{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { NgZone, PLATFORM_ID, Injectable, Inject, InjectionToken, inject, INJECTOR, ɵglobal, ErrorHandler, Optional, SkipSelf, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';\nimport * as i5 from '@ngxs/store/internals';\nimport { memoize, INITIAL_STATE_TOKEN, NgxsBootstrapper, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY } from '@ngxs/store/internals';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subject, BehaviorSubject, of, forkJoin, throwError, EMPTY, from, isObservable } from 'rxjs';\nimport { filter, map, share, shareReplay, take, exhaustMap, mergeMap, defaultIfEmpty, catchError, takeUntil, distinctUntilChanged, tap, startWith, pairwise } from 'rxjs/operators';\nimport { isStateOperator } from '@ngxs/store/operators';\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nfunction getActionTypeFromInstance(action) {\n  if (action.constructor && action.constructor.type) {\n    return action.constructor.type;\n  } else {\n    return action.type;\n  }\n}\n/**\n * Matches a action\n * @ignore\n */\nfunction actionMatcher(action1) {\n  const type1 = getActionTypeFromInstance(action1);\n  return function (action2) {\n    return type1 === getActionTypeFromInstance(action2);\n  };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nconst setValue = (obj, prop, val) => {\n  obj = Object.assign({}, obj);\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n    }\n    return acc && acc[part];\n  }, obj);\n  return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);\n/**\n * Simple object check.\n *\n *    isObject({a:1}) //=> true\n *    isObject(1) //=> false\n *\n * @ignore\n */\nconst isObject$1 = item => {\n  return item && typeof item === 'object' && !Array.isArray(item);\n};\n/**\n * Deep merge two objects.\n *\n *    mergeDeep({a:1, b:{x: 1, y:2}}, {b:{x: 3}, c:4}) //=> {a:1, b:{x:3, y:2}, c:4}\n *\n * @param base base object onto which `sources` will be applied\n */\nconst mergeDeep = (base, ...sources) => {\n  if (!sources.length) return base;\n  const source = sources.shift();\n  if (isObject$1(base) && isObject$1(source)) {\n    for (const key in source) {\n      if (isObject$1(source[key])) {\n        if (!base[key]) Object.assign(base, {\n          [key]: {}\n        });\n        mergeDeep(base[key], source[key]);\n      } else {\n        Object.assign(base, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(base, ...sources);\n};\nfunction throwStateNameError(name) {\n  throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\nfunction throwStateNamePropertyError() {\n  throw new Error(`States must register a 'name' property.`);\n}\nfunction throwStateUniqueError(current, newName, oldName) {\n  throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\nfunction throwStateDecoratorError(name) {\n  throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\nfunction throwActionDecoratorError() {\n  throw new Error('@Action() decorator cannot be used with static methods.');\n}\nfunction throwSelectorDecoratorError() {\n  throw new Error('Selectors only work on methods.');\n}\nfunction getZoneWarningMessage() {\n  return 'Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' + 'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' + 'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })';\n}\nfunction getUndecoratedStateInIvyWarningMessage(name) {\n  return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\nfunction throwSelectFactoryNotConnectedError() {\n  throw new Error('You have forgotten to import the NGXS module!');\n}\nfunction throwPatchingArrayError() {\n  throw new Error('Patching arrays is not supported.');\n}\nfunction throwPatchingPrimitiveError() {\n  throw new Error('Patching primitives is not supported.');\n}\nlet DispatchOutsideZoneNgxsExecutionStrategy = /*#__PURE__*/(() => {\n  class DispatchOutsideZoneNgxsExecutionStrategy {\n    constructor(_ngZone, _platformId) {\n      this._ngZone = _ngZone;\n      this._platformId = _platformId;\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        verifyZoneIsNotNooped(_ngZone);\n      }\n    }\n    enter(func) {\n      if (isPlatformServer(this._platformId)) {\n        return this.runInsideAngular(func);\n      }\n      return this.runOutsideAngular(func);\n    }\n    leave(func) {\n      return this.runInsideAngular(func);\n    }\n    runInsideAngular(func) {\n      if (NgZone.isInAngularZone()) {\n        return func();\n      }\n      return this._ngZone.run(func);\n    }\n    runOutsideAngular(func) {\n      if (NgZone.isInAngularZone()) {\n        return this._ngZone.runOutsideAngular(func);\n      }\n      return func();\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */DispatchOutsideZoneNgxsExecutionStrategy.ɵfac = function DispatchOutsideZoneNgxsExecutionStrategy_Factory(t) {\n    return new (t || DispatchOutsideZoneNgxsExecutionStrategy)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PLATFORM_ID));\n  };\n  DispatchOutsideZoneNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DispatchOutsideZoneNgxsExecutionStrategy,\n    factory: DispatchOutsideZoneNgxsExecutionStrategy.ɵfac,\n    providedIn: 'root'\n  });\n  return DispatchOutsideZoneNgxsExecutionStrategy;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n// Caretaker note: this should exist as a separate function and not a class method,\n// since class methods are not tree-shakable.\nfunction verifyZoneIsNotNooped(ngZone) {\n  // `NoopNgZone` is not exposed publicly as it doesn't expect\n  // to be used outside of the core Angular code, thus we just have\n  // to check if the zone doesn't extend or instanceof `NgZone`.\n  if (ngZone instanceof NgZone) {\n    return;\n  }\n  console.warn(getZoneWarningMessage());\n}\nconst ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');\nconst ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');\nconst FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');\nconst NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\nconst META_KEY = 'NGXS_META';\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nconst SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n/**\n * The NGXS config settings.\n */\nlet NgxsConfig = /*#__PURE__*/(() => {\n  class NgxsConfig {\n    constructor() {\n      /**\n       * Defining the default state before module initialization\n       * This is convenient if we need to create a define our own set of states.\n       * @deprecated will be removed after v4\n       * (default: {})\n       */\n      this.defaultsState = {};\n      /**\n       * Defining shared selector options\n       */\n      this.selectorOptions = {\n        injectContainerState: true,\n        suppressErrors: true // TODO: default is true in v3, will change in v4\n      };\n\n      this.compatibility = {\n        strictContentSecurityPolicy: false\n      };\n      this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */NgxsConfig.ɵfac = function NgxsConfig_Factory(t) {\n    return new (t || NgxsConfig)();\n  };\n  NgxsConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsConfig,\n    factory: function NgxsConfig_Factory(t) {\n      let r = null;\n      if (t) {\n        r = new t();\n      } else {\n        r = (options => mergeDeep(new NgxsConfig(), options))(i0.ɵɵinject(ROOT_OPTIONS));\n      }\n      return r;\n    },\n    providedIn: 'root'\n  });\n  return NgxsConfig;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nclass NgxsSimpleChange {\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n}\nlet NoopNgxsExecutionStrategy = /*#__PURE__*/(() => {\n  class NoopNgxsExecutionStrategy {\n    enter(func) {\n      return func();\n    }\n    leave(func) {\n      return func();\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */NoopNgxsExecutionStrategy.ɵfac = function NoopNgxsExecutionStrategy_Factory(t) {\n    return new (t || NoopNgxsExecutionStrategy)();\n  };\n  NoopNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NoopNgxsExecutionStrategy,\n    factory: NoopNgxsExecutionStrategy.ɵfac,\n    providedIn: 'root'\n  });\n  return NoopNgxsExecutionStrategy;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The strategy that might be provided by users through `options.executionStrategy`.\n */\nconst USER_PROVIDED_NGXS_EXECUTION_STRATEGY = new InjectionToken('USER_PROVIDED_NGXS_EXECUTION_STRATEGY');\n/*\n * Internal execution strategy injection token\n */\nconst NGXS_EXECUTION_STRATEGY = new InjectionToken('NGXS_EXECUTION_STRATEGY', {\n  providedIn: 'root',\n  factory: () => {\n    const injector = inject(INJECTOR);\n    const executionStrategy = injector.get(USER_PROVIDED_NGXS_EXECUTION_STRATEGY);\n    return executionStrategy ? injector.get(executionStrategy) : injector.get(typeof ɵglobal.Zone !== 'undefined' ? DispatchOutsideZoneNgxsExecutionStrategy : NoopNgxsExecutionStrategy);\n  }\n});\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nfunction ensureStoreMetadata$1(target) {\n  if (!target.hasOwnProperty(META_KEY)) {\n    const defaultMetadata = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n      makeRootSelector(context) {\n        return context.getStateGetter(defaultMetadata.name);\n      },\n      children: []\n    };\n    Object.defineProperty(target, META_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return getStoreMetadata$1(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nfunction getStoreMetadata$1(target) {\n  return target[META_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nfunction ensureSelectorMetadata$1(target) {\n  if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n    const defaultMetadata = {\n      makeRootSelector: null,\n      originalFn: null,\n      containerClass: null,\n      selectorName: null,\n      getSelectorOptions: () => ({})\n    };\n    Object.defineProperty(target, SELECTOR_META_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return getSelectorMetadata$1(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nfunction getSelectorMetadata$1(target) {\n  return target[SELECTOR_META_KEY];\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths) {\n  const copyOfPaths = paths.slice();\n  return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths) {\n  const segments = paths;\n  let seg = 'store.' + segments[0];\n  let i = 0;\n  const l = segments.length;\n  let expr = seg;\n  while (++i < l) {\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n  }\n  const fn = new Function('store', 'return ' + expr + ';');\n  return fn;\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nfunction propGetter(paths, config) {\n  if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\n    return compliantPropGetter(paths);\n  } else {\n    return fastPropGetter(paths);\n  }\n}\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nfunction buildGraph(stateClasses) {\n  const findName = stateClass => {\n    const meta = stateClasses.find(g => g === stateClass);\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {\n      throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n    }\n    return meta[META_KEY].name;\n  };\n  return stateClasses.reduce((result, stateClass) => {\n    const {\n      name,\n      children\n    } = stateClass[META_KEY];\n    result[name] = (children || []).map(findName);\n    return result;\n  }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nfunction nameToState(states) {\n  return states.reduce((result, stateClass) => {\n    const meta = stateClass[META_KEY];\n    result[meta.name] = stateClass;\n    return result;\n  }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nfunction findFullParentPath(obj, newObj = {}) {\n  const visit = (child, keyToFind) => {\n    for (const key in child) {\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n        const parent = visit(child, key);\n        return parent !== null ? `${parent}.${key}` : key;\n      }\n    }\n    return null;\n  };\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const parent = visit(obj, key);\n      newObj[key] = parent ? `${parent}.${key}` : key;\n    }\n  }\n  return newObj;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nfunction topologicalSort(graph) {\n  const sorted = [];\n  const visited = {};\n  const visit = (name, ancestors = []) => {\n    if (!Array.isArray(ancestors)) {\n      ancestors = [];\n    }\n    ancestors.push(name);\n    visited[name] = true;\n    graph[name].forEach(dep => {\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {\n        throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n      }\n      if (visited[dep]) {\n        return;\n      }\n      visit(dep, ancestors.slice(0));\n    });\n    if (sorted.indexOf(name) < 0) {\n      sorted.push(name);\n    }\n  };\n  Object.keys(graph).forEach(k => visit(k));\n  return sorted.reverse();\n}\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n */\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null || typeof obj === 'function';\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nfunction ofAction(...allowedTypes) {\n  return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nfunction ofActionDispatched(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"DISPATCHED\" /* Dispatched */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nfunction ofActionSuccessful(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"SUCCESSFUL\" /* Successful */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nfunction ofActionCanceled(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"CANCELED\" /* Canceled */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nfunction ofActionCompleted(...allowedTypes) {\n  const allowedStatuses = [\"SUCCESSFUL\" /* Successful */, \"CANCELED\" /* Canceled */, \"ERRORED\" /* Errored */];\n\n  return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nfunction ofActionErrored(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"ERRORED\" /* Errored */]);\n}\n\nfunction ofActionOperator(allowedTypes, statuses,\n// This actually could've been `OperatorFunction<ActionContext, ActionCompletion | any>`,\n// since it maps either to `ctx.action` OR to `ActionCompletion`. But `ActionCompleteion | any`\n// defaults to `any`, thus there is no sense from union type.\nmapOperator = mapAction) {\n  const allowedMap = createAllowedActionTypesMap(allowedTypes);\n  const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n  return function (o) {\n    return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n  };\n}\nfunction filterStatus(allowedTypes, allowedStatuses) {\n  return filter(ctx => {\n    const actionType = getActionTypeFromInstance(ctx.action);\n    const typeMatch = allowedTypes[actionType];\n    const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n    return typeMatch && statusMatch;\n  });\n}\nfunction mapActionResult() {\n  return map(({\n    action,\n    status,\n    error\n  }) => {\n    return {\n      action,\n      result: {\n        successful: \"SUCCESSFUL\" /* Successful */ === status,\n        canceled: \"CANCELED\" /* Canceled */ === status,\n        error\n      }\n    };\n  });\n}\nfunction mapAction() {\n  return map(ctx => ctx.action);\n}\nfunction createAllowedActionTypesMap(types) {\n  return types.reduce((filterMap, klass) => {\n    filterMap[getActionTypeFromInstance(klass)] = true;\n    return filterMap;\n  }, {});\n}\nfunction createAllowedStatusesMap(statuses) {\n  return statuses.reduce((filterMap, status) => {\n    filterMap[status] = true;\n    return filterMap;\n  }, {});\n}\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nfunction leaveNgxs(ngxsExecutionStrategy) {\n  return source => {\n    return new Observable(sink => {\n      return source.subscribe({\n        next(value) {\n          ngxsExecutionStrategy.leave(() => sink.next(value));\n        },\n        error(error) {\n          ngxsExecutionStrategy.leave(() => sink.error(error));\n        },\n        complete() {\n          ngxsExecutionStrategy.leave(() => sink.complete());\n        }\n      });\n    });\n  };\n}\nlet InternalNgxsExecutionStrategy = /*#__PURE__*/(() => {\n  class InternalNgxsExecutionStrategy {\n    constructor(_executionStrategy) {\n      this._executionStrategy = _executionStrategy;\n    }\n    enter(func) {\n      return this._executionStrategy.enter(func);\n    }\n    leave(func) {\n      return this._executionStrategy.leave(func);\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */InternalNgxsExecutionStrategy.ɵfac = function InternalNgxsExecutionStrategy_Factory(t) {\n    return new (t || InternalNgxsExecutionStrategy)(i0.ɵɵinject(NGXS_EXECUTION_STRATEGY));\n  };\n  InternalNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalNgxsExecutionStrategy,\n    factory: InternalNgxsExecutionStrategy.ɵfac,\n    providedIn: 'root'\n  });\n  return InternalNgxsExecutionStrategy;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * This wraps the provided function, and will enforce the following:\n * - The calls will execute in the order that they are made\n * - A call will only be initiated when the previous call has completed\n * - If there is a call currently executing then the new call will be added\n *   to the queue and the function will return immediately\n *\n * NOTE: The following assumptions about the operation must hold true:\n * - The operation is synchronous in nature\n * - If any asynchronous side effects of the call exist, it should not\n *   have any bearing on the correctness of the next call in the queue\n * - The operation has a void return\n * - The caller should not assume that the call has completed upon\n *   return of the function\n * - The caller can assume that all the queued calls will complete\n *   within the current microtask\n * - The only way that a call will encounter another call in the queue\n *   would be if the call at the front of the queue initiated this call\n *   as part of its synchronous execution\n */\nfunction orderedQueueOperation(operation) {\n  const callsQueue = [];\n  let busyPushingNext = false;\n  return function callOperation(...args) {\n    if (busyPushingNext) {\n      callsQueue.unshift(args);\n      return;\n    }\n    busyPushingNext = true;\n    operation(...args);\n    while (callsQueue.length > 0) {\n      const nextCallArgs = callsQueue.pop();\n      nextCallArgs && operation(...nextCallArgs);\n    }\n    busyPushingNext = false;\n  };\n}\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedSubject extends Subject {\n  constructor() {\n    super(...arguments);\n    this._orderedNext = orderedQueueOperation(value => super.next(value));\n  }\n  next(value) {\n    this._orderedNext(value);\n  }\n}\n/**\n * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard BehaviorSubject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new BehaviorSubject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedBehaviorSubject extends BehaviorSubject {\n  constructor(value) {\n    super(value);\n    this._orderedNext = orderedQueueOperation(value => super.next(value));\n    this._currentValue = value;\n  }\n  getValue() {\n    return this._currentValue;\n  }\n  next(value) {\n    this._currentValue = value;\n    this._orderedNext(value);\n  }\n}\n\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\nlet InternalActions = /*#__PURE__*/(() => {\n  class InternalActions extends OrderedSubject {\n    ngOnDestroy() {\n      this.complete();\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */InternalActions.ɵfac = /* @__PURE__ */function () {\n    let ɵInternalActions_BaseFactory;\n    return function InternalActions_Factory(t) {\n      return (ɵInternalActions_BaseFactory || (ɵInternalActions_BaseFactory = i0.ɵɵgetInheritedFactory(InternalActions)))(t || InternalActions);\n    };\n  }();\n  InternalActions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalActions,\n    factory: InternalActions.ɵfac,\n    providedIn: 'root'\n  });\n  return InternalActions;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\nlet Actions = /*#__PURE__*/(() => {\n  class Actions extends Observable {\n    constructor(internalActions$, internalExecutionStrategy) {\n      const sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy),\n      // The `InternalActions` subject emits outside of the Angular zone.\n      // We have to re-enter the Angular zone for any incoming consumer.\n      // The `share()` operator reduces the number of change detections.\n      // This would call leave only once for any stream emission across all active subscribers.\n      share());\n      super(observer => {\n        const childSubscription = sharedInternalActions$.subscribe({\n          next: ctx => observer.next(ctx),\n          error: error => observer.error(error),\n          complete: () => observer.complete()\n        });\n        observer.add(childSubscription);\n      });\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */Actions.ɵfac = function Actions_Factory(t) {\n    return new (t || Actions)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalNgxsExecutionStrategy));\n  };\n  Actions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Actions,\n    factory: Actions.ɵfac,\n    providedIn: 'root'\n  });\n  return Actions;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\nconst compose = funcs => (...args) => {\n  const curr = funcs.shift();\n  return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\n};\n\n/**\n * This operator is used for piping the observable result\n * from the `dispatch()`. It has a \"smart\" error handling\n * strategy that allows us to decide whether we propagate\n * errors to Angular's `ErrorHandler` or enable users to\n * handle them manually. We consider following cases:\n * 1) `store.dispatch()` (no subscribe) -> call `handleError()`\n * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`\n * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`\n * 4) `toPromise()` without `catch` -> do `handleError()`\n * 5) `toPromise()` with `catch` -> don't `handleError()`\n */\nfunction ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {\n  return source => {\n    let subscribed = false;\n    source.subscribe({\n      error: error => {\n        // Do not trigger change detection for a microtask. This depends on the execution\n        // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`\n        // leaves the Angular zone.\n        ngxsExecutionStrategy.enter(() => Promise.resolve().then(() => {\n          if (!subscribed) {\n            ngxsExecutionStrategy.leave(() => internalErrorReporter.reportErrorSafely(error));\n          }\n        }));\n      }\n    });\n    return new Observable(subscriber => {\n      subscribed = true;\n      return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);\n    });\n  };\n}\nlet InternalErrorReporter = /*#__PURE__*/(() => {\n  class InternalErrorReporter {\n    constructor(_injector) {\n      this._injector = _injector;\n      /** Will be set lazily to be backward compatible. */\n      this._errorHandler = null;\n    }\n    reportErrorSafely(error) {\n      if (this._errorHandler === null) {\n        this._errorHandler = this._injector.get(ErrorHandler);\n      }\n      // The `try-catch` is used to avoid handling the error twice. Suppose we call\n      // `handleError` which re-throws the error internally. The re-thrown error will\n      // be caught by zone.js which will then get to the `zone.onError.emit()` and the\n      // `onError` subscriber will call `handleError` again.\n      try {\n        this._errorHandler.handleError(error);\n      } catch (_a) {}\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */InternalErrorReporter.ɵfac = function InternalErrorReporter_Factory(t) {\n    return new (t || InternalErrorReporter)(i0.ɵɵinject(i0.Injector));\n  };\n  InternalErrorReporter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalErrorReporter,\n    factory: InternalErrorReporter.ɵfac,\n    providedIn: 'root'\n  });\n  return InternalErrorReporter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\nlet StateStream = /*#__PURE__*/(() => {\n  class StateStream extends OrderedBehaviorSubject {\n    constructor() {\n      super({});\n    }\n    ngOnDestroy() {\n      // The `StateStream` should never emit values once the root view is removed, e.g. when the `NgModuleRef.destroy()` is called.\n      // This will eliminate memory leaks in server-side rendered apps where the `StateStream` is created per each HTTP request, users\n      // might forget to unsubscribe from `store.select` or `store.subscribe`, thus this will lead to huge memory leaks in SSR apps.\n      this.complete();\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */StateStream.ɵfac = function StateStream_Factory(t) {\n    return new (t || StateStream)();\n  };\n  StateStream.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StateStream,\n    factory: StateStream.ɵfac,\n    providedIn: 'root'\n  });\n  return StateStream;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PluginManager = /*#__PURE__*/(() => {\n  class PluginManager {\n    constructor(_parentManager, _pluginHandlers) {\n      this._parentManager = _parentManager;\n      this._pluginHandlers = _pluginHandlers;\n      this.plugins = [];\n      this.registerHandlers();\n    }\n    get rootPlugins() {\n      return this._parentManager && this._parentManager.plugins || this.plugins;\n    }\n    registerHandlers() {\n      const pluginHandlers = this.getPluginHandlers();\n      this.rootPlugins.push(...pluginHandlers);\n    }\n    getPluginHandlers() {\n      const handlers = this._pluginHandlers || [];\n      return handlers.map(plugin => plugin.handle ? plugin.handle.bind(plugin) : plugin);\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */PluginManager.ɵfac = function PluginManager_Factory(t) {\n    return new (t || PluginManager)(i0.ɵɵinject(PluginManager, 12), i0.ɵɵinject(NGXS_PLUGINS, 8));\n  };\n  PluginManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: PluginManager,\n    factory: PluginManager.ɵfac\n  });\n  return PluginManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\nlet InternalDispatchedActionResults = /*#__PURE__*/(() => {\n  class InternalDispatchedActionResults extends Subject {}\n  /** @nocollapse */\n  /** @nocollapse */InternalDispatchedActionResults.ɵfac = /* @__PURE__ */function () {\n    let ɵInternalDispatchedActionResults_BaseFactory;\n    return function InternalDispatchedActionResults_Factory(t) {\n      return (ɵInternalDispatchedActionResults_BaseFactory || (ɵInternalDispatchedActionResults_BaseFactory = i0.ɵɵgetInheritedFactory(InternalDispatchedActionResults)))(t || InternalDispatchedActionResults);\n    };\n  }();\n  InternalDispatchedActionResults.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalDispatchedActionResults,\n    factory: InternalDispatchedActionResults.ɵfac,\n    providedIn: 'root'\n  });\n  return InternalDispatchedActionResults;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet InternalDispatcher = /*#__PURE__*/(() => {\n  class InternalDispatcher {\n    constructor(_actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy, _internalErrorReporter) {\n      this._actions = _actions;\n      this._actionResults = _actionResults;\n      this._pluginManager = _pluginManager;\n      this._stateStream = _stateStream;\n      this._ngxsExecutionStrategy = _ngxsExecutionStrategy;\n      this._internalErrorReporter = _internalErrorReporter;\n    }\n    /**\n     * Dispatches event(s).\n     */\n    dispatch(actionOrActions) {\n      const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n      return result.pipe(ngxsErrorHandler(this._internalErrorReporter, this._ngxsExecutionStrategy));\n    }\n    dispatchByEvents(actionOrActions) {\n      if (Array.isArray(actionOrActions)) {\n        if (actionOrActions.length === 0) return of(this._stateStream.getValue());\n        return forkJoin(actionOrActions.map(action => this.dispatchSingle(action)));\n      } else {\n        return this.dispatchSingle(actionOrActions);\n      }\n    }\n    dispatchSingle(action) {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        const type = getActionTypeFromInstance(action);\n        if (!type) {\n          const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n          return throwError(error);\n        }\n      }\n      const prevState = this._stateStream.getValue();\n      const plugins = this._pluginManager.plugins;\n      return compose([...plugins, (nextState, nextAction) => {\n        if (nextState !== prevState) {\n          this._stateStream.next(nextState);\n        }\n        const actionResult$ = this.getActionResultStream(nextAction);\n        actionResult$.subscribe(ctx => this._actions.next(ctx));\n        this._actions.next({\n          action: nextAction,\n          status: \"DISPATCHED\" /* Dispatched */\n        });\n        return this.createDispatchObservable(actionResult$);\n      }])(prevState, action).pipe(shareReplay());\n    }\n    getActionResultStream(action) {\n      return this._actionResults.pipe(filter(ctx => ctx.action === action && ctx.status !== \"DISPATCHED\" /* Dispatched */), take(1), shareReplay());\n    }\n    createDispatchObservable(actionResult$) {\n      return actionResult$.pipe(exhaustMap(ctx => {\n        switch (ctx.status) {\n          case \"SUCCESSFUL\" /* Successful */:\n            return of(this._stateStream.getValue());\n          case \"ERRORED\" /* Errored */:\n            return throwError(ctx.error);\n          default:\n            return EMPTY;\n        }\n      })).pipe(shareReplay());\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */InternalDispatcher.ɵfac = function InternalDispatcher_Factory(t) {\n    return new (t || InternalDispatcher)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(PluginManager), i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(InternalErrorReporter));\n  };\n  InternalDispatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalDispatcher,\n    factory: InternalDispatcher.ɵfac,\n    providedIn: 'root'\n  });\n  return InternalDispatcher;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nconst deepFreeze = o => {\n  Object.freeze(o);\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n};\n\n/**\n * @ignore\n */\nlet InternalStateOperations = /*#__PURE__*/(() => {\n  class InternalStateOperations {\n    constructor(_stateStream, _dispatcher, _config) {\n      this._stateStream = _stateStream;\n      this._dispatcher = _dispatcher;\n      this._config = _config;\n    }\n    /**\n     * Returns the root state operators.\n     */\n    getRootStateOperations() {\n      const rootStateOperations = {\n        getState: () => this._stateStream.getValue(),\n        setState: newState => this._stateStream.next(newState),\n        dispatch: actionOrActions => this._dispatcher.dispatch(actionOrActions)\n      };\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        return this._config.developmentMode ? ensureStateAndActionsAreImmutable(rootStateOperations) : rootStateOperations;\n      } else {\n        return rootStateOperations;\n      }\n    }\n    setStateToTheCurrentWithNew(results) {\n      const stateOperations = this.getRootStateOperations();\n      // Get our current stream\n      const currentState = stateOperations.getState();\n      // Set the state to the current + new\n      stateOperations.setState(Object.assign(Object.assign({}, currentState), results.defaults));\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */InternalStateOperations.ɵfac = function InternalStateOperations_Factory(t) {\n    return new (t || InternalStateOperations)(i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalDispatcher), i0.ɵɵinject(NgxsConfig));\n  };\n  InternalStateOperations.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: InternalStateOperations,\n    factory: InternalStateOperations.ɵfac,\n    providedIn: 'root'\n  });\n  return InternalStateOperations;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction ensureStateAndActionsAreImmutable(root) {\n  return {\n    getState: () => root.getState(),\n    setState: value => {\n      const frozenValue = deepFreeze(value);\n      return root.setState(frozenValue);\n    },\n    dispatch: actions => {\n      return root.dispatch(actions);\n    }\n  };\n}\nfunction simplePatch(value) {\n  return existingState => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (Array.isArray(value)) {\n        throwPatchingArrayError();\n      } else if (typeof value !== 'object') {\n        throwPatchingPrimitiveError();\n      }\n    }\n    const newState = Object.assign({}, existingState);\n    for (const key in value) {\n      // deep clone for patch compatibility\n      newState[key] = value[key];\n    }\n    return newState;\n  };\n}\n\n/**\n * State Context factory class\n * @ignore\n */\nlet StateContextFactory = /*#__PURE__*/(() => {\n  class StateContextFactory {\n    constructor(_internalStateOperations) {\n      this._internalStateOperations = _internalStateOperations;\n    }\n    /**\n     * Create the state context\n     */\n    createStateContext(mappedStore) {\n      const root = this._internalStateOperations.getRootStateOperations();\n      return {\n        getState() {\n          const currentAppState = root.getState();\n          return getState(currentAppState, mappedStore.path);\n        },\n        patchState(val) {\n          const currentAppState = root.getState();\n          const patchOperator = simplePatch(val);\n          return setStateFromOperator(root, currentAppState, patchOperator, mappedStore.path);\n        },\n        setState(val) {\n          const currentAppState = root.getState();\n          return isStateOperator(val) ? setStateFromOperator(root, currentAppState, val, mappedStore.path) : setStateValue(root, currentAppState, val, mappedStore.path);\n        },\n        dispatch(actions) {\n          return root.dispatch(actions);\n        }\n      };\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */StateContextFactory.ɵfac = function StateContextFactory_Factory(t) {\n    return new (t || StateContextFactory)(i0.ɵɵinject(InternalStateOperations));\n  };\n  StateContextFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StateContextFactory,\n    factory: StateContextFactory.ɵfac,\n    providedIn: 'root'\n  });\n  return StateContextFactory;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction setStateValue(root, currentAppState, newValue, path) {\n  const newAppState = setValue(currentAppState, path, newValue);\n  root.setState(newAppState);\n  return newAppState;\n  // In doing this refactoring I noticed that there is a 'bug' where the\n  // application state is returned instead of this state slice.\n  // This has worked this way since the beginning see:\n  // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n  // This needs to be fixed, but is a 'breaking' change.\n  // I will do this fix in a subsequent PR and we can decide how to handle it.\n}\n\nfunction setStateFromOperator(root, currentAppState, stateOperator, path) {\n  const local = getState(currentAppState, path);\n  const newValue = stateOperator(local);\n  return setStateValue(root, currentAppState, newValue, path);\n}\nfunction getState(currentAppState, path) {\n  return getValue(currentAppState, path);\n}\nconst stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\nfunction ensureStateNameIsValid(name) {\n  if (!name) {\n    throwStateNamePropertyError();\n  } else if (!stateNameRegex.test(name)) {\n    throwStateNameError(name);\n  }\n}\nfunction ensureStateNameIsUnique(stateName, state, statesByName) {\n  const existingState = statesByName[stateName];\n  if (existingState && existingState !== state) {\n    throwStateUniqueError(stateName, state.name, existingState.name);\n  }\n}\nfunction ensureStatesAreDecorated(stateClasses) {\n  stateClasses.forEach(stateClass => {\n    if (!getStoreMetadata$1(stateClass)) {\n      throwStateDecoratorError(stateClass.name);\n    }\n  });\n}\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nfunction ensureStateClassIsInjectable(stateClass) {\n  if (jit_hasInjectableAnnotation(stateClass) || aot_hasNgInjectableDef(stateClass)) {\n    return;\n  }\n  console.warn(getUndecoratedStateInIvyWarningMessage(stateClass.name));\n}\nfunction aot_hasNgInjectableDef(stateClass) {\n  // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n  // AOT mode because this property is added before runtime. If an application is running in\n  // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n  // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n  return !!stateClass.ɵprov;\n}\nfunction jit_hasInjectableAnnotation(stateClass) {\n  // `ɵprov` doesn't exist in JIT mode (for instance when running unit tests with Jest).\n  const annotations = stateClass.__annotations__ || [];\n  return annotations.some(annotation => (annotation === null || annotation === void 0 ? void 0 : annotation.ngMetadataName) === 'Injectable');\n}\n\n/**\n * Init action\n */\nlet InitState = /*#__PURE__*/(() => {\n  class InitState {}\n  InitState.type = '@@INIT';\n  /**\n   * Update action\n   */\n  return InitState;\n})();\nlet UpdateState = /*#__PURE__*/(() => {\n  class UpdateState {\n    constructor(addedStates) {\n      this.addedStates = addedStates;\n    }\n  }\n  UpdateState.type = '@@UPDATE_STATE';\n  return UpdateState;\n})();\nconst NGXS_DEVELOPMENT_OPTIONS = new InjectionToken('NGXS_DEVELOPMENT_OPTIONS', {\n  providedIn: 'root',\n  factory: () => ({\n    warnOnUnhandledActions: true\n  })\n});\nlet NgxsUnhandledActionsLogger = /*#__PURE__*/(() => {\n  class NgxsUnhandledActionsLogger {\n    constructor(options) {\n      /**\n       * These actions should be ignored by default; the user can increase this\n       * list in the future via the `ignoreActions` method.\n       */\n      this._ignoredActions = new Set([InitState.type, UpdateState.type]);\n      if (typeof options.warnOnUnhandledActions === 'object') {\n        this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n      }\n    }\n    /**\n     * Adds actions to the internal list of actions that should be ignored.\n     */\n    ignoreActions(...actions) {\n      for (const action of actions) {\n        this._ignoredActions.add(action.type);\n      }\n    }\n    /** @internal */\n    warn(action) {\n      const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n      if (actionShouldBeIgnored) {\n        return;\n      }\n      action = action.constructor && action.constructor.name !== 'Object' ? action.constructor.name : action.type;\n      console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */NgxsUnhandledActionsLogger.ɵfac = function NgxsUnhandledActionsLogger_Factory(t) {\n    return new (t || NgxsUnhandledActionsLogger)(i0.ɵɵinject(NGXS_DEVELOPMENT_OPTIONS));\n  };\n  NgxsUnhandledActionsLogger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsUnhandledActionsLogger,\n    factory: NgxsUnhandledActionsLogger.ɵfac\n  });\n  return NgxsUnhandledActionsLogger;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n/**\n * The `StateFactory` class adds root and feature states to the graph.\n * This extracts state names from state classes, checks if they already\n * exist in the global graph, throws errors if their names are invalid, etc.\n * See its constructor, state factories inject state factories that are\n * parent-level providers. This is required to get feature states from the\n * injector on the same level.\n *\n * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.\n * The `StateFactory` is initialized on the feature level and goes through `...states`\n * to get them from the injector through `injector.get(state)`.\n * @ignore\n */\nlet StateFactory = /*#__PURE__*/(() => {\n  class StateFactory {\n    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {\n      this._injector = _injector;\n      this._config = _config;\n      this._parentFactory = _parentFactory;\n      this._actions = _actions;\n      this._actionResults = _actionResults;\n      this._stateContextFactory = _stateContextFactory;\n      this._initialState = _initialState;\n      this._actionsSubscription = null;\n      this._states = [];\n      this._statesByName = {};\n      this._statePaths = {};\n      this.getRuntimeSelectorContext = memoize(() => {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const stateFactory = this;\n        function resolveGetter(key) {\n          const path = stateFactory.statePaths[key];\n          return path ? propGetter(path.split('.'), stateFactory._config) : null;\n        }\n        const context = this._parentFactory ? this._parentFactory.getRuntimeSelectorContext() : {\n          getStateGetter(key) {\n            let getter = resolveGetter(key);\n            if (getter) {\n              return getter;\n            }\n            return (...args) => {\n              // Late loaded getter\n              if (!getter) {\n                getter = resolveGetter(key);\n              }\n              return getter ? getter(...args) : undefined;\n            };\n          },\n          getSelectorOptions(localOptions) {\n            const globalSelectorOptions = stateFactory._config.selectorOptions;\n            return Object.assign(Object.assign({}, globalSelectorOptions), localOptions || {});\n          }\n        };\n        return context;\n      });\n    }\n    get states() {\n      return this._parentFactory ? this._parentFactory.states : this._states;\n    }\n    get statesByName() {\n      return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n    }\n    get statePaths() {\n      return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n    }\n    static _cloneDefaults(defaults) {\n      let value = defaults;\n      if (Array.isArray(defaults)) {\n        value = defaults.slice();\n      } else if (isObject(defaults)) {\n        value = Object.assign({}, defaults);\n      } else if (defaults === undefined) {\n        value = {};\n      }\n      return value;\n    }\n    ngOnDestroy() {\n      var _a;\n      (_a = this._actionsSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    }\n    /**\n     * Add a new state to the global defs.\n     */\n    add(stateClasses) {\n      if (NG_DEV_MODE) {\n        ensureStatesAreDecorated(stateClasses);\n      }\n      const {\n        newStates\n      } = this.addToStatesMap(stateClasses);\n      if (!newStates.length) return [];\n      const stateGraph = buildGraph(newStates);\n      const sortedStates = topologicalSort(stateGraph);\n      const paths = findFullParentPath(stateGraph);\n      const nameGraph = nameToState(newStates);\n      const bootstrappedStores = [];\n      for (const name of sortedStates) {\n        const stateClass = nameGraph[name];\n        const path = paths[name];\n        const meta = stateClass[META_KEY];\n        this.addRuntimeInfoToMeta(meta, path);\n        // Note: previously we called `ensureStateClassIsInjectable` within the\n        // `State` decorator. This check is moved here because the `ɵprov` property\n        // will not exist on the class in JIT mode (because it's set asynchronously\n        // during JIT compilation through `Object.defineProperty`).\n        if (NG_DEV_MODE) {\n          ensureStateClassIsInjectable(stateClass);\n        }\n        const stateMap = {\n          name,\n          path,\n          isInitialised: false,\n          actions: meta.actions,\n          instance: this._injector.get(stateClass),\n          defaults: StateFactory._cloneDefaults(meta.defaults)\n        };\n        // ensure our store hasn't already been added\n        // but don't throw since it could be lazy\n        // loaded from different paths\n        if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n          bootstrappedStores.push(stateMap);\n        }\n        this.states.push(stateMap);\n      }\n      return bootstrappedStores;\n    }\n    /**\n     * Add a set of states to the store and return the defaults\n     */\n    addAndReturnDefaults(stateClasses) {\n      const classes = stateClasses || [];\n      const mappedStores = this.add(classes);\n      const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n      return {\n        defaults,\n        states: mappedStores\n      };\n    }\n    connectActionHandlers() {\n      // Note: We have to connect actions only once when the `StateFactory`\n      //       is being created for the first time. This checks if we're in\n      //       a child state factory and the parent state factory already exists.\n      if (this._parentFactory || this._actionsSubscription !== null) {\n        return;\n      }\n      const dispatched$ = new Subject();\n      this._actionsSubscription = this._actions.pipe(filter(ctx => ctx.status === \"DISPATCHED\" /* Dispatched */), mergeMap(ctx => {\n        dispatched$.next(ctx);\n        const action = ctx.action;\n        return this.invokeActions(dispatched$, action).pipe(map(() => ({\n          action,\n          status: \"SUCCESSFUL\" /* Successful */\n        })), defaultIfEmpty({\n          action,\n          status: \"CANCELED\" /* Canceled */\n        }), catchError(error => of({\n          action,\n          status: \"ERRORED\" /* Errored */,\n          error\n        })));\n      })).subscribe(ctx => this._actionResults.next(ctx));\n    }\n    /**\n     * Invoke actions on the states.\n     */\n    invokeActions(dispatched$, action) {\n      const type = getActionTypeFromInstance(action);\n      const results = [];\n      // Determines whether the dispatched action has been handled, this is assigned\n      // to `true` within the below `for` loop if any `actionMetas` has been found.\n      let actionHasBeenHandled = false;\n      for (const metadata of this.states) {\n        const actionMetas = metadata.actions[type];\n        if (actionMetas) {\n          for (const actionMeta of actionMetas) {\n            const stateContext = this._stateContextFactory.createStateContext(metadata);\n            try {\n              let result = metadata.instance[actionMeta.fn](stateContext, action);\n              if (result instanceof Promise) {\n                result = from(result);\n              }\n              if (isObservable(result)) {\n                // If this observable has been completed w/o emitting\n                // any value then we wouldn't want to complete the whole chain\n                // of actions. Since if any observable completes then\n                // action will be canceled.\n                // For instance if any action handler would've had such statement:\n                // `handler(ctx) { return EMPTY; }`\n                // then the action will be canceled.\n                // See https://github.com/ngxs/store/issues/1568\n                result = result.pipe(mergeMap(value => {\n                  if (value instanceof Promise) {\n                    return from(value);\n                  }\n                  if (isObservable(value)) {\n                    return value;\n                  }\n                  return of(value);\n                }), defaultIfEmpty({}));\n                if (actionMeta.options.cancelUncompleted) {\n                  // todo: ofActionDispatched should be used with action class\n                  result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));\n                }\n              } else {\n                result = of({}).pipe(shareReplay());\n              }\n              results.push(result);\n            } catch (e) {\n              results.push(throwError(e));\n            }\n            actionHasBeenHandled = true;\n          }\n        }\n      }\n      // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n      // only during development.\n      if (NG_DEV_MODE && !actionHasBeenHandled) {\n        const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);\n        // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n        // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n        // didn't return `null` so we may ensure the module has been imported.\n        if (unhandledActionsLogger) {\n          unhandledActionsLogger.warn(action);\n        }\n      }\n      if (!results.length) {\n        results.push(of({}));\n      }\n      return forkJoin(results);\n    }\n    addToStatesMap(stateClasses) {\n      const newStates = [];\n      const statesMap = this.statesByName;\n      for (const stateClass of stateClasses) {\n        const stateName = getStoreMetadata$1(stateClass).name;\n        if (NG_DEV_MODE) {\n          ensureStateNameIsUnique(stateName, stateClass, statesMap);\n        }\n        const unmountedState = !statesMap[stateName];\n        if (unmountedState) {\n          newStates.push(stateClass);\n          statesMap[stateName] = stateClass;\n        }\n      }\n      return {\n        newStates\n      };\n    }\n    addRuntimeInfoToMeta(meta, path) {\n      this.statePaths[meta.name] = path;\n      // TODO: v4 - we plan to get rid of the path property because it is non-deterministic\n      // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n      // We will need to come up with an alternative in v4 because this is used by many plugins\n      meta.path = path;\n    }\n    hasBeenMountedAndBootstrapped(name, path) {\n      const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n      // This checks whether a state has been already added to the global graph and\n      // its lifecycle is in 'bootstrapped' state.\n      return this.statesByName[name] && valueIsBootstrappedInInitialState;\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */StateFactory.ɵfac = function StateFactory_Factory(t) {\n    return new (t || StateFactory)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(StateFactory, 12), i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n  };\n  StateFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: StateFactory,\n    factory: StateFactory.ɵfac\n  });\n  return StateFactory;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {\n  return context => {\n    const {\n      argumentSelectorFunctions,\n      selectorOptions\n    } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n    return function selectFromRoot(rootState) {\n      // Determine arguments from the app state using the selectors\n      const results = argumentSelectorFunctions.map(argFn => argFn(rootState));\n      // if the lambda tries to access a something on the\n      // state that doesn't exist, it will throw a TypeError.\n      // since this is quite usual behaviour, we simply return undefined if so.\n      try {\n        return memoizedSelectorFn(...results);\n      } catch (ex) {\n        if (ex instanceof TypeError && selectorOptions.suppressErrors) {\n          return undefined;\n        }\n        throw ex;\n      }\n    };\n  };\n}\nfunction createMemoizedSelectorFn(originalFn, creationMetadata) {\n  const containerClass = creationMetadata && creationMetadata.containerClass;\n  const wrappedFn = function wrappedSelectorFn(...args) {\n    const returnValue = originalFn.apply(containerClass, args);\n    if (returnValue instanceof Function) {\n      const innerMemoizedFn = memoize.apply(null, [returnValue]);\n      return innerMemoizedFn;\n    }\n    return returnValue;\n  };\n  const memoizedFn = memoize(wrappedFn);\n  Object.setPrototypeOf(memoizedFn, originalFn);\n  return memoizedFn;\n}\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n  const localSelectorOptions = selectorMetaData.getSelectorOptions();\n  const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n  const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n  const argumentSelectorFunctions = selectorsToApply.map(selector => {\n    const factory = getRootSelectorFactory(selector);\n    return factory(context);\n  });\n  return {\n    selectorOptions,\n    argumentSelectorFunctions\n  };\n}\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n  const selectorsToApply = [];\n  const canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;\n  if (containerClass && canInjectContainerState) {\n    // If we are on a state class, add it as the first selector parameter\n    const metadata = getStoreMetadata$1(containerClass);\n    if (metadata) {\n      selectorsToApply.push(containerClass);\n    }\n  }\n  if (selectors) {\n    selectorsToApply.push(...selectors);\n  }\n  return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nfunction getRootSelectorFactory(selector) {\n  const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n  return metadata && metadata.makeRootSelector || (() => selector);\n}\n\n// tslint:disable:unified-signatures\nlet Store = /*#__PURE__*/(() => {\n  class Store {\n    constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {\n      this._stateStream = _stateStream;\n      this._internalStateOperations = _internalStateOperations;\n      this._config = _config;\n      this._internalExecutionStrategy = _internalExecutionStrategy;\n      this._stateFactory = _stateFactory;\n      /**\n       * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n       * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n       * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n       */\n      this._selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({\n        bufferSize: 1,\n        refCount: true\n      }));\n      this.initStateStream(initialStateValue);\n    }\n    /**\n     * Dispatches event(s).\n     */\n    dispatch(actionOrActions) {\n      return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n    }\n    select(selector) {\n      const selectorFn = this.getStoreBoundSelectorFn(selector);\n      return this._selectableStateStream.pipe(map(selectorFn), catchError(err => {\n        // if error is TypeError we swallow it to prevent usual errors with property access\n        const {\n          suppressErrors\n        } = this._config.selectorOptions;\n        if (err instanceof TypeError && suppressErrors) {\n          return of(undefined);\n        }\n        // rethrow other errors\n        return throwError(err);\n      }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n    }\n    selectOnce(selector) {\n      return this.select(selector).pipe(take(1));\n    }\n    selectSnapshot(selector) {\n      const selectorFn = this.getStoreBoundSelectorFn(selector);\n      return selectorFn(this._stateStream.getValue());\n    }\n    /**\n     * Allow the user to subscribe to the root of the state\n     */\n    subscribe(fn) {\n      return this._selectableStateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);\n    }\n    /**\n     * Return the raw value of the state.\n     */\n    snapshot() {\n      return this._internalStateOperations.getRootStateOperations().getState();\n    }\n    /**\n     * Reset the state to a specific point in time. This method is useful\n     * for plugin's who need to modify the state directly or unit testing.\n     */\n    reset(state) {\n      return this._internalStateOperations.getRootStateOperations().setState(state);\n    }\n    getStoreBoundSelectorFn(selector) {\n      const makeSelectorFn = getRootSelectorFactory(selector);\n      const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n      return makeSelectorFn(runtimeContext);\n    }\n    initStateStream(initialStateValue) {\n      const value = this._stateStream.value;\n      const storeIsEmpty = !value || Object.keys(value).length === 0;\n      if (storeIsEmpty) {\n        const defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;\n        const storeValues = defaultStateNotEmpty ? Object.assign(Object.assign({}, this._config.defaultsState), initialStateValue) : initialStateValue;\n        this._stateStream.next(storeValues);\n      }\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */Store.ɵfac = function Store_Factory(t) {\n    return new (t || Store)(i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(StateFactory), i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n  };\n  Store.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: Store,\n    factory: Store.ɵfac,\n    providedIn: 'root'\n  });\n  return Store;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\nlet SelectFactory = /*#__PURE__*/(() => {\n  class SelectFactory {\n    constructor(store, config) {\n      SelectFactory.store = store;\n      SelectFactory.config = config;\n    }\n    ngOnDestroy() {\n      SelectFactory.store = null;\n      SelectFactory.config = null;\n    }\n  }\n  SelectFactory.store = null;\n  SelectFactory.config = null;\n  /** @nocollapse */\n  /** @nocollapse */\n  SelectFactory.ɵfac = function SelectFactory_Factory(t) {\n    return new (t || SelectFactory)(i0.ɵɵinject(Store), i0.ɵɵinject(NgxsConfig));\n  };\n  SelectFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SelectFactory,\n    factory: SelectFactory.ɵfac,\n    providedIn: 'root'\n  });\n  return SelectFactory;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet LifecycleStateManager = /*#__PURE__*/(() => {\n  class LifecycleStateManager {\n    constructor(_store, _internalErrorReporter, _internalStateOperations, _stateContextFactory, _bootstrapper) {\n      this._store = _store;\n      this._internalErrorReporter = _internalErrorReporter;\n      this._internalStateOperations = _internalStateOperations;\n      this._stateContextFactory = _stateContextFactory;\n      this._bootstrapper = _bootstrapper;\n      this._destroy$ = new Subject();\n    }\n    ngOnDestroy() {\n      this._destroy$.next();\n    }\n    ngxsBootstrap(action, results) {\n      this._internalStateOperations.getRootStateOperations().dispatch(action).pipe(filter(() => !!results), tap(() => this._invokeInitOnStates(results.states)), mergeMap(() => this._bootstrapper.appBootstrapped$), filter(appBootstrapped => !!appBootstrapped), catchError(error => {\n        // The `SafeSubscriber` (which is used by most RxJS operators) re-throws\n        // errors asynchronously (`setTimeout(() => { throw error })`). This might\n        // break existing user's code or unit tests. We catch the error manually to\n        // be backward compatible with the old behavior.\n        this._internalErrorReporter.reportErrorSafely(error);\n        return EMPTY;\n      }), takeUntil(this._destroy$)).subscribe(() => this._invokeBootstrapOnStates(results.states));\n    }\n    _invokeInitOnStates(mappedStores) {\n      for (const mappedStore of mappedStores) {\n        const instance = mappedStore.instance;\n        if (instance.ngxsOnChanges) {\n          this._store.select(state => getValue(state, mappedStore.path)).pipe(startWith(undefined), pairwise(), takeUntil(this._destroy$)).subscribe(([previousValue, currentValue]) => {\n            const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n            instance.ngxsOnChanges(change);\n          });\n        }\n        if (instance.ngxsOnInit) {\n          instance.ngxsOnInit(this._getStateContext(mappedStore));\n        }\n        mappedStore.isInitialised = true;\n      }\n    }\n    _invokeBootstrapOnStates(mappedStores) {\n      for (const mappedStore of mappedStores) {\n        const instance = mappedStore.instance;\n        if (instance.ngxsAfterBootstrap) {\n          instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n        }\n      }\n    }\n    _getStateContext(mappedStore) {\n      return this._stateContextFactory.createStateContext(mappedStore);\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */LifecycleStateManager.ɵfac = function LifecycleStateManager_Factory(t) {\n    return new (t || LifecycleStateManager)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalErrorReporter), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(i5.NgxsBootstrapper));\n  };\n  LifecycleStateManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LifecycleStateManager,\n    factory: LifecycleStateManager.ɵfac,\n    providedIn: 'root'\n  });\n  return LifecycleStateManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Root module\n * @ignore\n */\nlet NgxsRootModule = /*#__PURE__*/(() => {\n  class NgxsRootModule {\n    constructor(factory, internalStateOperations, _store, _select, states = [], lifecycleStateManager) {\n      // Add stores to the state graph and return their defaults\n      const results = factory.addAndReturnDefaults(states);\n      internalStateOperations.setStateToTheCurrentWithNew(results);\n      // Connect our actions stream\n      factory.connectActionHandlers();\n      // Dispatch the init action and invoke init and bootstrap functions after\n      lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */\n  /** @nocollapse */NgxsRootModule.ɵfac = function NgxsRootModule_Factory(t) {\n    return new (t || NgxsRootModule)(i0.ɵɵinject(StateFactory), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(Store), i0.ɵɵinject(SelectFactory), i0.ɵɵinject(ROOT_STATE_TOKEN, 8), i0.ɵɵinject(LifecycleStateManager));\n  };\n  NgxsRootModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsRootModule\n  });\n  NgxsRootModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxsRootModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Feature module\n * @ignore\n */\nlet NgxsFeatureModule = /*#__PURE__*/(() => {\n  class NgxsFeatureModule {\n    constructor(_store, internalStateOperations, factory, states = [], lifecycleStateManager) {\n      // Since FEATURE_STATE_TOKEN is a multi token, we need to\n      // flatten it [[Feature1State, Feature2State], [Feature3State]]\n      const flattenedStates = NgxsFeatureModule.flattenStates(states);\n      // add stores to the state graph and return their defaults\n      const results = factory.addAndReturnDefaults(flattenedStates);\n      if (results.states.length) {\n        internalStateOperations.setStateToTheCurrentWithNew(results);\n        // dispatch the update action and invoke init and bootstrap functions after\n        lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n      }\n    }\n    static flattenStates(states = []) {\n      return states.reduce((total, values) => total.concat(values), []);\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */\n  /** @nocollapse */NgxsFeatureModule.ɵfac = function NgxsFeatureModule_Factory(t) {\n    return new (t || NgxsFeatureModule)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateFactory), i0.ɵɵinject(FEATURE_STATE_TOKEN, 8), i0.ɵɵinject(LifecycleStateManager));\n  };\n  NgxsFeatureModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsFeatureModule\n  });\n  NgxsFeatureModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxsFeatureModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Ngxs Module\n */\nlet NgxsModule = /*#__PURE__*/(() => {\n  class NgxsModule {\n    /**\n     * Root module factory\n     */\n    static forRoot(states = [], options = {}) {\n      return {\n        ngModule: NgxsRootModule,\n        providers: [StateFactory, PluginManager, ...states, ...NgxsModule.ngxsTokenProviders(states, options)]\n      };\n    }\n    /**\n     * Feature module factory\n     */\n    static forFeature(states = []) {\n      return {\n        ngModule: NgxsFeatureModule,\n        providers: [\n        // This is required on the feature level, see comments in `state-factory.ts`.\n        StateFactory, PluginManager, ...states, {\n          provide: FEATURE_STATE_TOKEN,\n          multi: true,\n          useValue: states\n        }]\n      };\n    }\n    static ngxsTokenProviders(states, options) {\n      return [{\n        provide: USER_PROVIDED_NGXS_EXECUTION_STRATEGY,\n        useValue: options.executionStrategy\n      }, {\n        provide: ROOT_STATE_TOKEN,\n        useValue: states\n      }, {\n        provide: ROOT_OPTIONS,\n        useValue: options\n      }, {\n        provide: APP_BOOTSTRAP_LISTENER,\n        useFactory: NgxsModule.appBootstrapListenerFactory,\n        multi: true,\n        deps: [NgxsBootstrapper]\n      }, {\n        provide: ɵNGXS_STATE_CONTEXT_FACTORY,\n        useExisting: StateContextFactory\n      }, {\n        provide: ɵNGXS_STATE_FACTORY,\n        useExisting: StateFactory\n      }];\n    }\n    static appBootstrapListenerFactory(bootstrapper) {\n      return () => bootstrapper.bootstrap();\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */\n  /** @nocollapse */NgxsModule.ɵfac = function NgxsModule_Factory(t) {\n    return new (t || NgxsModule)();\n  };\n  NgxsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsModule\n  });\n  NgxsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Decorates a method with a action information.\n */\nfunction Action(actions, options) {\n  return (target, name) => {\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const isStaticMethod = target.hasOwnProperty('prototype');\n      if (isStaticMethod) {\n        throwActionDecoratorError();\n      }\n    }\n    const meta = ensureStoreMetadata$1(target.constructor);\n    if (!Array.isArray(actions)) {\n      actions = [actions];\n    }\n    for (const action of actions) {\n      const type = action.type;\n      if (!meta.actions[type]) {\n        meta.actions[type] = [];\n      }\n      meta.actions[type].push({\n        fn: name,\n        options: options || {},\n        type\n      });\n    }\n  };\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nfunction State(options) {\n  return target => {\n    const stateClass = target;\n    const meta = ensureStoreMetadata$1(stateClass);\n    const inheritedStateClass = Object.getPrototypeOf(stateClass);\n    const optionsWithInheritance = getStateOptions(inheritedStateClass, options);\n    mutateMetaData({\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    });\n    stateClass[META_OPTIONS_KEY] = optionsWithInheritance;\n  };\n}\nfunction getStateOptions(inheritedStateClass, options) {\n  const inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};\n  return Object.assign(Object.assign({}, inheritanceOptions), options);\n}\nfunction mutateMetaData(params) {\n  const {\n    meta,\n    inheritedStateClass,\n    optionsWithInheritance\n  } = params;\n  const {\n    children,\n    defaults,\n    name\n  } = optionsWithInheritance;\n  const stateName = typeof name === 'string' ? name : name && name.getName() || null;\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    ensureStateNameIsValid(stateName);\n  }\n  if (inheritedStateClass.hasOwnProperty(META_KEY)) {\n    const inheritedMeta = inheritedStateClass[META_KEY] || {};\n    meta.actions = Object.assign(Object.assign({}, meta.actions), inheritedMeta.actions);\n  }\n  meta.children = children;\n  meta.defaults = defaults;\n  meta.name = stateName;\n}\nconst DOLLAR_CHAR_CODE = 36;\nfunction createSelectObservable(selector) {\n  if (!SelectFactory.store) {\n    throwSelectFactoryNotConnectedError();\n  }\n  return SelectFactory.store.select(selector);\n}\nfunction createSelectorFn(name, rawSelector, paths = []) {\n  rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n  if (typeof rawSelector === 'string') {\n    const propsArray = paths.length ? [rawSelector, ...paths] : rawSelector.split('.');\n    return propGetter(propsArray, SelectFactory.config);\n  }\n  return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\nfunction removeDollarAtTheEnd(name) {\n  const lastCharIndex = name.length - 1;\n  const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n  return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n */\nfunction Select(rawSelector, ...paths) {\n  return function (target, key) {\n    const name = key.toString();\n    const selectorId = `__${name}__selector`;\n    const selector = createSelectorFn(name, rawSelector, paths);\n    Object.defineProperties(target, {\n      [selectorId]: {\n        writable: true,\n        enumerable: false,\n        configurable: true\n      },\n      [name]: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n        }\n      }\n    });\n  };\n}\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n  getOptions: target => {\n    return target && target[SELECTOR_OPTIONS_META_KEY] || {};\n  },\n  defineOptions: (target, options) => {\n    if (!target) return;\n    target[SELECTOR_OPTIONS_META_KEY] = options;\n  }\n};\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n  const selectorMetaData = ensureSelectorMetadata$1(originalFn);\n  selectorMetaData.originalFn = originalFn;\n  let getExplicitSelectorOptions = () => ({});\n  if (creationMetadata) {\n    selectorMetaData.containerClass = creationMetadata.containerClass;\n    selectorMetaData.selectorName = creationMetadata.selectorName || null;\n    getExplicitSelectorOptions = creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n  }\n  const selectorMetaDataClone = Object.assign({}, selectorMetaData);\n  selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n  return selectorMetaData;\n}\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}), selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}), selectorMetaData.getSelectorOptions() || {}), explicitOptions);\n}\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nfunction SelectorOptions(options) {\n  return function decorate(target, methodName, descriptor) {\n    if (methodName) {\n      descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, methodName));\n      // Method Decorator\n      const originalFn = descriptor.value || descriptor.originalFn;\n      if (originalFn) {\n        selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n      }\n    } else {\n      // Class Decorator\n      selectorOptionsMetaAccessor.defineOptions(target, options);\n    }\n  };\n}\nfunction ensureStoreMetadata(target) {\n  return ensureStoreMetadata$1(target);\n}\nfunction getStoreMetadata(target) {\n  return getStoreMetadata$1(target);\n}\nfunction ensureSelectorMetadata(target) {\n  return ensureSelectorMetadata$1(target);\n}\nfunction getSelectorMetadata(target) {\n  return getSelectorMetadata$1(target);\n}\nfunction createSelector(selectors, projector, creationMetadata) {\n  const memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);\n  const selectorMetaData = setupSelectorMetadata(projector, creationMetadata);\n  selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);\n  return memoizedFn;\n}\nfunction Selector(selectors) {\n  return (target, key, descriptor) => {\n    descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, key));\n    const originalFn = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (originalFn && typeof originalFn !== 'function') {\n        throwSelectorDecoratorError();\n      }\n    }\n    const memoizedFn = createSelector(selectors, originalFn, {\n      containerClass: target,\n      selectorName: key.toString(),\n      getSelectorOptions() {\n        return {};\n      }\n    });\n    const newDescriptor = {\n      configurable: true,\n      get() {\n        return memoizedFn;\n      }\n    };\n    // Add hidden property to descriptor\n    newDescriptor['originalFn'] = originalFn;\n    return newDescriptor;\n  };\n}\nclass StateToken {\n  constructor(name) {\n    this.name = name;\n    const selectorMetadata = ensureSelectorMetadata$1(this);\n    selectorMetadata.makeRootSelector = runtimeContext => {\n      return runtimeContext.getStateGetter(this.name);\n    };\n  }\n  getName() {\n    return this.name;\n  }\n  toString() {\n    return `StateToken[${this.name}]`;\n  }\n}\nlet NgxsDevelopmentModule = /*#__PURE__*/(() => {\n  class NgxsDevelopmentModule {\n    static forRoot(options) {\n      return {\n        ngModule: NgxsDevelopmentModule,\n        providers: [NgxsUnhandledActionsLogger, {\n          provide: NGXS_DEVELOPMENT_OPTIONS,\n          useValue: options\n        }]\n      };\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */\n  /** @nocollapse */NgxsDevelopmentModule.ɵfac = function NgxsDevelopmentModule_Factory(t) {\n    return new (t || NgxsDevelopmentModule)();\n  };\n  NgxsDevelopmentModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsDevelopmentModule\n  });\n  NgxsDevelopmentModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxsDevelopmentModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction ensureValidSelector(selector, context = {}) {\n  const noun = context.noun || 'selector';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  ensureValueProvided(selector, {\n    noun,\n    prefix: context.prefix\n  });\n  const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n  if (!metadata) {\n    throw new Error(`${prefix}The value provided as the ${noun} is not a valid selector.`);\n  }\n}\nfunction ensureValueProvided(value, context = {}) {\n  const noun = context.noun || 'value';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  if (!value) {\n    throw new Error(`${prefix}A ${noun} must be provided.`);\n  }\n}\nfunction createModelSelector(selectorMap) {\n  const selectorKeys = Object.keys(selectorMap);\n  const selectors = Object.values(selectorMap);\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    ensureValidSelectorMap({\n      prefix: '[createModelSelector]',\n      selectorMap,\n      selectorKeys,\n      selectors\n    });\n  }\n  return createSelector(selectors, (...args) => {\n    return selectorKeys.reduce((obj, key, index) => {\n      obj[key] = args[index];\n      return obj;\n    }, {});\n  });\n}\nfunction ensureValidSelectorMap({\n  prefix,\n  selectorMap,\n  selectorKeys,\n  selectors\n}) {\n  ensureValueProvided(selectorMap, {\n    prefix,\n    noun: 'selector map'\n  });\n  ensureValueProvided(typeof selectorMap === 'object', {\n    prefix,\n    noun: 'valid selector map'\n  });\n  ensureValueProvided(selectorKeys.length, {\n    prefix,\n    noun: 'non-empty selector map'\n  });\n  selectors.forEach((selector, index) => ensureValidSelector(selector, {\n    prefix,\n    noun: `selector for the '${selectorKeys[index]}' property`\n  }));\n}\nfunction createPickSelector(selector, keys) {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    ensureValidSelector(selector, {\n      prefix: '[createPickSelector]'\n    });\n  }\n  const validKeys = keys.filter(Boolean);\n  const selectors = validKeys.map(key => createSelector([selector], s => s[key]));\n  return createSelector([...selectors], (...props) => {\n    return validKeys.reduce((acc, key, index) => {\n      acc[key] = props[index];\n      return acc;\n    }, {});\n  });\n}\nfunction createPropertySelectors(parentSelector) {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    ensureValidSelector(parentSelector, {\n      prefix: '[createPropertySelectors]',\n      noun: 'parent selector'\n    });\n  }\n  const cache = {};\n  return new Proxy({}, {\n    get(_target, prop) {\n      const selector = cache[prop] || createSelector([parentSelector], s => s === null || s === void 0 ? void 0 : s[prop]);\n      cache[prop] = selector;\n      return selector;\n    }\n  });\n}\n\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Action, Actions, InitState, NGXS_PLUGINS, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NoopNgxsExecutionStrategy, Select, Selector, SelectorOptions, State, StateStream, StateToken, Store, UpdateState, actionMatcher, createModelSelector, createPickSelector, createPropertySelectors, createSelector, ensureSelectorMetadata, ensureStoreMetadata, getActionTypeFromInstance, getSelectorMetadata, getStoreMetadata, getValue, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, setValue, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule };\n//# sourceMappingURL=ngxs-store.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}