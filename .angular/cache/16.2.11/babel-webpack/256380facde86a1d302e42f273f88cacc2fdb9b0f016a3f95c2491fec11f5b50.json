{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Injector, NgModule, inject } from '@angular/core';\nimport { StateToken, actionMatcher, InitState, UpdateState, getValue, setValue, NGXS_PLUGINS } from '@ngxs/store';\nimport { isPlatformServer, isPlatformBrowser } from '@angular/common';\nimport { tap } from 'rxjs/operators';\nconst NG_DEV_MODE$4 = typeof ngDevMode === 'undefined' || ngDevMode;\nconst NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken(NG_DEV_MODE$4 ? 'NGXS_STORAGE_PLUGIN_OPTIONS' : '');\nconst STORAGE_ENGINE = new InjectionToken(NG_DEV_MODE$4 ? 'STORAGE_ENGINE' : '');\n\n/**\n * The following key is used to store the entire serialized\n * state when there's no specific state provided.\n */\nconst DEFAULT_STATE_KEY = '@@STATE';\nfunction storageOptionsFactory(options) {\n  return Object.assign({\n    key: [DEFAULT_STATE_KEY],\n    storage: 0 /* LocalStorage */,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    beforeSerialize: obj => obj,\n    afterDeserialize: obj => obj\n  }, options);\n}\nfunction engineFactory(options, platformId) {\n  if (isPlatformServer(platformId)) {\n    return null;\n  }\n  if (options.storage === 0 /* LocalStorage */) {\n    return localStorage;\n  } else if (options.storage === 1 /* SessionStorage */) {\n    return sessionStorage;\n  }\n  return null;\n}\nfunction getStorageKey(key, options) {\n  // Prepends the `namespace` option to any key if it's been provided by a user.\n  // So `@@STATE` becomes `my-app:@@STATE`.\n  return options && options.namespace ? `${options.namespace}:${key}` : key;\n}\n\n/** Determines whether the provided key has the following structure. */\nfunction isKeyWithExplicitEngine(key) {\n  return key != null && !!key.engine;\n}\n/** This symbol is used to store the metadata on state classes. */\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nfunction exctractStringKey(storageKey) {\n  // Extract the actual key out of the `{ key, engine }` structure.\n  if (isKeyWithExplicitEngine(storageKey)) {\n    storageKey = storageKey.key;\n  }\n  // Given the `storageKey` is a class, for instance, `AuthState`.\n  // We should retrieve its metadata and the `name` property.\n  // The `name` property might be a string (state name) or a state token.\n  if (storageKey.hasOwnProperty(META_OPTIONS_KEY)) {\n    storageKey = storageKey[META_OPTIONS_KEY].name;\n  }\n  return storageKey instanceof StateToken ? storageKey.getName() : storageKey;\n}\nconst NG_DEV_MODE$3 = typeof ngDevMode === 'undefined' || ngDevMode;\nconst FINAL_NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken(NG_DEV_MODE$3 ? 'FINAL_NGXS_STORAGE_PLUGIN_OPTIONS' : '');\nfunction createFinalStoragePluginOptions(injector, options) {\n  const storageKeys = Array.isArray(options.key) ? options.key : [options.key];\n  const keysWithEngines = storageKeys.map(storageKey => {\n    const key = exctractStringKey(storageKey);\n    const engine = isKeyWithExplicitEngine(storageKey) ? injector.get(storageKey.engine) : injector.get(STORAGE_ENGINE);\n    return {\n      key,\n      engine\n    };\n  });\n  return Object.assign(Object.assign({}, options), {\n    keysWithEngines\n  });\n}\nconst NG_DEV_MODE$2 = typeof ngDevMode === 'undefined' || ngDevMode;\nlet NgxsStoragePlugin = /*#__PURE__*/(() => {\n  class NgxsStoragePlugin {\n    constructor(_options, _platformId) {\n      this._options = _options;\n      this._platformId = _platformId;\n      this._keysWithEngines = this._options.keysWithEngines;\n      // We default to `[DEFAULT_STATE_KEY]` if the user explicitly does not provide the `key` option.\n      this._usesDefaultStateKey = this._keysWithEngines.length === 1 && this._keysWithEngines[0].key === DEFAULT_STATE_KEY;\n    }\n    handle(state, event, next) {\n      var _a;\n      if (isPlatformServer(this._platformId)) {\n        return next(state, event);\n      }\n      const matches = actionMatcher(event);\n      const isInitAction = matches(InitState);\n      const isUpdateAction = matches(UpdateState);\n      const isInitOrUpdateAction = isInitAction || isUpdateAction;\n      let hasMigration = false;\n      if (isInitOrUpdateAction) {\n        const addedStates = isUpdateAction && event.addedStates;\n        for (const {\n          key,\n          engine\n        } of this._keysWithEngines) {\n          // We're checking what states have been added by NGXS and if any of these states should be handled by\n          // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added\n          // the `user` state, the storage plugin will be rerun and will do redundant deserialization.\n          // `usesDefaultStateKey` is necessary to check since `event.addedStates` never contains `@@STATE`.\n          if (!this._usesDefaultStateKey && addedStates) {\n            // We support providing keys that can be deeply nested via dot notation, for instance,\n            // `keys: ['myState.myProperty']` is a valid key.\n            // The state name should always go first. The below code checks if the `key` includes dot\n            // notation and extracts the state name out of the key.\n            // Given the `key` is `myState.myProperty`, the `addedStates` will only contain `myState`.\n            const dotNotationIndex = key.indexOf(DOT);\n            const stateName = dotNotationIndex > -1 ? key.slice(0, dotNotationIndex) : key;\n            if (!addedStates.hasOwnProperty(stateName)) {\n              continue;\n            }\n          }\n          const storageKey = getStorageKey(key, this._options);\n          let storedValue = engine.getItem(storageKey);\n          if (storedValue !== 'undefined' && storedValue != null) {\n            try {\n              const newVal = this._options.deserialize(storedValue);\n              storedValue = this._options.afterDeserialize(newVal, key);\n            } catch (_b) {\n              if (NG_DEV_MODE$2) {\n                console.error(`Error ocurred while deserializing the ${storageKey} store value, falling back to empty object, the value obtained from the store: `, storedValue);\n              }\n              storedValue = {};\n            }\n            (_a = this._options.migrations) === null || _a === void 0 ? void 0 : _a.forEach(strategy => {\n              const versionMatch = strategy.version === getValue(storedValue, strategy.versionKey || 'version');\n              const keyMatch = !strategy.key && this._usesDefaultStateKey || strategy.key === key;\n              if (versionMatch && keyMatch) {\n                storedValue = strategy.migrate(storedValue);\n                hasMigration = true;\n              }\n            });\n            if (!this._usesDefaultStateKey) {\n              state = setValue(state, key, storedValue);\n            } else {\n              // The `UpdateState` action is dispatched whenever the feature\n              // state is added. The condition below is satisfied only when\n              // the `UpdateState` action is dispatched. Let's consider two states:\n              // `counter` and `@ngxs/router-plugin` state. When we call `NgxsModule.forRoot()`,\n              // `CounterState` is provided at the root level, while `@ngxs/router-plugin`\n              // is provided as a feature state. Beforehand, the storage plugin may have\n              // stored the value of the counter state as `10`. If `CounterState` implements\n              // the `ngxsOnInit` hook and calls `ctx.setState(999)`, the storage plugin\n              // will rehydrate the entire state when the `RouterState` is registered.\n              // Consequently, the `counter` state will revert back to `10` instead of `999`.\n              if (storedValue && addedStates && Object.keys(addedStates).length > 0) {\n                storedValue = Object.keys(addedStates).reduce((accumulator, addedState) => {\n                  // The `storedValue` can be equal to the entire state when the default\n                  // state key is used. However, if `addedStates` only contains the `router` value,\n                  // we only want to merge the state with the `router` value.\n                  // Let's assume that the `storedValue` is an object:\n                  // `{ counter: 10, router: {...} }`\n                  // This will pick only the `router` object from the `storedValue` and `counter`\n                  // state will not be rehydrated unnecessary.\n                  if (storedValue.hasOwnProperty(addedState)) {\n                    accumulator[addedState] = storedValue[addedState];\n                  }\n                  return accumulator;\n                }, {});\n              }\n              state = Object.assign(Object.assign({}, state), storedValue);\n            }\n          }\n        }\n      }\n      return next(state, event).pipe(tap(nextState => {\n        if (isInitOrUpdateAction && !hasMigration) {\n          return;\n        }\n        for (const {\n          key,\n          engine\n        } of this._keysWithEngines) {\n          let storedValue = nextState;\n          const storageKey = getStorageKey(key, this._options);\n          if (key !== DEFAULT_STATE_KEY) {\n            storedValue = getValue(nextState, key);\n          }\n          try {\n            const newStoredValue = this._options.beforeSerialize(storedValue, key);\n            engine.setItem(storageKey, this._options.serialize(newStoredValue));\n          } catch (error) {\n            if (NG_DEV_MODE$2) {\n              if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n                console.error(`The ${storageKey} store value exceeds the browser storage quota: `, storedValue);\n              } else {\n                console.error(`Error ocurred while serializing the ${storageKey} store value, value not updated, the value obtained from the store: `, storedValue);\n              }\n            }\n          }\n        }\n      }));\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */NgxsStoragePlugin.ɵfac = function NgxsStoragePlugin_Factory(t) {\n    return new (t || NgxsStoragePlugin)(i0.ɵɵinject(FINAL_NGXS_STORAGE_PLUGIN_OPTIONS), i0.ɵɵinject(PLATFORM_ID));\n  };\n  NgxsStoragePlugin.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsStoragePlugin,\n    factory: NgxsStoragePlugin.ɵfac\n  });\n  return NgxsStoragePlugin;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DOT = '.';\nconst NG_DEV_MODE$1 = typeof ngDevMode === 'undefined' || ngDevMode;\nconst USER_OPTIONS = new InjectionToken(NG_DEV_MODE$1 ? 'USER_OPTIONS' : '');\nlet NgxsStoragePluginModule = /*#__PURE__*/(() => {\n  class NgxsStoragePluginModule {\n    static forRoot(options) {\n      return {\n        ngModule: NgxsStoragePluginModule,\n        providers: [{\n          provide: NGXS_PLUGINS,\n          useClass: NgxsStoragePlugin,\n          multi: true\n        }, {\n          provide: USER_OPTIONS,\n          useValue: options\n        }, {\n          provide: NGXS_STORAGE_PLUGIN_OPTIONS,\n          useFactory: storageOptionsFactory,\n          deps: [USER_OPTIONS]\n        }, {\n          provide: STORAGE_ENGINE,\n          useFactory: engineFactory,\n          deps: [NGXS_STORAGE_PLUGIN_OPTIONS, PLATFORM_ID]\n        }, {\n          provide: FINAL_NGXS_STORAGE_PLUGIN_OPTIONS,\n          useFactory: createFinalStoragePluginOptions,\n          deps: [Injector, NGXS_STORAGE_PLUGIN_OPTIONS]\n        }]\n      };\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */\n  /** @nocollapse */NgxsStoragePluginModule.ɵfac = function NgxsStoragePluginModule_Factory(t) {\n    return new (t || NgxsStoragePluginModule)();\n  };\n  NgxsStoragePluginModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsStoragePluginModule\n  });\n  NgxsStoragePluginModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxsStoragePluginModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\nconst LOCAL_STORAGE_ENGINE = new InjectionToken(NG_DEV_MODE ? 'LOCAL_STORAGE_ENGINE' : '', {\n  providedIn: 'root',\n  factory: () => isPlatformBrowser(inject(PLATFORM_ID)) ? localStorage : null\n});\nconst SESSION_STORAGE_ENGINE = new InjectionToken(NG_DEV_MODE ? 'SESSION_STORAGE_ENGINE' : '', {\n  providedIn: 'root',\n  factory: () => isPlatformBrowser(inject(PLATFORM_ID)) ? sessionStorage : null\n});\n\n/**\n * The public api for consumers of @ngxs/storage-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LOCAL_STORAGE_ENGINE, NGXS_STORAGE_PLUGIN_OPTIONS, NgxsStoragePlugin, NgxsStoragePluginModule, SESSION_STORAGE_ENGINE, STORAGE_ENGINE };\n//# sourceMappingURL=ngxs-storage-plugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}