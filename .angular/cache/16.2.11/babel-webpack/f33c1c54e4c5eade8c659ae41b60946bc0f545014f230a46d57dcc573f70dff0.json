{"ast":null,"code":"var _class21, _class32, _class33, _class34;\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, NgModule, SkipSelf, EventEmitter, Component, ViewEncapsulation, Input, Output, Directive, ViewChild, Pipe } from '@angular/core';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpUrlEncodingCodec, HttpParams } from '@angular/common/http';\nimport * as i2$1 from '@angular/forms';\nimport { FormControl, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';\nimport * as i3$1 from '@angular/router';\nimport { RouterModule } from '@angular/router';\nimport * as i1$1 from '@ngxs/store';\nimport { createSelector, Action, Selector, State } from '@ngxs/store';\nimport { map, take, switchMap, catchError, tap, forkJoin, of, startWith, BehaviorSubject } from 'rxjs';\nimport { __decorate, __metadata } from 'tslib';\nimport * as i1$2 from '@angular/material/snack-bar';\nimport * as i1$3 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i2 from '@angular/material/badge';\nimport { MatBadgeModule } from '@angular/material/badge';\nimport * as i3 from '@angular/material/button';\nimport { MatButtonModule } from '@angular/material/button';\nimport * as i4 from '@angular/material/icon';\nimport { MatIconModule } from '@angular/material/icon';\nimport * as i5 from '@angular/material/tooltip';\nimport { MatTooltipModule } from '@angular/material/tooltip';\nimport * as i3$2 from '@angular/material/form-field';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport * as i5$1 from '@angular/material/input';\nimport { MatInputModule } from '@angular/material/input';\nimport * as i7 from 'ngx-mask';\nimport { NgxMaskDirective, provideNgxMask } from 'ngx-mask';\nfunction _class38_button_1_mat_icon_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-icon\", 7);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r3.icon, \" \");\n  }\n}\nfunction _class38_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 4);\n    i0.ɵɵlistener(\"click\", function _class38_button_1_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r4.emitClicked($event));\n    });\n    i0.ɵɵelementStart(1, \"div\", 5);\n    i0.ɵɵtemplate(2, _class38_button_1_mat_icon_2_Template, 2, 1, \"mat-icon\", 6);\n    i0.ɵɵelementStart(3, \"span\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r0.buttonClass);\n    i0.ɵɵproperty(\"type\", ctx_r0.type)(\"color\", ctx_r0.color)(\"disabled\", ctx_r0.disabled)(\"matTooltip\", ctx_r0.tooltip)(\"routerLink\", ctx_r0.buttonRouterLink)(\"matBadgeColor\", ctx_r0.matBadgeColor)(\"matBadge\", ctx_r0.matBadgeContent);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r0.icon);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.buttonText, \" \");\n  }\n}\nfunction _class38_button_2_mat_icon_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-icon\", 7);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r6.icon, \" \");\n  }\n}\nfunction _class38_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 8);\n    i0.ɵɵlistener(\"click\", function _class38_button_2_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r8);\n      const ctx_r7 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r7.emitClicked($event));\n    });\n    i0.ɵɵelementStart(1, \"div\", 5);\n    i0.ɵɵtemplate(2, _class38_button_2_mat_icon_2_Template, 2, 1, \"mat-icon\", 6);\n    i0.ɵɵelementStart(3, \"span\");\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r1.buttonClass);\n    i0.ɵɵproperty(\"type\", ctx_r1.type)(\"color\", ctx_r1.color)(\"disabled\", ctx_r1.disabled)(\"matTooltip\", ctx_r1.tooltip)(\"matBadgeColor\", ctx_r1.matBadgeColor)(\"matBadge\", ctx_r1.matBadgeContent)(\"routerLink\", ctx_r1.buttonRouterLink);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.icon);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r1.buttonText, \" \");\n  }\n}\nfunction _class38_button_3_mat_icon_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"mat-icon\", 12);\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"svgIcon\", ctx_r9.customIcon);\n  }\n}\nfunction _class38_button_3_mat_icon_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-icon\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r10 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r10.icon, \" \");\n  }\n}\nfunction _class38_button_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 9);\n    i0.ɵɵlistener(\"click\", function _class38_button_3_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r11.emitClicked($event));\n    });\n    i0.ɵɵtemplate(1, _class38_button_3_mat_icon_1_Template, 1, 1, \"mat-icon\", 10);\n    i0.ɵɵtemplate(2, _class38_button_3_mat_icon_2_Template, 2, 1, \"mat-icon\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r2.buttonClass);\n    i0.ɵɵproperty(\"type\", ctx_r2.type)(\"color\", ctx_r2.color)(\"disabled\", ctx_r2.disabled)(\"routerLink\", ctx_r2.buttonRouterLink)(\"matTooltip\", ctx_r2.tooltip)(\"matBadgeColor\", ctx_r2.matBadgeColor)(\"matBadge\", ctx_r2.matBadgeContent);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.customIcon);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.icon);\n  }\n}\nconst _c0 = [\"nativeInput\"];\nfunction _class41_button_6_mat_icon_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-icon\");\n    i0.ɵɵtext(1, \"visibility\");\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class41_button_6_mat_icon_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-icon\");\n    i0.ɵɵtext(1, \"visibility_off\");\n    i0.ɵɵelementEnd();\n  }\n}\nfunction _class41_button_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 6);\n    i0.ɵɵlistener(\"click\", function _class41_button_6_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.toggleVisibility());\n    });\n    i0.ɵɵtemplate(1, _class41_button_6_mat_icon_1_Template, 2, 0, \"mat-icon\", 7);\n    i0.ɵɵtemplate(2, _class41_button_6_mat_icon_2_Template, 2, 0, \"mat-icon\", 7);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"matTooltip\", ctx_r1.type === \"password\" ? \"Show \" + ctx_r1.label : \"Hide \" + ctx_r1.label);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.type === \"password\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.type !== \"password\");\n  }\n}\nfunction _class41_mat_error_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"mat-error\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const err_r7 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(err_r7.message);\n  }\n}\nfunction _class43_5_ng_template_0_Template(rf, ctx) {}\nfunction _class43_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, _class43_5_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.additionalFieldsTemplate);\n  }\n}\nfunction _class43_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"app-input\", 10);\n    i0.ɵɵpipe(2, \"formGet\");\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"inputFormControl\", i0.ɵɵpipeBind2(2, 1, ctx_r1.form, \"displayname\"));\n  }\n}\nfunction _class43_app_button_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"app-button\", 11);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"buttonText\", ctx_r2.secondaryButtonText)(\"routerLink\", ctx_r2.secondaryButtonRouterLink);\n  }\n}\nconst fadeInOut = [trigger('fadeInOut', [state('void', style({\n  opacity: 0,\n  visibility: 'hidden'\n})), transition(':enter', [animate('0.2s', style({\n  opacity: 1,\n  visibility: 'visible'\n}))]), transition(':leave', [animate('0.2s', style({\n  opacity: 0,\n  visibility: 'hidden'\n}))])])];\nconst BASE_PATH = new InjectionToken('basePath');\nconst COLLECTION_FORMATS = {\n  'csv': ',',\n  'tsv': '   ',\n  'ssv': ' ',\n  'pipes': '|'\n};\nclass Configuration {\n  constructor(configurationParameters = {}) {\n    this.apiKeys = configurationParameters.apiKeys;\n    this.username = configurationParameters.username;\n    this.password = configurationParameters.password;\n    this.accessToken = configurationParameters.accessToken;\n    this.basePath = configurationParameters.basePath;\n    this.withCredentials = configurationParameters.withCredentials;\n  }\n  /**\n   * Select the correct content-type to use for a request.\n   * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n   * If no content type is found return the first found type if the contentTypes is not empty\n   * @param contentTypes - the array of content types that are available for selection\n   * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n   */\n  selectHeaderContentType(contentTypes) {\n    if (contentTypes.length == 0) {\n      return undefined;\n    }\n    let type = contentTypes.find(x => this.isJsonMime(x));\n    if (type === undefined) {\n      return contentTypes[0];\n    }\n    return type;\n  }\n  /**\n   * Select the correct accept content-type to use for a request.\n   * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n   * If no content type is found return the first found type if the contentTypes is not empty\n   * @param accepts - the array of content types that are available for selection.\n   * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n   */\n  selectHeaderAccept(accepts) {\n    if (accepts.length == 0) {\n      return undefined;\n    }\n    let type = accepts.find(x => this.isJsonMime(x));\n    if (type === undefined) {\n      return accepts[0];\n    }\n    return type;\n  }\n  /**\n   * Check if the given MIME is a JSON MIME.\n   * JSON MIME examples:\n   *   application/json\n   *   application/json; charset=UTF8\n   *   APPLICATION/JSON\n   *   application/vnd.company+json\n   * @param mime - MIME (Multipurpose Internet Mail Extensions)\n   * @return True if the given MIME is JSON, false otherwise.\n   */\n  isJsonMime(mime) {\n    const jsonMime = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n    return mime != null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n  }\n}\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet AuthService = /*#__PURE__*/(() => {\n  var _class;\n  class AuthService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    getNewRefreshToken(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('post', `${this.basePath}/token/`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    login(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling login.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/login/`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    logout(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('post', `${this.basePath}/logout/`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    signUp(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling signUp.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/signUp`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class = AuthService;\n  _class.ɵfac = function _class_Factory(t) {\n    return new (t || _class)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac\n  });\n  return AuthService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet CategoryService = /*#__PURE__*/(() => {\n  var _class2;\n  class CategoryService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    createCategory(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling createCategory.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/category/`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    deleteCategory(categoryId, observe = 'body', reportProgress = false) {\n      if (categoryId === null || categoryId === undefined) {\n        throw new Error('Required parameter categoryId was null or undefined when calling deleteCategory.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('delete', `${this.basePath}/category/${encodeURIComponent(String(categoryId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getAllCategories(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/category/`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getCategoryCountByName(categoryName, observe = 'body', reportProgress = false) {\n      if (categoryName === null || categoryName === undefined) {\n        throw new Error('Required parameter categoryName was null or undefined when calling getCategoryCountByName.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['text/plain'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/category/${encodeURIComponent(String(categoryName))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getPagedCategories(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling getPagedCategories.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/category/getPagedCategories`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    updateCategory(body, categoryId, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling updateCategory.');\n      }\n      if (categoryId === null || categoryId === undefined) {\n        throw new Error('Required parameter categoryId was null or undefined when calling updateCategory.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('put', `${this.basePath}/category/${encodeURIComponent(String(categoryId))}`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class2 = CategoryService;\n  _class2.ɵfac = function _class2_Factory(t) {\n    return new (t || _class2)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class2.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac\n  });\n  return CategoryService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet CommentService = /*#__PURE__*/(() => {\n  var _class3;\n  class CommentService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    addComment(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling addComment.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/comment/`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    deleteComment(commentId, observe = 'body', reportProgress = false) {\n      if (commentId === null || commentId === undefined) {\n        throw new Error('Required parameter commentId was null or undefined when calling deleteComment.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('delete', `${this.basePath}/comment/${encodeURIComponent(String(commentId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class3 = CommentService;\n  _class3.ɵfac = function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class3.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class3,\n    factory: _class3.ɵfac\n  });\n  return CommentService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet DashboardService = /*#__PURE__*/(() => {\n  var _class4;\n  class DashboardService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    createDashboard(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling createDashboard.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/dashboard/`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    deleteDashboard(dashboardId, observe = 'body', reportProgress = false) {\n      if (dashboardId === null || dashboardId === undefined) {\n        throw new Error('Required parameter dashboardId was null or undefined when calling deleteDashboard.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('delete', `${this.basePath}/dashboard/${encodeURIComponent(String(dashboardId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getDashboardsForUserByGroupId(groupId, observe = 'body', reportProgress = false) {\n      if (groupId === null || groupId === undefined) {\n        throw new Error('Required parameter groupId was null or undefined when calling getDashboardsForUserByGroupId.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/dashboard/${encodeURIComponent(String(groupId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    updateDashboard(body, dashboardId, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling updateDashboard.');\n      }\n      if (dashboardId === null || dashboardId === undefined) {\n        throw new Error('Required parameter dashboardId was null or undefined when calling updateDashboard.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('put', `${this.basePath}/dashboard/${encodeURIComponent(String(dashboardId))}`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class4 = DashboardService;\n  _class4.ɵfac = function _class4_Factory(t) {\n    return new (t || _class4)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class4.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class4,\n    factory: _class4.ɵfac\n  });\n  return DashboardService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet FeatureConfigService = /*#__PURE__*/(() => {\n  var _class5;\n  class FeatureConfigService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    getFeatureConfig(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/featureConfig`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class5 = FeatureConfigService;\n  _class5.ɵfac = function _class5_Factory(t) {\n    return new (t || _class5)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class5.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class5,\n    factory: _class5.ɵfac\n  });\n  return FeatureConfigService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet GroupsService = /*#__PURE__*/(() => {\n  var _class6;\n  class GroupsService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    createGroup(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling createGroup.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/group`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    deleteGroup(groupId, observe = 'body', reportProgress = false) {\n      if (groupId === null || groupId === undefined) {\n        throw new Error('Required parameter groupId was null or undefined when calling deleteGroup.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('delete', `${this.basePath}/group/${encodeURIComponent(String(groupId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getGroupById(groupId, observe = 'body', reportProgress = false) {\n      if (groupId === null || groupId === undefined) {\n        throw new Error('Required parameter groupId was null or undefined when calling getGroupById.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/group/${encodeURIComponent(String(groupId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getGroupsForuser(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/group`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    pollGroupEmail(groupId, observe = 'body', reportProgress = false) {\n      if (groupId === null || groupId === undefined) {\n        throw new Error('Required parameter groupId was null or undefined when calling pollGroupEmail.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('post', `${this.basePath}/group/${encodeURIComponent(String(groupId))}/pollGroupEmail`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    updateGroup(body, groupId, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling updateGroup.');\n      }\n      if (groupId === null || groupId === undefined) {\n        throw new Error('Required parameter groupId was null or undefined when calling updateGroup.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('put', `${this.basePath}/group/${encodeURIComponent(String(groupId))}`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    updateGroupSettings(body, groupId, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling updateGroupSettings.');\n      }\n      if (groupId === null || groupId === undefined) {\n        throw new Error('Required parameter groupId was null or undefined when calling updateGroupSettings.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('put', `${this.basePath}/group/${encodeURIComponent(String(groupId))}/groupSettings`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class6 = GroupsService;\n  _class6.ɵfac = function _class6_Factory(t) {\n    return new (t || _class6)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class6.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class6,\n    factory: _class6.ɵfac\n  });\n  return GroupsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet NotificationsService = /*#__PURE__*/(() => {\n  var _class7;\n  class NotificationsService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    deleteAllNotificationsForUser(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('delete', `${this.basePath}/notifications/`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    deleteNotificationById(notificationId, observe = 'body', reportProgress = false) {\n      if (notificationId === null || notificationId === undefined) {\n        throw new Error('Required parameter notificationId was null or undefined when calling deleteNotificationById.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('delete', `${this.basePath}/notifications/${encodeURIComponent(String(notificationId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getNotificationCount(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/notifications/notificationCount`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getNotificationsForuser(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/notifications/`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class7 = NotificationsService;\n  _class7.ɵfac = function _class7_Factory(t) {\n    return new (t || _class7)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class7.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class7,\n    factory: _class7.ɵfac\n  });\n  return NotificationsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * CustomHttpUrlEncodingCodec\n * Fix plus sign (+) not encoding, so sent as blank space\n * See: https://github.com/angular/angular/issues/11058#issuecomment-247367318\n */\nclass CustomHttpUrlEncodingCodec extends HttpUrlEncodingCodec {\n  encodeKey(k) {\n    k = super.encodeKey(k);\n    return k.replace(/\\+/gi, '%2B');\n  }\n  encodeValue(v) {\n    v = super.encodeValue(v);\n    return v.replace(/\\+/gi, '%2B');\n  }\n}\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet ReceiptService = /*#__PURE__*/(() => {\n  var _class8;\n  class ReceiptService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    bulkReceiptStatusUpdate(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling bulkReceiptStatusUpdate.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/receipt/bulkStatusUpdate`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    createReceipt(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling createReceipt.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/receipt/`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    deleteReceiptById(receiptId, observe = 'body', reportProgress = false) {\n      if (receiptId === null || receiptId === undefined) {\n        throw new Error('Required parameter receiptId was null or undefined when calling deleteReceiptById.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('delete', `${this.basePath}/receipt/${encodeURIComponent(String(receiptId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    duplicateReceipt(receiptId, observe = 'body', reportProgress = false) {\n      if (receiptId === null || receiptId === undefined) {\n        throw new Error('Required parameter receiptId was null or undefined when calling duplicateReceipt.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('post', `${this.basePath}/receipt/${encodeURIComponent(String(receiptId))}/duplicate`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getReceiptById(receiptId, observe = 'body', reportProgress = false) {\n      if (receiptId === null || receiptId === undefined) {\n        throw new Error('Required parameter receiptId was null or undefined when calling getReceiptById.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/receipt/${encodeURIComponent(String(receiptId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getReceiptsForGroup(body, groupId, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling getReceiptsForGroup.');\n      }\n      if (groupId === null || groupId === undefined) {\n        throw new Error('Required parameter groupId was null or undefined when calling getReceiptsForGroup.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/receipt/group/${encodeURIComponent(String(groupId))}`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    hasAccessToReceipt(receiptId, groupRole, observe = 'body', reportProgress = false) {\n      if (receiptId === null || receiptId === undefined) {\n        throw new Error('Required parameter receiptId was null or undefined when calling hasAccessToReceipt.');\n      }\n      let queryParameters = new HttpParams({\n        encoder: new CustomHttpUrlEncodingCodec()\n      });\n      if (receiptId !== undefined && receiptId !== null) {\n        queryParameters = queryParameters.set('receiptId', receiptId);\n      }\n      if (groupRole !== undefined && groupRole !== null) {\n        queryParameters = queryParameters.set('groupRole', groupRole);\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/receipt/hasAccess`, {\n        params: queryParameters,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    quickScanReceiptForm(file, groupId, paidByUserId, status, observe = 'body', reportProgress = false) {\n      if (file === null || file === undefined) {\n        throw new Error('Required parameter file was null or undefined when calling quickScanReceipt.');\n      }\n      if (groupId === null || groupId === undefined) {\n        throw new Error('Required parameter groupId was null or undefined when calling quickScanReceipt.');\n      }\n      if (paidByUserId === null || paidByUserId === undefined) {\n        throw new Error('Required parameter paidByUserId was null or undefined when calling quickScanReceipt.');\n      }\n      if (status === null || status === undefined) {\n        throw new Error('Required parameter status was null or undefined when calling quickScanReceipt.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['multipart/form-data'];\n      const canConsumeForm = this.canConsumeForm(consumes);\n      let formParams;\n      let useForm = false;\n      let convertFormParamsToString = false;\n      // use FormData to transmit files using content-type \"multipart/form-data\"\n      // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data\n      useForm = canConsumeForm;\n      if (useForm) {\n        formParams = new FormData();\n      } else {\n        formParams = new HttpParams({\n          encoder: new CustomHttpUrlEncodingCodec()\n        });\n      }\n      if (file !== undefined) {\n        formParams = formParams.append('file', file) || formParams;\n      }\n      if (groupId !== undefined) {\n        formParams = formParams.append('groupId', groupId) || formParams;\n      }\n      if (paidByUserId !== undefined) {\n        formParams = formParams.append('paidByUserId', paidByUserId) || formParams;\n      }\n      if (status !== undefined) {\n        formParams = formParams.append('status', status) || formParams;\n      }\n      return this.httpClient.request('post', `${this.basePath}/receipt/quickScan`, {\n        body: convertFormParamsToString ? formParams.toString() : formParams,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    updateReceipt(body, receiptId, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling updateReceipt.');\n      }\n      if (receiptId === null || receiptId === undefined) {\n        throw new Error('Required parameter receiptId was null or undefined when calling updateReceipt.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('put', `${this.basePath}/receipt/${encodeURIComponent(String(receiptId))}`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class8 = ReceiptService;\n  _class8.ɵfac = function _class8_Factory(t) {\n    return new (t || _class8)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class8.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class8,\n    factory: _class8.ɵfac\n  });\n  return ReceiptService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet ReceiptImageService = /*#__PURE__*/(() => {\n  var _class9;\n  class ReceiptImageService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    convertToJpgForm(file, observe = 'body', reportProgress = false) {\n      if (file === null || file === undefined) {\n        throw new Error('Required parameter file was null or undefined when calling convertToJpg.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['multipart/form-data'];\n      const canConsumeForm = this.canConsumeForm(consumes);\n      let formParams;\n      let useForm = false;\n      let convertFormParamsToString = false;\n      // use FormData to transmit files using content-type \"multipart/form-data\"\n      // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data\n      useForm = canConsumeForm;\n      if (useForm) {\n        formParams = new FormData();\n      } else {\n        formParams = new HttpParams({\n          encoder: new CustomHttpUrlEncodingCodec()\n        });\n      }\n      if (file !== undefined) {\n        formParams = formParams.append('file', file) || formParams;\n      }\n      return this.httpClient.request('post', `${this.basePath}/receiptImage/convertToJpg`, {\n        body: convertFormParamsToString ? formParams.toString() : formParams,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    deleteReceiptImageById(receiptImageId, observe = 'body', reportProgress = false) {\n      if (receiptImageId === null || receiptImageId === undefined) {\n        throw new Error('Required parameter receiptImageId was null or undefined when calling deleteReceiptImageById.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('delete', `${this.basePath}/receiptImage/${encodeURIComponent(String(receiptImageId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getReceiptImageById(receiptImageId, observe = 'body', reportProgress = false) {\n      if (receiptImageId === null || receiptImageId === undefined) {\n        throw new Error('Required parameter receiptImageId was null or undefined when calling getReceiptImageById.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/receiptImage/${encodeURIComponent(String(receiptImageId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    magicFillReceiptForm(file, receiptImageId, observe = 'body', reportProgress = false) {\n      let queryParameters = new HttpParams({\n        encoder: new CustomHttpUrlEncodingCodec()\n      });\n      if (receiptImageId !== undefined && receiptImageId !== null) {\n        queryParameters = queryParameters.set('receiptImageId', receiptImageId);\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['multipart/form-data'];\n      const canConsumeForm = this.canConsumeForm(consumes);\n      let formParams;\n      let useForm = false;\n      let convertFormParamsToString = false;\n      // use FormData to transmit files using content-type \"multipart/form-data\"\n      // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data\n      useForm = canConsumeForm;\n      if (useForm) {\n        formParams = new FormData();\n      } else {\n        formParams = new HttpParams({\n          encoder: new CustomHttpUrlEncodingCodec()\n        });\n      }\n      if (file !== undefined) {\n        formParams = formParams.append('file', file) || formParams;\n      }\n      return this.httpClient.request('post', `${this.basePath}/receiptImage/magicFill`, {\n        body: convertFormParamsToString ? formParams.toString() : formParams,\n        params: queryParameters,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    uploadReceiptImageForm(file, receiptId, encodedImage, observe = 'body', reportProgress = false) {\n      if (file === null || file === undefined) {\n        throw new Error('Required parameter file was null or undefined when calling uploadReceiptImage.');\n      }\n      if (receiptId === null || receiptId === undefined) {\n        throw new Error('Required parameter receiptId was null or undefined when calling uploadReceiptImage.');\n      }\n      if (encodedImage === null || encodedImage === undefined) {\n        throw new Error('Required parameter encodedImage was null or undefined when calling uploadReceiptImage.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['multipart/form-data'];\n      const canConsumeForm = this.canConsumeForm(consumes);\n      let formParams;\n      let useForm = false;\n      let convertFormParamsToString = false;\n      // use FormData to transmit files using content-type \"multipart/form-data\"\n      // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data\n      useForm = canConsumeForm;\n      if (useForm) {\n        formParams = new FormData();\n      } else {\n        formParams = new HttpParams({\n          encoder: new CustomHttpUrlEncodingCodec()\n        });\n      }\n      if (file !== undefined) {\n        formParams = formParams.append('file', file) || formParams;\n      }\n      if (receiptId !== undefined) {\n        formParams = formParams.append('receiptId', receiptId) || formParams;\n      }\n      if (encodedImage !== undefined) {\n        formParams = formParams.append('encodedImage', encodedImage) || formParams;\n      }\n      return this.httpClient.request('post', `${this.basePath}/receiptImage/`, {\n        body: convertFormParamsToString ? formParams.toString() : formParams,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class9 = ReceiptImageService;\n  _class9.ɵfac = function _class9_Factory(t) {\n    return new (t || _class9)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class9.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class9,\n    factory: _class9.ɵfac\n  });\n  return ReceiptImageService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet SearchService = /*#__PURE__*/(() => {\n  var _class10;\n  class SearchService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    receiptSearch(searchTerm, observe = 'body', reportProgress = false) {\n      if (searchTerm === null || searchTerm === undefined) {\n        throw new Error('Required parameter searchTerm was null or undefined when calling receiptSearch.');\n      }\n      let queryParameters = new HttpParams({\n        encoder: new CustomHttpUrlEncodingCodec()\n      });\n      if (searchTerm !== undefined && searchTerm !== null) {\n        queryParameters = queryParameters.set('searchTerm', searchTerm);\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/search/`, {\n        params: queryParameters,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class10 = SearchService;\n  _class10.ɵfac = function _class10_Factory(t) {\n    return new (t || _class10)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class10.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class10,\n    factory: _class10.ɵfac\n  });\n  return SearchService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet TagService = /*#__PURE__*/(() => {\n  var _class11;\n  class TagService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    createTag(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling createTag.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/tag/`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    deleteTag(tagId, observe = 'body', reportProgress = false) {\n      if (tagId === null || tagId === undefined) {\n        throw new Error('Required parameter tagId was null or undefined when calling deleteTag.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('delete', `${this.basePath}/tag/${encodeURIComponent(String(tagId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getAllTags(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/tag/`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getPagedTags(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling getPagedTags.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/tag/getPagedTags`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getTagCountByName(tagName, observe = 'body', reportProgress = false) {\n      if (tagName === null || tagName === undefined) {\n        throw new Error('Required parameter tagName was null or undefined when calling getTagCountByName.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['text/plain'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/tag/${encodeURIComponent(String(tagName))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    updateTag(body, tagId, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling updateTag.');\n      }\n      if (tagId === null || tagId === undefined) {\n        throw new Error('Required parameter tagId was null or undefined when calling updateTag.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('put', `${this.basePath}/tag/${encodeURIComponent(String(tagId))}`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class11 = TagService;\n  _class11.ɵfac = function _class11_Factory(t) {\n    return new (t || _class11)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class11.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class11,\n    factory: _class11.ɵfac\n  });\n  return TagService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet UserService = /*#__PURE__*/(() => {\n  var _class12;\n  class UserService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    convertDummyUserById(body, userId, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling convertDummyUserById.');\n      }\n      if (userId === null || userId === undefined) {\n        throw new Error('Required parameter userId was null or undefined when calling convertDummyUserById.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/user/${encodeURIComponent(String(userId))}/convertDummyUserToNormalUser`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    createUser(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling createUser.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/user`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    deleteUserById(userId, observe = 'body', reportProgress = false) {\n      if (userId === null || userId === undefined) {\n        throw new Error('Required parameter userId was null or undefined when calling deleteUserById.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('delete', `${this.basePath}/user/${encodeURIComponent(String(userId))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getAmountOwedForUser(groupId, receiptIds, observe = 'body', reportProgress = false) {\n      let queryParameters = new HttpParams({\n        encoder: new CustomHttpUrlEncodingCodec()\n      });\n      if (groupId !== undefined && groupId !== null) {\n        queryParameters = queryParameters.set('groupId', groupId);\n      }\n      if (receiptIds) {\n        receiptIds.forEach(element => {\n          queryParameters = queryParameters.append('receiptIds', element);\n        });\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/user/amountOwedForUser`, {\n        params: queryParameters,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getUserClaims(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/user/getUserClaims`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getUsernameCount(username, observe = 'body', reportProgress = false) {\n      if (username === null || username === undefined) {\n        throw new Error('Required parameter username was null or undefined when calling getUsernameCount.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/user/${encodeURIComponent(String(username))}`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    getUsers(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/user`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    resetPasswordById(body, userId, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling resetPasswordById.');\n      }\n      if (userId === null || userId === undefined) {\n        throw new Error('Required parameter userId was null or undefined when calling resetPasswordById.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('post', `${this.basePath}/user/${encodeURIComponent(String(userId))}/resetPassword`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    updateUserById(body, userId, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling updateUserById.');\n      }\n      if (userId === null || userId === undefined) {\n        throw new Error('Required parameter userId was null or undefined when calling updateUserById.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('put', `${this.basePath}/user/${encodeURIComponent(String(userId))}`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    updateUserProfile(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling updateUserProfile.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = [];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('put', `${this.basePath}/user/updateUserProfile`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class12 = UserService;\n  _class12.ɵfac = function _class12_Factory(t) {\n    return new (t || _class12)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class12.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class12,\n    factory: _class12.ɵfac\n  });\n  return UserService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */ /* tslint:disable:no-unused-variable member-ordering */\nlet UserPreferencesService = /*#__PURE__*/(() => {\n  var _class13;\n  class UserPreferencesService {\n    constructor(httpClient, basePath, configuration) {\n      this.httpClient = httpClient;\n      this.basePath = '/api';\n      this.defaultHeaders = new HttpHeaders();\n      this.configuration = new Configuration();\n      if (basePath) {\n        this.basePath = basePath;\n      }\n      if (configuration) {\n        this.configuration = configuration;\n        this.basePath = basePath || configuration.basePath || this.basePath;\n      }\n    }\n    /**\n     * @param consumes string[] mime-types\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\n     */\n    canConsumeForm(consumes) {\n      const form = 'multipart/form-data';\n      for (const consume of consumes) {\n        if (form === consume) {\n          return true;\n        }\n      }\n      return false;\n    }\n    getUserPreferences(observe = 'body', reportProgress = false) {\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = [];\n      return this.httpClient.request('get', `${this.basePath}/userPreferences`, {\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n    updateUserPreferences(body, observe = 'body', reportProgress = false) {\n      if (body === null || body === undefined) {\n        throw new Error('Required parameter body was null or undefined when calling updateUserPreferences.');\n      }\n      let headers = this.defaultHeaders;\n      // authentication (bearerAuth) required\n      if (this.configuration.accessToken) {\n        const accessToken = typeof this.configuration.accessToken === 'function' ? this.configuration.accessToken() : this.configuration.accessToken;\n        headers = headers.set('Authorization', 'Bearer ' + accessToken);\n      }\n      // to determine the Accept header\n      let httpHeaderAccepts = ['application/json'];\n      const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n      if (httpHeaderAcceptSelected != undefined) {\n        headers = headers.set('Accept', httpHeaderAcceptSelected);\n      }\n      // to determine the Content-Type header\n      const consumes = ['application/json'];\n      const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);\n      if (httpContentTypeSelected != undefined) {\n        headers = headers.set('Content-Type', httpContentTypeSelected);\n      }\n      return this.httpClient.request('put', `${this.basePath}/userPreferences`, {\n        body: body,\n        withCredentials: this.configuration.withCredentials,\n        headers: headers,\n        observe: observe,\n        reportProgress: reportProgress\n      });\n    }\n  }\n  _class13 = UserPreferencesService;\n  _class13.ɵfac = function _class13_Factory(t) {\n    return new (t || _class13)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(BASE_PATH, 8), i0.ɵɵinject(Configuration, 8));\n  };\n  _class13.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class13,\n    factory: _class13.ɵfac\n  });\n  return UserPreferencesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst APIS = [AuthService, CategoryService, CommentService, DashboardService, FeatureConfigService, GroupsService, NotificationsService, ReceiptService, ReceiptImageService, SearchService, TagService, UserService, UserPreferencesService];\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\nvar Group = /*#__PURE__*/function (Group) {\n  Group.StatusEnum = {\n    ACTIVE: 'ACTIVE',\n    ARCHIVED: 'ARCHIVED'\n  };\n  return Group;\n}(Group || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nvar GroupMember = /*#__PURE__*/function (GroupMember) {\n  GroupMember.GroupRoleEnum = {\n    OWNER: 'OWNER',\n    VIEWER: 'VIEWER',\n    EDITOR: 'EDITOR'\n  };\n  return GroupMember;\n}(GroupMember || {});\nvar GroupSettings = /*#__PURE__*/function (GroupSettings) {\n  GroupSettings.EmailDefaultReceiptStatusEnum = {\n    OPEN: 'OPEN',\n    NEEDSATTENTION: 'NEEDS_ATTENTION',\n    RESOLVED: 'RESOLVED',\n    DRAFT: 'DRAFT'\n  };\n  return GroupSettings;\n}(GroupSettings || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nvar Item = /*#__PURE__*/function (Item) {\n  Item.StatusEnum = {\n    OPEN: 'OPEN',\n    RESOLVED: 'RESOLVED',\n    DRAFT: 'DRAFT'\n  };\n  return Item;\n}(Item || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nvar PagedRequestCommand = /*#__PURE__*/function (PagedRequestCommand) {\n  PagedRequestCommand.SortDirectionEnum = {\n    Asc: 'asc',\n    Desc: 'desc',\n    Empty: ''\n  };\n  return PagedRequestCommand;\n}(PagedRequestCommand || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nvar PagedRequestField = /*#__PURE__*/function (PagedRequestField) {\n  PagedRequestField.OperationEnum = {\n    CONTAINS: 'CONTAINS',\n    EQUALS: 'EQUALS',\n    GREATERTHAN: 'GREATER_THAN',\n    LESSTHAN: 'LESS_THAN'\n  };\n  return PagedRequestField;\n}(PagedRequestField || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nvar QuickScanCommand = /*#__PURE__*/function (QuickScanCommand) {\n  QuickScanCommand.StatusEnum = {\n    OPEN: 'OPEN',\n    NEEDSATTENTION: 'NEEDS_ATTENTION',\n    RESOLVED: 'RESOLVED',\n    DRAFT: 'DRAFT'\n  };\n  return QuickScanCommand;\n}(QuickScanCommand || {});\nvar Receipt = /*#__PURE__*/function (Receipt) {\n  Receipt.StatusEnum = {\n    OPEN: 'OPEN',\n    NEEDSATTENTION: 'NEEDS_ATTENTION',\n    RESOLVED: 'RESOLVED',\n    DRAFT: 'DRAFT'\n  };\n  return Receipt;\n}(Receipt || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\nvar ReceiptPagedRequestCommand = /*#__PURE__*/function (ReceiptPagedRequestCommand) {\n  ReceiptPagedRequestCommand.SortDirectionEnum = {\n    Asc: 'asc',\n    Desc: 'desc',\n    Empty: ''\n  };\n  return ReceiptPagedRequestCommand;\n}(ReceiptPagedRequestCommand || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\nvar UpdateGroupSettingsCommand = /*#__PURE__*/function (UpdateGroupSettingsCommand) {\n  UpdateGroupSettingsCommand.EmailDefaultReceiptStatusEnum = {\n    OPEN: 'OPEN',\n    NEEDSATTENTION: 'NEEDS_ATTENTION',\n    RESOLVED: 'RESOLVED',\n    DRAFT: 'DRAFT'\n  };\n  return UpdateGroupSettingsCommand;\n}(UpdateGroupSettingsCommand || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nvar UpsertWidgetCommand = /*#__PURE__*/function (UpsertWidgetCommand) {\n  UpsertWidgetCommand.WidgetTypeEnum = {\n    GROUPSUMMARY: 'GROUP_SUMMARY',\n    FILTEREDRECEIPTS: 'FILTERED_RECEIPTS'\n  };\n  return UpsertWidgetCommand;\n}(UpsertWidgetCommand || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nvar User = /*#__PURE__*/function (User) {\n  User.UserRoleEnum = {\n    ADMIN: 'ADMIN',\n    USER: 'USER'\n  };\n  return User;\n}(User || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nvar UserPreferences = /*#__PURE__*/function (UserPreferences) {\n  UserPreferences.QuickScanDefaultStatusEnum = {\n    OPEN: 'OPEN',\n    NEEDSATTENTION: 'NEEDS_ATTENTION',\n    RESOLVED: 'RESOLVED',\n    DRAFT: 'DRAFT'\n  };\n  return UserPreferences;\n}(UserPreferences || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nvar UserView = /*#__PURE__*/function (UserView) {\n  UserView.UserRoleEnum = {\n    ADMIN: 'ADMIN',\n    USER: 'USER'\n  };\n  return UserView;\n}(UserView || {});\n/**\n * Receipt Wrangler API.\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\n *\n * OpenAPI spec version: 0.0.1\n *\n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\nvar Widget = /*#__PURE__*/function (Widget) {\n  Widget.WidgetTypeEnum = {\n    GROUPSUMMARY: 'GROUP_SUMMARY',\n    FILTEREDRECEIPTS: 'FILTERED_RECEIPTS'\n  };\n  return Widget;\n}(Widget || {});\nlet ApiModule = /*#__PURE__*/(() => {\n  var _class14;\n  class ApiModule {\n    static forRoot(configurationFactory) {\n      return {\n        ngModule: ApiModule,\n        providers: [{\n          provide: Configuration,\n          useFactory: configurationFactory\n        }]\n      };\n    }\n    constructor(parentModule, http) {\n      if (parentModule) {\n        throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\n      }\n      if (!http) {\n        throw new Error('You need to import the HttpClientModule in your AppModule! \\n' + 'See also https://github.com/angular/angular/issues/20575');\n      }\n    }\n  }\n  _class14 = ApiModule;\n  _class14.ɵfac = function _class14_Factory(t) {\n    return new (t || _class14)(i0.ɵɵinject(_class14, 12), i0.ɵɵinject(i1.HttpClient, 8));\n  };\n  _class14.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class14\n  });\n  _class14.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AuthService, CategoryService, CommentService, DashboardService, FeatureConfigService, GroupsService, NotificationsService, ReceiptService, ReceiptImageService, SearchService, TagService, UserService, UserPreferencesService]\n  });\n  return ApiModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AddGroup = /*#__PURE__*/(() => {\n  var _class15;\n  class AddGroup {\n    constructor(group) {\n      this.group = group;\n    }\n  }\n  _class15 = AddGroup;\n  _class15.type = '[Group] Add Group';\n  return AddGroup;\n})();\nlet RemoveGroup = /*#__PURE__*/(() => {\n  var _class16;\n  class RemoveGroup {\n    constructor(groupId) {\n      this.groupId = groupId;\n    }\n  }\n  _class16 = RemoveGroup;\n  _class16.type = '[Group] Remove Group';\n  return RemoveGroup;\n})();\nlet SetGroups = /*#__PURE__*/(() => {\n  var _class17;\n  class SetGroups {\n    constructor(groups) {\n      this.groups = groups;\n    }\n  }\n  _class17 = SetGroups;\n  _class17.type = '[Group] Set Groups';\n  return SetGroups;\n})();\nlet UpdateGroup = /*#__PURE__*/(() => {\n  var _class18;\n  class UpdateGroup {\n    constructor(group) {\n      this.group = group;\n    }\n  }\n  _class18 = UpdateGroup;\n  _class18.type = '[Group] Update Group';\n  return UpdateGroup;\n})();\nlet SetSelectedDashboardId = /*#__PURE__*/(() => {\n  var _class19;\n  class SetSelectedDashboardId {\n    constructor(dashboardId) {\n      this.dashboardId = dashboardId;\n    }\n  }\n  _class19 = SetSelectedDashboardId;\n  _class19.type = '[Group] Set Selected Dashboard Id';\n  return SetSelectedDashboardId;\n})();\nlet SetSelectedGroupId = /*#__PURE__*/(() => {\n  var _class20;\n  class SetSelectedGroupId {\n    constructor(groupId) {\n      this.groupId = groupId;\n    }\n  }\n  _class20 = SetSelectedGroupId;\n  _class20.type = '[Group] Set Selected Group Id';\n  return SetSelectedGroupId;\n})();\nvar GroupState_1;\nlet GroupState = GroupState_1 = (_class21 = class GroupState {\n  static groups(state) {\n    return state.groups;\n  }\n  static allGroupMembers(state) {\n    return state.groups.map(g => g.groupMembers).flat();\n  }\n  static groupsWithoutAll(state) {\n    return state.groups.filter(g => !g.isAllGroup);\n  }\n  static groupsWithoutSelectedGroup(state) {\n    return state.groups.filter(g => g.id.toString() !== state.selectedGroupId);\n  }\n  static selectedDashboardId(state) {\n    return state.selectedDashboardId;\n  }\n  static selectedGroupId(state) {\n    return state.selectedGroupId;\n  }\n  static receiptListLink(state) {\n    return `/receipts/group/${state.selectedGroupId}`;\n  }\n  // TODO: needs to be fixed\n  static dashboardLink(state) {\n    return `/dashboard/group/${state.selectedGroupId}`;\n  }\n  static settingsLinkBase(state) {\n    return `/groups/${state.selectedGroupId}/settings`;\n  }\n  static getGroupById(groupId) {\n    return createSelector([GroupState_1], state => {\n      return state.groups.find(g => g.id.toString() === groupId.toString());\n    });\n  }\n  addGroup({\n    getState,\n    patchState\n  }, payload) {\n    const groups = Array.from(getState().groups);\n    groups.push(payload.group);\n    patchState({\n      groups: groups\n    });\n  }\n  removeGroup({\n    getState,\n    patchState\n  }, payload) {\n    const state = getState();\n    const group = GroupState_1.getGroupById(payload.groupId)(state);\n    if (group) {\n      const index = state.groups.findIndex(g => g === group);\n      if (index >= 0) {\n        const newInterface = {};\n        const newGroups = Array.from(state.groups).filter(g => g.id !== group.id);\n        newInterface.groups = newGroups;\n        if (group.id.toString() === state.selectedGroupId.toString()) {\n          newInterface.selectedGroupId = state.groups[0].id.toString();\n        }\n        patchState(newInterface);\n      }\n    }\n  }\n  setGroups({\n    patchState\n  }, payload) {\n    patchState({\n      groups: payload.groups\n    });\n  }\n  updateGroup({\n    getState,\n    patchState\n  }, payload) {\n    const groupIndex = getState().groups.findIndex(g => {\n      var _g$id, _payload$group;\n      return ((_g$id = g.id) === null || _g$id === void 0 ? void 0 : _g$id.toString()) === (payload === null || payload === void 0 || (_payload$group = payload.group) === null || _payload$group === void 0 || (_payload$group = _payload$group.id) === null || _payload$group === void 0 ? void 0 : _payload$group.toString());\n    });\n    if (groupIndex > -1) {\n      const newGroups = Array.from(getState().groups);\n      newGroups[groupIndex] = payload.group;\n      patchState({\n        groups: newGroups\n      });\n    }\n  }\n  setSelectedDashboardId({\n    getState,\n    patchState\n  }, payload) {\n    patchState({\n      selectedDashboardId: payload.dashboardId\n    });\n  }\n  setSelectedGroupId({\n    getState,\n    patchState\n  }, payload) {\n    let groupId = '';\n    let dashboardId = '';\n    if (payload !== null && payload !== void 0 && payload.groupId) {\n      groupId = payload.groupId;\n    } else {\n      const groups = getState().groups;\n      groupId = groups[0].id.toString();\n    }\n    if (payload.groupId === getState().selectedGroupId) {\n      dashboardId = getState().selectedDashboardId;\n    }\n    patchState({\n      selectedGroupId: groupId,\n      selectedDashboardId: dashboardId\n    });\n  }\n}, _class21.ɵfac = function _class21_Factory(t) {\n  return new (t || _class21)();\n}, _class21.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _class21,\n  factory: _class21.ɵfac\n}), _class21);\n__decorate([Action(AddGroup), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, AddGroup]), __metadata(\"design:returntype\", void 0)], GroupState.prototype, \"addGroup\", null);\n__decorate([Action(RemoveGroup), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, RemoveGroup]), __metadata(\"design:returntype\", void 0)], GroupState.prototype, \"removeGroup\", null);\n__decorate([Action(SetGroups), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, SetGroups]), __metadata(\"design:returntype\", void 0)], GroupState.prototype, \"setGroups\", null);\n__decorate([Action(UpdateGroup), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, UpdateGroup]), __metadata(\"design:returntype\", void 0)], GroupState.prototype, \"updateGroup\", null);\n__decorate([Action(SetSelectedDashboardId), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, SetSelectedDashboardId]), __metadata(\"design:returntype\", void 0)], GroupState.prototype, \"setSelectedDashboardId\", null);\n__decorate([Action(SetSelectedGroupId), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, SetSelectedGroupId]), __metadata(\"design:returntype\", void 0)], GroupState.prototype, \"setSelectedGroupId\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Array)], GroupState, \"groups\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Array)], GroupState, \"allGroupMembers\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Array)], GroupState, \"groupsWithoutAll\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Array)], GroupState, \"groupsWithoutSelectedGroup\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", String)], GroupState, \"selectedDashboardId\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", String)], GroupState, \"selectedGroupId\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", String)], GroupState, \"receiptListLink\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", String)], GroupState, \"dashboardLink\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", String)], GroupState, \"settingsLinkBase\", null);\nGroupState = GroupState_1 = __decorate([State({\n  name: 'groups',\n  defaults: {\n    groups: [],\n    selectedGroupId: '',\n    selectedDashboardId: ''\n  }\n})], GroupState);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UserValidators = /*#__PURE__*/(() => {\n  var _class22;\n  class UserValidators {\n    constructor(userService) {\n      this.userService = userService;\n    }\n    uniqueUsername(threshold, originalValue) {\n      return control => {\n        return this.userService.getUsernameCount(control.value).pipe(map(usernameCount => {\n          if (usernameCount > threshold && control.value !== originalValue) {\n            return {\n              duplicate: true\n            };\n          }\n          return null;\n        }));\n      };\n    }\n  }\n  _class22 = UserValidators;\n  _class22.ɵfac = function _class22_Factory(t) {\n    return new (t || _class22)(i0.ɵɵinject(UserService));\n  };\n  _class22.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class22,\n    factory: _class22.ɵfac\n  });\n  return UserValidators;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SetFeatureConfig = /*#__PURE__*/(() => {\n  var _class23;\n  class SetFeatureConfig {\n    constructor(config) {\n      this.config = config;\n    }\n  }\n  _class23 = SetFeatureConfig;\n  _class23.type = '[FeatureConfig] Set Feature Config';\n  return SetFeatureConfig;\n})();\nlet SetUsers = /*#__PURE__*/(() => {\n  var _class24;\n  class SetUsers {\n    constructor(users) {\n      this.users = users;\n    }\n  }\n  _class24 = SetUsers;\n  _class24.type = '[User] Set Users';\n  return SetUsers;\n})();\nlet UpdateUser = /*#__PURE__*/(() => {\n  var _class25;\n  class UpdateUser {\n    constructor(userId, user) {\n      this.userId = userId;\n      this.user = user;\n    }\n  }\n  _class25 = UpdateUser;\n  _class25.type = '[User] Update User';\n  return UpdateUser;\n})();\nlet AddUser = /*#__PURE__*/(() => {\n  var _class26;\n  class AddUser {\n    constructor(user) {\n      this.user = user;\n    }\n  }\n  _class26 = AddUser;\n  _class26.type = '[User] Add User';\n  return AddUser;\n})();\nlet RemoveUser = /*#__PURE__*/(() => {\n  var _class27;\n  class RemoveUser {\n    constructor(userId) {\n      this.userId = userId;\n    }\n  }\n  _class27 = RemoveUser;\n  _class27.type = '[User] Remove User';\n  return RemoveUser;\n})();\nlet SetAuthState = /*#__PURE__*/(() => {\n  var _class28;\n  class SetAuthState {\n    constructor(userClaims) {\n      this.userClaims = userClaims;\n    }\n  }\n  _class28 = SetAuthState;\n  _class28.type = '[Auth] Set Auth State';\n  return SetAuthState;\n})();\nlet SetUserPreferences = /*#__PURE__*/(() => {\n  var _class29;\n  class SetUserPreferences {\n    constructor(userPreferences) {\n      this.userPreferences = userPreferences;\n    }\n  }\n  _class29 = SetUserPreferences;\n  _class29.type = '[Auth] Set User PReferences';\n  return SetUserPreferences;\n})();\nlet Logout = /*#__PURE__*/(() => {\n  var _class30;\n  class Logout {}\n  _class30 = Logout;\n  _class30.type = '[Auth] Logout';\n  return Logout;\n})();\nlet ClaimsService = /*#__PURE__*/(() => {\n  var _class31;\n  class ClaimsService {\n    constructor(store, userService) {\n      this.store = store;\n      this.userService = userService;\n    }\n    getAndSetClaimsForLoggedInUser() {\n      return this.userService.getUserClaims().pipe(take(1), switchMap(claims => this.store.dispatch(new SetAuthState(claims))));\n    }\n  }\n  _class31 = ClaimsService;\n  _class31.ɵfac = function _class31_Factory(t) {\n    return new (t || _class31)(i0.ɵɵinject(i1$1.Store), i0.ɵɵinject(UserService));\n  };\n  _class31.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class31,\n    factory: _class31.ɵfac,\n    providedIn: 'root'\n  });\n  return ClaimsService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar AuthState_1;\nlet AuthState = AuthState_1 = (_class32 = class AuthState {\n  static userPreferences(state) {\n    return state.userPreferences;\n  }\n  static userRole(state) {\n    var _state$userRole;\n    return (_state$userRole = state.userRole) !== null && _state$userRole !== void 0 ? _state$userRole : '';\n  }\n  static isLoggedIn(state) {\n    return !AuthState_1.isTokenExpired(state);\n  }\n  static userId(state) {\n    var _state$userId;\n    return (_state$userId = state.userId) !== null && _state$userId !== void 0 ? _state$userId : '';\n  }\n  static isTokenExpired(state) {\n    if (state.expirationDate) {\n      return new Date() >= new Date(Number(state.expirationDate) * 1000);\n    } else {\n      return true;\n    }\n  }\n  static loggedInUser(state) {\n    var _state$defaultAvatarC, _state$displayname, _Number, _state$username;\n    return {\n      defaultAvatarColor: (_state$defaultAvatarC = state.defaultAvatarColor) !== null && _state$defaultAvatarC !== void 0 ? _state$defaultAvatarC : '',\n      displayName: (_state$displayname = state.displayname) !== null && _state$displayname !== void 0 ? _state$displayname : '',\n      id: (_Number = Number(state.userId)) !== null && _Number !== void 0 ? _Number : '',\n      username: (_state$username = state.username) !== null && _state$username !== void 0 ? _state$username : ''\n    };\n  }\n  static hasRole(role) {\n    return createSelector([AuthState_1], state => {\n      return state.userRole === role;\n    });\n  }\n  setAuthState({\n    getState,\n    patchState\n  }, payload) {\n    var _claims$exp, _claims$UserId;\n    const claims = payload.userClaims;\n    patchState({\n      defaultAvatarColor: claims['DefaultAvatarColor'],\n      displayname: claims['Displayname'],\n      expirationDate: (_claims$exp = claims['exp']) === null || _claims$exp === void 0 ? void 0 : _claims$exp.toString(),\n      userId: (_claims$UserId = claims['UserId']) === null || _claims$UserId === void 0 ? void 0 : _claims$UserId.toString(),\n      username: claims['Username'],\n      userRole: claims['UserRole']\n    });\n  }\n  logout({\n    getState,\n    patchState\n  }) {\n    patchState({\n      defaultAvatarColor: '',\n      displayname: '',\n      expirationDate: '',\n      userId: '',\n      username: '',\n      userRole: undefined,\n      userPreferences: undefined\n    });\n  }\n  setUserPreferences({\n    patchState\n  }, payload) {\n    patchState({\n      userPreferences: payload.userPreferences\n    });\n  }\n}, _class32.ɵfac = function _class32_Factory(t) {\n  return new (t || _class32)();\n}, _class32.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _class32,\n  factory: _class32.ɵfac\n}), _class32);\n__decorate([Action(SetAuthState), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, SetAuthState]), __metadata(\"design:returntype\", void 0)], AuthState.prototype, \"setAuthState\", null);\n__decorate([Action(Logout), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], AuthState.prototype, \"logout\", null);\n__decorate([Action(SetUserPreferences), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, SetUserPreferences]), __metadata(\"design:returntype\", void 0)], AuthState.prototype, \"setUserPreferences\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Object)], AuthState, \"userPreferences\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", String)], AuthState, \"userRole\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Boolean)], AuthState, \"isLoggedIn\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", String)], AuthState, \"userId\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Boolean)], AuthState, \"isTokenExpired\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Object)], AuthState, \"loggedInUser\", null);\nAuthState = AuthState_1 = __decorate([State({\n  name: 'auth',\n  defaults: {}\n})], AuthState);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar FeatureConfigState_1;\nlet FeatureConfigState = FeatureConfigState_1 = (_class33 = class FeatureConfigState {\n  static enableLocalSignUp(state) {\n    return state.enableLocalSignUp;\n  }\n  static aiPoweredReceipts(state) {\n    return state.aiPoweredReceipts;\n  }\n  static hasFeature(feature) {\n    return createSelector([FeatureConfigState_1], state => {\n      return !!state[feature];\n    });\n  }\n  setFeatureConfig({\n    patchState\n  }, payload) {\n    var _payload$config, _payload$config2;\n    patchState({\n      aiPoweredReceipts: (_payload$config = payload.config) === null || _payload$config === void 0 ? void 0 : _payload$config.aiPoweredReceipts,\n      enableLocalSignUp: (_payload$config2 = payload.config) === null || _payload$config2 === void 0 ? void 0 : _payload$config2.enableLocalSignUp\n    });\n  }\n}, _class33.ɵfac = function _class33_Factory(t) {\n  return new (t || _class33)();\n}, _class33.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _class33,\n  factory: _class33.ɵfac\n}), _class33);\n__decorate([Action(SetFeatureConfig), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, SetFeatureConfig]), __metadata(\"design:returntype\", void 0)], FeatureConfigState.prototype, \"setFeatureConfig\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Boolean)], FeatureConfigState, \"enableLocalSignUp\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Boolean)], FeatureConfigState, \"aiPoweredReceipts\", null);\nFeatureConfigState = FeatureConfigState_1 = __decorate([State({\n  name: 'featureConfig',\n  defaults: {\n    enableLocalSignUp: true,\n    aiPoweredReceipts: false\n  }\n})], FeatureConfigState);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar UserState_1;\nlet UserState = UserState_1 = (_class34 = class UserState {\n  static users(state) {\n    return state.users;\n  }\n  static getUserById(userId) {\n    return createSelector([UserState_1], state => {\n      return state.users.find(u => u.id.toString() === userId.toString());\n    });\n  }\n  static findUserById(userId) {\n    return createSelector([UserState_1], state => {\n      return state.users.find(u => u.id.toString() === userId.toString());\n    });\n  }\n  static findUserIndexById(userId, users) {\n    return users.findIndex(u => u.id.toString() === userId);\n  }\n  setUsers({\n    getState,\n    patchState\n  }, payload) {\n    patchState({\n      users: payload.users\n    });\n  }\n  updateUser({\n    getState,\n    patchState\n  }, payload) {\n    const users = Array.from(getState().users);\n    const index = UserState_1.findUserIndexById(payload.userId, users);\n    if (index >= 0) {\n      users.splice(index, 1, payload.user);\n      patchState({\n        users: users\n      });\n    }\n  }\n  addUser({\n    getState,\n    patchState\n  }, payload) {\n    const users = Array.from(getState().users);\n    users.push(payload.user);\n    patchState({\n      users: users\n    });\n  }\n  removeUser({\n    getState,\n    patchState\n  }, payload) {\n    const users = Array.from(getState().users);\n    patchState({\n      users: users.filter(u => u.id.toString() !== payload.userId.toString())\n    });\n  }\n}, _class34.ɵfac = function _class34_Factory(t) {\n  return new (t || _class34)();\n}, _class34.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: _class34,\n  factory: _class34.ɵfac\n}), _class34);\n__decorate([Action(SetUsers), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, SetUsers]), __metadata(\"design:returntype\", void 0)], UserState.prototype, \"setUsers\", null);\n__decorate([Action(UpdateUser), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, UpdateUser]), __metadata(\"design:returntype\", void 0)], UserState.prototype, \"updateUser\", null);\n__decorate([Action(AddUser), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, AddUser]), __metadata(\"design:returntype\", void 0)], UserState.prototype, \"addUser\", null);\n__decorate([Action(RemoveUser), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, RemoveUser]), __metadata(\"design:returntype\", void 0)], UserState.prototype, \"removeUser\", null);\n__decorate([Selector(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", Array)], UserState, \"users\", null);\nUserState = UserState_1 = __decorate([State({\n  name: 'users',\n  defaults: {\n    users: []\n  }\n})], UserState);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AppInitService = /*#__PURE__*/(() => {\n  var _class35;\n  class AppInitService {\n    constructor(authService, claimsService, featureConfigService, groupsService, store, userService, userPreferencesService) {\n      this.authService = authService;\n      this.claimsService = claimsService;\n      this.featureConfigService = featureConfigService;\n      this.groupsService = groupsService;\n      this.store = store;\n      this.userService = userService;\n      this.userPreferencesService = userPreferencesService;\n    }\n    initAppData() {\n      return new Promise(resolve => {\n        this.featureConfigService.getFeatureConfig().pipe(take(1), switchMap(config => this.store.dispatch(new SetFeatureConfig(config))), catchError(err => {\n          resolve(false);\n          return err;\n        }), switchMap(() => this.authService.getNewRefreshToken()), switchMap(() => this.getAppData()), tap(() => resolve(true))).subscribe();\n      });\n    }\n    getAppData() {\n      const usersCall = this.userService.getUsers().pipe(take(1), tap(users => this.store.dispatch(new SetUsers(users))));\n      const groupsCall = this.groupsService.getGroupsForuser().pipe(take(1), tap(groups => {\n        this.store.dispatch(new SetGroups(groups));\n        const groupId = this.store.selectSnapshot(GroupState.selectedGroupId);\n        if (!groupId) {\n          this.store.dispatch(new SetSelectedGroupId());\n        }\n      }));\n      const userClaims = this.claimsService.getAndSetClaimsForLoggedInUser();\n      const userPreferencesCall = this.userPreferencesService.getUserPreferences().pipe(take(1), tap(userPreferences => {\n        this.store.dispatch(new SetUserPreferences(userPreferences));\n      }));\n      return forkJoin(usersCall, groupsCall, userClaims, userPreferencesCall);\n    }\n  }\n  _class35 = AppInitService;\n  _class35.ɵfac = function _class35_Factory(t) {\n    return new (t || _class35)(i0.ɵɵinject(AuthService), i0.ɵɵinject(ClaimsService), i0.ɵɵinject(FeatureConfigService), i0.ɵɵinject(GroupsService), i0.ɵɵinject(i1$1.Store), i0.ɵɵinject(UserService), i0.ɵɵinject(UserPreferencesService));\n  };\n  _class35.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class35,\n    factory: _class35.ɵfac,\n    providedIn: 'root'\n  });\n  return AppInitService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction initAppData(appInitService) {\n  return () => appInitService.initAppData();\n}\nconst DEFAULT_SNACKBAR_ACTION = 'Ok';\nconst DEFAULT_SNACKBAR_CONFIG = {\n  horizontalPosition: 'center',\n  verticalPosition: 'top',\n  duration: 3000\n};\nlet SnackbarService = /*#__PURE__*/(() => {\n  var _class36;\n  class SnackbarService {\n    constructor(snackbar) {\n      this.snackbar = snackbar;\n    }\n    error(message) {\n      this.snackbar.open(message, DEFAULT_SNACKBAR_ACTION, {\n        ...DEFAULT_SNACKBAR_CONFIG,\n        panelClass: ['error-snackbar']\n      });\n    }\n    success(message, configOverrides) {\n      this.snackbar.open(message, DEFAULT_SNACKBAR_ACTION, {\n        ...DEFAULT_SNACKBAR_CONFIG,\n        ...configOverrides,\n        panelClass: ['success-snackbar']\n      });\n    }\n    successFromTemplate(template, configOverrides) {\n      return this.snackbar.openFromTemplate(template, {\n        ...DEFAULT_SNACKBAR_CONFIG,\n        ...configOverrides,\n        panelClass: ['success-snackbar']\n      });\n    }\n  }\n  _class36 = SnackbarService;\n  _class36.ɵfac = function _class36_Factory(t) {\n    return new (t || _class36)(i0.ɵɵinject(i1$2.MatSnackBar));\n  };\n  _class36.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class36,\n    factory: _class36.ɵfac,\n    providedIn: 'root'\n  });\n  return SnackbarService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AuthFormUtil = /*#__PURE__*/(() => {\n  var _class37;\n  class AuthFormUtil {\n    constructor(authService, snackbarService, appInitService) {\n      this.authService = authService;\n      this.snackbarService = snackbarService;\n      this.appInitService = appInitService;\n    }\n    getSubmitObservable(form, isSignUp) {\n      const isValid = form.valid;\n      if (isValid && isSignUp) {\n        return this.authService.signUp(form.value).pipe(tap(() => {\n          this.snackbarService.success('User successfully signed up');\n        }), catchError(err => {\n          var _err$error$username;\n          return of(this.snackbarService.error((_err$error$username = err.error['username']) !== null && _err$error$username !== void 0 ? _err$error$username : err['errMsg']));\n        }));\n      } else if (isValid && !isSignUp) {\n        return this.authService.login(form.value).pipe(tap(() => {\n          this.snackbarService.success('Successfully logged in');\n        }), switchMap(() => this.appInitService.getAppData()), map(() => undefined));\n      } else {\n        return of(undefined);\n      }\n    }\n  }\n  _class37 = AuthFormUtil;\n  _class37.ɵfac = function _class37_Factory(t) {\n    return new (t || _class37)(i0.ɵɵinject(AuthService), i0.ɵɵinject(SnackbarService), i0.ɵɵinject(AppInitService));\n  };\n  _class37.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class37,\n    factory: _class37.ɵfac\n  });\n  return AuthFormUtil;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ButtonComponent = /*#__PURE__*/(() => {\n  var _class38;\n  class ButtonComponent {\n    constructor() {\n      this.buttonClass = '';\n      this.color = 'primary';\n      this.buttonText = '';\n      this.type = 'button';\n      this.matButtonType = 'matRaisedButton';\n      this.icon = '';\n      this.customIcon = '';\n      this.disabled = false;\n      this.buttonRouterLink = [];\n      this.tooltip = '';\n      this.matBadgeColor = 'primary';\n      this.clicked = new EventEmitter();\n    }\n    emitClicked(event) {\n      this.clicked.emit(event);\n    }\n  }\n  _class38 = ButtonComponent;\n  _class38.ɵfac = function _class38_Factory(t) {\n    return new (t || _class38)();\n  };\n  _class38.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class38,\n    selectors: [[\"app-button\"]],\n    inputs: {\n      buttonClass: \"buttonClass\",\n      color: \"color\",\n      buttonText: \"buttonText\",\n      type: \"type\",\n      matButtonType: \"matButtonType\",\n      icon: \"icon\",\n      customIcon: \"customIcon\",\n      disabled: \"disabled\",\n      buttonRouterLink: \"buttonRouterLink\",\n      tooltip: \"tooltip\",\n      matBadgeContent: \"matBadgeContent\",\n      matBadgeColor: \"matBadgeColor\"\n    },\n    outputs: {\n      clicked: \"clicked\"\n    },\n    decls: 4,\n    vars: 4,\n    consts: [[3, \"ngSwitch\"], [\"mat-button\", \"\", 3, \"class\", \"type\", \"color\", \"disabled\", \"matTooltip\", \"routerLink\", \"matBadgeColor\", \"matBadge\", \"click\", 4, \"ngSwitchCase\"], [\"mat-raised-button\", \"\", 3, \"class\", \"type\", \"color\", \"disabled\", \"matTooltip\", \"matBadgeColor\", \"matBadge\", \"routerLink\", \"click\", 4, \"ngSwitchCase\"], [\"mat-icon-button\", \"\", 3, \"class\", \"type\", \"color\", \"disabled\", \"routerLink\", \"matTooltip\", \"matBadgeColor\", \"matBadge\", \"click\", 4, \"ngSwitchCase\"], [\"mat-button\", \"\", 3, \"type\", \"color\", \"disabled\", \"matTooltip\", \"routerLink\", \"matBadgeColor\", \"matBadge\", \"click\"], [1, \"d-flex\", \"align-items-center\"], [\"class\", \"me-1\", 4, \"ngIf\"], [1, \"me-1\"], [\"mat-raised-button\", \"\", 3, \"type\", \"color\", \"disabled\", \"matTooltip\", \"matBadgeColor\", \"matBadge\", \"routerLink\", \"click\"], [\"mat-icon-button\", \"\", 3, \"type\", \"color\", \"disabled\", \"routerLink\", \"matTooltip\", \"matBadgeColor\", \"matBadge\", \"click\"], [3, \"svgIcon\", 4, \"ngIf\"], [4, \"ngIf\"], [3, \"svgIcon\"]],\n    template: function _class38_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementContainerStart(0, 0);\n        i0.ɵɵtemplate(1, _class38_button_1_Template, 5, 11, \"button\", 1);\n        i0.ɵɵtemplate(2, _class38_button_2_Template, 5, 11, \"button\", 2);\n        i0.ɵɵtemplate(3, _class38_button_3_Template, 3, 11, \"button\", 3);\n        i0.ɵɵelementContainerEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngSwitch\", ctx.matButtonType);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", \"basic\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", \"matRaisedButton\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngSwitchCase\", \"iconButton\");\n      }\n    },\n    dependencies: [i1$3.NgIf, i1$3.NgSwitch, i1$3.NgSwitchCase, i2.MatBadge, i3.MatButton, i3.MatIconButton, i4.MatIcon, i5.MatTooltip, i3$1.RouterLink],\n    styles: [\"app-button{width:-moz-fit-content;width:fit-content}app-button .mat-badge-content{color:#fff}\\n\"],\n    encapsulation: 2\n  });\n  return ButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Add the template content to the DOM unless the condition is true.\n */\nlet FeatureDirective = /*#__PURE__*/(() => {\n  var _class39;\n  class FeatureDirective {\n    constructor(templateRef, viewContainer, store) {\n      this.templateRef = templateRef;\n      this.viewContainer = viewContainer;\n      this.store = store;\n      this.hasView = false;\n    }\n    set appFeature(feature) {\n      const hasFeature = this.store.selectSnapshot(FeatureConfigState.hasFeature(feature));\n      if (hasFeature) {\n        this.viewContainer.createEmbeddedView(this.templateRef);\n        this.hasView = true;\n      } else if (!hasFeature) {\n        this.viewContainer.clear();\n        this.hasView = false;\n      }\n    }\n  }\n  _class39 = FeatureDirective;\n  _class39.ɵfac = function _class39_Factory(t) {\n    return new (t || _class39)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i1$1.Store));\n  };\n  _class39.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class39,\n    selectors: [[\"\", \"appFeature\", \"\"]],\n    inputs: {\n      appFeature: \"appFeature\"\n    }\n  });\n  return FeatureDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BaseInputComponent = /*#__PURE__*/(() => {\n  var _class40;\n  class BaseInputComponent {\n    constructor() {\n      this.inputFormControl = new FormControl();\n      this.label = '';\n      this.readonly = false;\n      this.errorMessages = {};\n    }\n    ngOnInit() {\n      this.errorMessages = {\n        required: `${this.label} is required.`,\n        email: `${this.label} must be a valid email address.`,\n        duplicate: `${this.label} must be unique.`,\n        min: `Value must be larger than 0`\n      };\n      this.formControlErrors = this.inputFormControl.statusChanges.pipe(startWith(this.inputFormControl.status), map(() => {\n        const errors = this.inputFormControl.errors;\n        if (errors) {\n          const keys = Object.keys(this.inputFormControl.errors);\n          return keys.map(k => {\n            const value = errors[k];\n            let message = '';\n            if (typeof value === 'string') {\n              message = value;\n            } else if (this.errorMessages[k]) {\n              message = this.errorMessages[k];\n            }\n            return {\n              error: k,\n              message: message\n            };\n          });\n        } else {\n          return [];\n        }\n      }));\n      if (this.additionalErrorMessages) {\n        this.errorMessages = {\n          ...this.errorMessages,\n          ...this.additionalErrorMessages\n        };\n      }\n    }\n  }\n  _class40 = BaseInputComponent;\n  _class40.ɵfac = function _class40_Factory(t) {\n    return new (t || _class40)();\n  };\n  _class40.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class40,\n    selectors: [[\"app-base-input\"]],\n    inputs: {\n      inputFormControl: \"inputFormControl\",\n      label: \"label\",\n      additionalErrorMessages: \"additionalErrorMessages\",\n      readonly: \"readonly\",\n      placeholder: \"placeholder\"\n    },\n    decls: 2,\n    vars: 0,\n    template: function _class40_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"p\");\n        i0.ɵɵtext(1, \"base-input works!\");\n        i0.ɵɵelementEnd();\n      }\n    }\n  });\n  return BaseInputComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet InputComponent = /*#__PURE__*/(() => {\n  var _class41;\n  class InputComponent extends BaseInputComponent {\n    constructor() {\n      super(...arguments);\n      this.inputId = '';\n      this.type = 'text';\n      this.showVisibilityEye = false;\n      this.isCurrency = false;\n      this.mask = '';\n      this.maskPrefix = '';\n      this.thousandSeparator = '';\n      this.inputBlur = new EventEmitter(undefined);\n    }\n    ngOnChanges(changes) {\n      var _changes$isCurrency;\n      if ((_changes$isCurrency = changes['isCurrency']) !== null && _changes$isCurrency !== void 0 && _changes$isCurrency.currentValue) {\n        this.maskPrefix = '$ ';\n        this.mask = 'separator.2';\n        this.thousandSeparator = ',';\n      }\n    }\n    toggleVisibility() {\n      if (this.type !== 'password') {\n        this.type = 'password';\n      } else {\n        this.type = 'text';\n      }\n    }\n  }\n  _class41 = InputComponent;\n  _class41.ɵfac = /* @__PURE__ */function () {\n    let ɵ_class41_BaseFactory;\n    return function _class41_Factory(t) {\n      return (ɵ_class41_BaseFactory || (ɵ_class41_BaseFactory = i0.ɵɵgetInheritedFactory(_class41)))(t || _class41);\n    };\n  }();\n  _class41.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class41,\n    selectors: [[\"app-input\"]],\n    viewQuery: function _class41_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nativeInput = _t.first);\n      }\n    },\n    inputs: {\n      inputId: \"inputId\",\n      type: \"type\",\n      showVisibilityEye: \"showVisibilityEye\",\n      isCurrency: \"isCurrency\",\n      mask: \"mask\",\n      maskPrefix: \"maskPrefix\",\n      thousandSeparator: \"thousandSeparator\"\n    },\n    outputs: {\n      inputBlur: \"inputBlur\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 9,\n    vars: 12,\n    consts: [[1, \"w-100\"], [1, \"d-flex\", \"align-items-center\"], [\"matInput\", \"\", 3, \"id\", \"type\", \"readonly\", \"formControl\", \"prefix\", \"mask\", \"thousandSeparator\", \"blur\"], [\"nativeInput\", \"\"], [\"mat-icon-button\", \"\", \"type\", \"button\", 3, \"matTooltip\", \"click\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [\"mat-icon-button\", \"\", \"type\", \"button\", 3, \"matTooltip\", \"click\"], [4, \"ngIf\"]],\n    template: function _class41_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"mat-form-field\", 0)(1, \"mat-label\");\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 1)(4, \"input\", 2, 3);\n        i0.ɵɵlistener(\"blur\", function _class41_Template_input_blur_4_listener($event) {\n          return ctx.inputBlur.emit($event);\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, _class41_button_6_Template, 3, 3, \"button\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(7, _class41_mat_error_7_Template, 2, 1, \"mat-error\", 5);\n        i0.ɵɵpipe(8, \"async\");\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.label);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"id\", ctx.inputId)(\"type\", ctx.type)(\"readonly\", ctx.readonly)(\"formControl\", ctx.inputFormControl)(\"prefix\", ctx.maskPrefix)(\"mask\", ctx.mask)(\"thousandSeparator\", ctx.thousandSeparator);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.showVisibilityEye);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", i0.ɵɵpipeBind1(8, 10, ctx.formControlErrors));\n      }\n    },\n    dependencies: [i1$3.NgForOf, i1$3.NgIf, i3.MatIconButton, i3$2.MatFormField, i3$2.MatLabel, i3$2.MatError, i4.MatIcon, i5$1.MatInput, i5.MatTooltip, i7.NgxMaskDirective, i2$1.DefaultValueAccessor, i2$1.NgControlStatus, i2$1.FormControlDirective, i1$3.AsyncPipe]\n  });\n  return InputComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormGetPipe = /*#__PURE__*/(() => {\n  var _class42;\n  class FormGetPipe {\n    transform(form, path) {\n      const result = form.get(path);\n      if (result) {\n        return result;\n      } else {\n        return new FormControl();\n      }\n    }\n  }\n  _class42 = FormGetPipe;\n  _class42.ɵfac = function _class42_Factory(t) {\n    return new (t || _class42)();\n  };\n  _class42.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"formGet\",\n    type: _class42,\n    pure: true\n  });\n  return FormGetPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AuthForm = /*#__PURE__*/(() => {\n  var _class43;\n  class AuthForm {\n    constructor(authFormUtil, formBuilder, route, router, store, userValidators) {\n      this.authFormUtil = authFormUtil;\n      this.formBuilder = formBuilder;\n      this.route = route;\n      this.router = router;\n      this.store = store;\n      this.userValidators = userValidators;\n      this.emitSubmit = false;\n      this.submitted = new EventEmitter();\n      this.form = new FormGroup({});\n      this.isSignUp = new BehaviorSubject(false);\n      this.headerText = '';\n      this.primaryButtonText = '';\n      this.secondaryButtonText = '';\n      this.secondaryButtonRouterLink = [];\n    }\n    ngOnInit() {\n      this.initForm();\n      this.listenForRouteChanges();\n      this.listenForIsSignUpChanges();\n    }\n    listenForRouteChanges() {\n      this.route.data.pipe(tap(data => {\n        this.isSignUp.next(!!(data !== null && data !== void 0 && data['isSignUp']));\n      })).subscribe();\n    }\n    listenForIsSignUpChanges() {\n      this.isSignUp.pipe(tap(isSignUp => {\n        if (isSignUp) {\n          var _this$form$get;\n          this.headerText = 'Sign Up';\n          this.primaryButtonText = 'Sign Up';\n          this.secondaryButtonRouterLink = ['/auth/login'];\n          this.secondaryButtonText = 'Back to Login';\n          (_this$form$get = this.form.get('username')) === null || _this$form$get === void 0 || _this$form$get.addAsyncValidators(this.userValidators.uniqueUsername(0, ''));\n          this.form.addControl('displayname', new FormControl('', Validators.required));\n        } else {\n          var _this$form$get2;\n          this.headerText = 'Login';\n          this.primaryButtonText = 'Login';\n          this.secondaryButtonRouterLink = ['/auth/sign-up'];\n          this.secondaryButtonText = 'Sign Up';\n          (_this$form$get2 = this.form.get('username')) === null || _this$form$get2 === void 0 || _this$form$get2.removeAsyncValidators(this.userValidators.uniqueUsername(0, ''));\n          this.form.removeControl('displayname');\n        }\n      })).subscribe();\n    }\n    initForm() {\n      this.form = this.formBuilder.group({\n        username: ['', [Validators.required]],\n        password: ['', Validators.required]\n      });\n    }\n    submit() {\n      if (this.emitSubmit) {\n        this.submitted.emit();\n      } else {\n        const isSignUp = this.isSignUp.getValue();\n        this.authFormUtil.getSubmitObservable(this.form, isSignUp).pipe(take(1), tap(() => {\n          this.router.navigate([this.store.selectSnapshot(GroupState.dashboardLink)]);\n        })).subscribe();\n      }\n    }\n  }\n  _class43 = AuthForm;\n  _class43.ɵfac = function _class43_Factory(t) {\n    return new (t || _class43)(i0.ɵɵdirectiveInject(AuthFormUtil), i0.ɵɵdirectiveInject(i2$1.FormBuilder), i0.ɵɵdirectiveInject(i3$1.ActivatedRoute), i0.ɵɵdirectiveInject(i3$1.Router), i0.ɵɵdirectiveInject(i1$1.Store), i0.ɵɵdirectiveInject(UserValidators));\n  };\n  _class43.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: _class43,\n    selectors: [[\"app-auth-form\"]],\n    inputs: {\n      additionalFieldsTemplate: \"additionalFieldsTemplate\",\n      emitSubmit: \"emitSubmit\"\n    },\n    outputs: {\n      submitted: \"submitted\"\n    },\n    features: [i0.ɵɵProvidersFeature([UserValidators])],\n    decls: 15,\n    vars: 17,\n    consts: [[1, \"d-flex\", \"align-items-center\", \"justify-content-center\"], [3, \"formGroup\", \"ngSubmit\"], [1, \"d-flex\", \"flex-column\"], [4, \"ngIf\"], [\"label\", \"Username\", 3, \"inputFormControl\"], [\"label\", \"Password\", \"type\", \"password\", 3, \"showVisibilityEye\", \"inputFormControl\"], [1, \"w-100\", \"d-flex\", \"flex-column\"], [\"buttonClass\", \"w-100 mb-2\", \"type\", \"submit\", 1, \"w-100\", 3, \"buttonText\"], [\"class\", \"w-100\", \"buttonClass\", \"w-100 \", \"type\", \"button\", \"color\", \"accent\", 3, \"buttonText\", \"routerLink\", 4, \"appFeature\"], [3, \"ngTemplateOutlet\"], [\"label\", \"Displayname\", 3, \"inputFormControl\"], [\"buttonClass\", \"w-100 \", \"type\", \"button\", \"color\", \"accent\", 1, \"w-100\", 3, \"buttonText\", \"routerLink\"]],\n    template: function _class43_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"form\", 1);\n        i0.ɵɵlistener(\"ngSubmit\", function _class43_Template_form_ngSubmit_1_listener() {\n          return ctx.submit();\n        });\n        i0.ɵɵelementStart(2, \"h2\");\n        i0.ɵɵtext(3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"div\", 2);\n        i0.ɵɵtemplate(5, _class43_5_Template, 1, 1, null, 3);\n        i0.ɵɵtemplate(6, _class43_ng_container_6_Template, 3, 4, \"ng-container\", 3);\n        i0.ɵɵpipe(7, \"async\");\n        i0.ɵɵelement(8, \"app-input\", 4);\n        i0.ɵɵpipe(9, \"formGet\");\n        i0.ɵɵelement(10, \"app-input\", 5);\n        i0.ɵɵpipe(11, \"formGet\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(12, \"div\", 6);\n        i0.ɵɵelement(13, \"app-button\", 7);\n        i0.ɵɵtemplate(14, _class43_app_button_14_Template, 1, 2, \"app-button\", 8);\n        i0.ɵɵelementEnd()()();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"formGroup\", ctx.form);\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(ctx.headerText);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.additionalFieldsTemplate);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(7, 9, ctx.isSignUp));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"inputFormControl\", i0.ɵɵpipeBind2(9, 11, ctx.form, \"username\"));\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"showVisibilityEye\", true)(\"inputFormControl\", i0.ɵɵpipeBind2(11, 14, ctx.form, \"password\"));\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"buttonText\", ctx.primaryButtonText);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"appFeature\", \"enableLocalSignUp\");\n      }\n    },\n    dependencies: [i3$1.RouterLink, ButtonComponent, i1$3.NgIf, i1$3.NgTemplateOutlet, FeatureDirective, InputComponent, i2$1.ɵNgNoValidate, i2$1.NgControlStatusGroup, i2$1.FormGroupDirective, i1$3.AsyncPipe, FormGetPipe]\n  });\n  return AuthForm;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FeatureGuard = /*#__PURE__*/(() => {\n  var _class44;\n  class FeatureGuard {\n    constructor(store) {\n      this.store = store;\n    }\n    canActivate(route, state) {\n      return this.store.selectSnapshot(FeatureConfigState.hasFeature(route.data['feature']));\n    }\n  }\n  _class44 = FeatureGuard;\n  _class44.ɵfac = function _class44_Factory(t) {\n    return new (t || _class44)(i0.ɵɵinject(i1$1.Store));\n  };\n  _class44.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class44,\n    factory: _class44.ɵfac,\n    providedIn: 'root'\n  });\n  return FeatureGuard;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst authRoutes = [{\n  path: 'sign-up',\n  component: AuthForm,\n  data: {\n    isSignUp: true,\n    feature: 'enableLocalSignUp'\n  },\n  canActivate: [FeatureGuard]\n}, {\n  path: 'login',\n  component: AuthForm\n}];\nlet AuthRoutingModule = /*#__PURE__*/(() => {\n  var _class45;\n  class AuthRoutingModule {}\n  _class45 = AuthRoutingModule;\n  _class45.ɵfac = function _class45_Factory(t) {\n    return new (t || _class45)();\n  };\n  _class45.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class45\n  });\n  _class45.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [RouterModule.forChild(authRoutes), RouterModule]\n  });\n  return AuthRoutingModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ButtonModule = /*#__PURE__*/(() => {\n  var _class46;\n  class ButtonModule {}\n  _class46 = ButtonModule;\n  _class46.ɵfac = function _class46_Factory(t) {\n    return new (t || _class46)();\n  };\n  _class46.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class46\n  });\n  _class46.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, MatBadgeModule, MatButtonModule, MatIconModule, MatTooltipModule, RouterModule]\n  });\n  return ButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RoleDirective = /*#__PURE__*/(() => {\n  var _class47;\n  class RoleDirective {\n    constructor(templateRef, viewContainer, store) {\n      this.templateRef = templateRef;\n      this.viewContainer = viewContainer;\n      this.store = store;\n      this.hasView = false;\n    }\n    set appRole(role) {\n      const hasRole = this.store.selectSnapshot(AuthState.hasRole(role));\n      if (hasRole) {\n        this.viewContainer.createEmbeddedView(this.templateRef);\n        this.hasView = true;\n      } else if (!hasRole) {\n        this.viewContainer.clear();\n        this.hasView = false;\n      }\n    }\n  }\n  _class47 = RoleDirective;\n  _class47.ɵfac = function _class47_Factory(t) {\n    return new (t || _class47)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i1$1.Store));\n  };\n  _class47.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class47,\n    selectors: [[\"\", \"appRole\", \"\"]],\n    inputs: {\n      appRole: \"appRole\"\n    }\n  });\n  return RoleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DirectivesModule = /*#__PURE__*/(() => {\n  var _class48;\n  class DirectivesModule {}\n  _class48 = DirectivesModule;\n  _class48.ɵfac = function _class48_Factory(t) {\n    return new (t || _class48)();\n  };\n  _class48.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class48\n  });\n  _class48.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return DirectivesModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet InputModule = /*#__PURE__*/(() => {\n  var _class49;\n  class InputModule {}\n  _class49 = InputModule;\n  _class49.ɵfac = function _class49_Factory(t) {\n    return new (t || _class49)();\n  };\n  _class49.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class49\n  });\n  _class49.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [provideNgxMask()],\n    imports: [CommonModule, MatButtonModule, MatFormFieldModule, MatIconModule, MatInputModule, MatTooltipModule, ReactiveFormsModule]\n  });\n  return InputModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PipesModule = /*#__PURE__*/(() => {\n  var _class50;\n  class PipesModule {}\n  _class50 = PipesModule;\n  _class50.ɵfac = function _class50_Factory(t) {\n    return new (t || _class50)();\n  };\n  _class50.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class50\n  });\n  _class50.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return PipesModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AuthModule = /*#__PURE__*/(() => {\n  var _class51;\n  class AuthModule {}\n  _class51 = AuthModule;\n  _class51.ɵfac = function _class51_Factory(t) {\n    return new (t || _class51)();\n  };\n  _class51.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class51\n  });\n  _class51.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [AuthRoutingModule, ButtonModule, CommonModule, DirectivesModule, InputModule, PipesModule, ReactiveFormsModule]\n  });\n  return AuthModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BaseInputModule = /*#__PURE__*/(() => {\n  var _class52;\n  class BaseInputModule {}\n  _class52 = BaseInputModule;\n  _class52.ɵfac = function _class52_Factory(t) {\n    return new (t || _class52)();\n  };\n  _class52.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class52\n  });\n  _class52.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return BaseInputModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AuthGuard = /*#__PURE__*/(() => {\n  var _class53;\n  class AuthGuard {\n    constructor(router, store) {\n      this.router = router;\n      this.store = store;\n    }\n    canActivate(route, state) {\n      const isLoggedIn = this.store.selectSnapshot(AuthState.isLoggedIn);\n      const navigatingToAuth = route.url.toString().includes('auth');\n      // if user tries to go to login screens while already logged in\n      if (navigatingToAuth && isLoggedIn) {\n        this.router.navigate([this.store.selectSnapshot(GroupState.dashboardLink)]);\n        return false;\n      } else if (navigatingToAuth && !isLoggedIn) {\n        return true;\n      }\n      if (!isLoggedIn) {\n        this.router.navigate(['/auth/login']);\n      }\n      return isLoggedIn;\n    }\n  }\n  _class53 = AuthGuard;\n  _class53.ɵfac = function _class53_Factory(t) {\n    return new (t || _class53)(i0.ɵɵinject(i3$1.Router), i0.ɵɵinject(i1$1.Store));\n  };\n  _class53.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class53,\n    factory: _class53.ɵfac,\n    providedIn: 'root'\n  });\n  return AuthGuard;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { APIS, AddGroup, AddUser, ApiModule, AppInitService, AuthForm, AuthFormUtil, AuthGuard, AuthModule, AuthRoutingModule, AuthService, AuthState, BASE_PATH, BaseInputComponent, BaseInputModule, ButtonComponent, ButtonModule, COLLECTION_FORMATS, CategoryService, ClaimsService, CommentService, Configuration, DEFAULT_SNACKBAR_ACTION, DEFAULT_SNACKBAR_CONFIG, DashboardService, DirectivesModule, FeatureConfigService, FeatureConfigState, FeatureDirective, FeatureGuard, FormGetPipe, Group, GroupMember, GroupSettings, GroupState, GroupsService, InputComponent, InputModule, Item, Logout, NotificationsService, PagedRequestCommand, PagedRequestField, PipesModule, QuickScanCommand, Receipt, ReceiptImageService, ReceiptPagedRequestCommand, ReceiptService, RemoveGroup, RemoveUser, RoleDirective, SearchService, SetAuthState, SetFeatureConfig, SetGroups, SetSelectedDashboardId, SetSelectedGroupId, SetUserPreferences, SetUsers, SnackbarService, TagService, UpdateGroup, UpdateGroupSettingsCommand, UpdateUser, UpsertWidgetCommand, User, UserPreferences, UserPreferencesService, UserService, UserState, UserValidators, UserView, Widget, authRoutes, fadeInOut, initAppData };\n//# sourceMappingURL=receipt-wrangler-receipt-wrangler-core.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}