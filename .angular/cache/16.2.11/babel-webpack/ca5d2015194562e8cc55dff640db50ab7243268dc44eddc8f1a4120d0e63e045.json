{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, ɵglobal, Injectable, Inject, NgModule } from '@angular/core';\nimport { Store, getActionTypeFromInstance, InitState, NGXS_PLUGINS } from '@ngxs/store';\nimport { catchError, tap } from 'rxjs/operators';\nconst NGXS_DEVTOOLS_OPTIONS = new InjectionToken('NGXS_DEVTOOLS_OPTIONS');\n\n/**\n * Adds support for the Redux Devtools extension:\n * http://extension.remotedev.io/\n */\nlet NgxsReduxDevtoolsPlugin = /*#__PURE__*/(() => {\n  class NgxsReduxDevtoolsPlugin {\n    constructor(_options, _injector, _ngZone) {\n      this._options = _options;\n      this._injector = _injector;\n      this._ngZone = _ngZone;\n      this.devtoolsExtension = null;\n      this.globalDevtools = ɵglobal['__REDUX_DEVTOOLS_EXTENSION__'] || ɵglobal['devToolsExtension'];\n      this.unsubscribe = null;\n      this.connect();\n    }\n    ngOnDestroy() {\n      if (this.unsubscribe !== null) {\n        this.unsubscribe();\n      }\n      if (this.globalDevtools) {\n        this.globalDevtools.disconnect();\n      }\n    }\n    /**\n     * Lazy get the store for circular dependency issues\n     */\n    get store() {\n      return this._injector.get(Store);\n    }\n    /**\n     * Middleware handle function\n     */\n    handle(state, action, next) {\n      if (!this.devtoolsExtension || this._options.disabled) {\n        return next(state, action);\n      }\n      return next(state, action).pipe(catchError(error => {\n        const newState = this.store.snapshot();\n        this.sendToDevTools(state, action, newState);\n        throw error;\n      }), tap(newState => {\n        this.sendToDevTools(state, action, newState);\n      }));\n    }\n    sendToDevTools(state, action, newState) {\n      const type = getActionTypeFromInstance(action);\n      // if init action, send initial state to dev tools\n      const isInitAction = type === InitState.type;\n      if (isInitAction) {\n        this.devtoolsExtension.init(state);\n      } else {\n        this.devtoolsExtension.send(Object.assign(Object.assign({}, action), {\n          action: null,\n          type\n        }), newState);\n      }\n    }\n    /**\n     * Handle the action from the dev tools subscription\n     */\n    dispatched(action) {\n      if (action.type === \"DISPATCH\" /* Dispatch */) {\n        if (action.payload.type === \"JUMP_TO_ACTION\" /* JumpToAction */ || action.payload.type === \"JUMP_TO_STATE\" /* JumpToState */) {\n          const prevState = JSON.parse(action.state);\n          // This makes the DevTools and Router plugins compatible with each other.\n          // We check for the existence of the `router` state and ensure it has the\n          // `trigger` property, confirming that it is our router state (coming from `@ngxs/router-plugin`).\n          // This enables a time-traveling feature, as it not only restores the state but\n          // also allows the `RouterState` to navigate back when the action is jumped.\n          if (prevState.router && prevState.router.trigger) {\n            prevState.router.trigger = 'devtools';\n          }\n          this.store.reset(prevState);\n        } else if (action.payload.type === \"TOGGLE_ACTION\" /* ToggleAction */) {\n          console.warn('Skip is not supported at this time.');\n        } else if (action.payload.type === \"IMPORT_STATE\" /* ImportState */) {\n          const {\n            actionsById,\n            computedStates,\n            currentStateIndex\n          } = action.payload.nextLiftedState;\n          this.devtoolsExtension.init(computedStates[0].state);\n          Object.keys(actionsById).filter(actionId => actionId !== '0').forEach(actionId => this.devtoolsExtension.send(actionsById[actionId], computedStates[actionId].state));\n          this.store.reset(computedStates[currentStateIndex].state);\n        }\n      } else if (action.type === \"ACTION\" /* Action */) {\n        const actionPayload = JSON.parse(action.payload);\n        this.store.dispatch(actionPayload);\n      }\n    }\n    connect() {\n      if (!this.globalDevtools || this._options.disabled) {\n        return;\n      }\n      // The `connect` method adds a `message` event listener to communicate\n      // with an extension through `window.postMessage` and handle message events.\n      // Since we only handle two specific events, we aim to avoid unnecessary change\n      // detections triggered by events that the extension sends, but we don't need to handle.\n      this.devtoolsExtension = this._ngZone.runOutsideAngular(() => this.globalDevtools.connect(this._options));\n      this.unsubscribe = this.devtoolsExtension.subscribe(action => {\n        if (action.type === \"DISPATCH\" /* Dispatch */ || action.type === \"ACTION\" /* Action */) {\n          this.dispatched(action);\n        }\n      });\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */NgxsReduxDevtoolsPlugin.ɵfac = function NgxsReduxDevtoolsPlugin_Factory(t) {\n    return new (t || NgxsReduxDevtoolsPlugin)(i0.ɵɵinject(NGXS_DEVTOOLS_OPTIONS), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i0.NgZone));\n  };\n  NgxsReduxDevtoolsPlugin.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxsReduxDevtoolsPlugin,\n    factory: NgxsReduxDevtoolsPlugin.ɵfac\n  });\n  return NgxsReduxDevtoolsPlugin;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction devtoolsOptionsFactory(options) {\n  return Object.assign({\n    name: 'NGXS'\n  }, options);\n}\nconst USER_OPTIONS = new InjectionToken('USER_OPTIONS');\nlet NgxsReduxDevtoolsPluginModule = /*#__PURE__*/(() => {\n  class NgxsReduxDevtoolsPluginModule {\n    static forRoot(options) {\n      return {\n        ngModule: NgxsReduxDevtoolsPluginModule,\n        providers: [{\n          provide: NGXS_PLUGINS,\n          useClass: NgxsReduxDevtoolsPlugin,\n          multi: true\n        }, {\n          provide: USER_OPTIONS,\n          useValue: options\n        }, {\n          provide: NGXS_DEVTOOLS_OPTIONS,\n          useFactory: devtoolsOptionsFactory,\n          deps: [USER_OPTIONS]\n        }]\n      };\n    }\n  }\n  /** @nocollapse */\n  /** @nocollapse */\n  /** @nocollapse */NgxsReduxDevtoolsPluginModule.ɵfac = function NgxsReduxDevtoolsPluginModule_Factory(t) {\n    return new (t || NgxsReduxDevtoolsPluginModule)();\n  };\n  NgxsReduxDevtoolsPluginModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxsReduxDevtoolsPluginModule\n  });\n  NgxsReduxDevtoolsPluginModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return NgxsReduxDevtoolsPluginModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * The public api for consumers of @ngxs/devtools-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NGXS_DEVTOOLS_OPTIONS, NgxsReduxDevtoolsPlugin, NgxsReduxDevtoolsPluginModule };\n//# sourceMappingURL=ngxs-devtools-plugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}