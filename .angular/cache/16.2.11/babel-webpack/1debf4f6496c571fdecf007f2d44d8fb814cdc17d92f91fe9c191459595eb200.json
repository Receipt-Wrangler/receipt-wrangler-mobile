{"ast":null,"code":"/**\n * @param items - Specific items to append to the end of an array\n */\nfunction append(items) {\n  return function appendOperator(existing) {\n    // If `items` is `undefined` or `null` or `[]` but `existing` is provided\n    // just return `existing`\n    const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\n    if (itemsNotProvidedButExistingIs) {\n      return existing;\n    }\n    if (Array.isArray(existing)) {\n      return existing.concat(items);\n    }\n    // For example if some property is added dynamically\n    // and didn't exist before thus it's not `ArrayLike`\n    return items;\n  };\n}\nfunction compose(...operators) {\n  return function composeOperator(existing) {\n    return operators.reduce((accumulator, operator) => operator(accumulator), existing);\n  };\n}\nfunction isStateOperator(value) {\n  return typeof value === 'function';\n}\nfunction isUndefined(value) {\n  return typeof value === 'undefined';\n}\nfunction isPredicate(value) {\n  return typeof value === 'function';\n}\nfunction isNumber(value) {\n  return typeof value === 'number';\n}\nfunction invalidIndex(index) {\n  return Number.isNaN(index) || index === -1;\n}\nfunction isNil(value) {\n  return value === null || isUndefined(value);\n}\nfunction retrieveValue(operatorOrValue, existing) {\n  // If state operator is a function\n  // then call it with an original value\n  if (isStateOperator(operatorOrValue)) {\n    const value = operatorOrValue(existing);\n    return value;\n  }\n  // If operator or value was not provided\n  // e.g. `elseOperatorOrValue` is `undefined`\n  // then we just return an original value\n  if (isUndefined(operatorOrValue)) {\n    return existing;\n  }\n  return operatorOrValue;\n}\n/**\n * @param condition - Condition can be a plain boolean value or a function,\n * that returns boolean, also this function can take a value as an argument\n * to which this state operator applies\n * @param trueOperatorOrValue - Any value or a state operator\n * @param elseOperatorOrValue - Any value or a state operator\n */\nfunction iif(condition, trueOperatorOrValue, elseOperatorOrValue) {\n  return function iifOperator(existing) {\n    // Convert the value to a boolean\n    let result = !!condition;\n    // but if it is a function then run it to get the result\n    if (isPredicate(condition)) {\n      result = condition(existing);\n    }\n    if (result) {\n      return retrieveValue(trueOperatorOrValue, existing);\n    }\n    return retrieveValue(elseOperatorOrValue, existing);\n  };\n}\n\n/**\n * @param value - Value to insert\n * @param [beforePosition] -  Specified index to insert value before, optional\n */\nfunction insertItem(value, beforePosition) {\n  return function insertItemOperator(existing) {\n    // Have to check explicitly for `null` and `undefined`\n    // because `value` can be `0`, thus `!value` will return `true`\n    if (isNil(value) && existing) {\n      return existing;\n    }\n    // Property may be dynamic and might not existed before\n    if (!Array.isArray(existing)) {\n      return [value];\n    }\n    const clone = existing.slice();\n    let index = 0;\n    // No need to call `isNumber`\n    // as we are checking `> 0` not `>= 0`\n    // everything except number will return false here\n    if (beforePosition > 0) {\n      index = beforePosition;\n    }\n    clone.splice(index, 0, value);\n    return clone;\n  };\n}\nfunction patch(patchObject) {\n  return function patchStateOperator(existing) {\n    let clone = null;\n    for (const k in patchObject) {\n      const newValue = patchObject[k];\n      const existingPropValue = existing === null || existing === void 0 ? void 0 : existing[k];\n      const newPropValue = isStateOperator(newValue) ? newValue(existingPropValue) : newValue;\n      if (newPropValue !== existingPropValue) {\n        if (!clone) {\n          clone = Object.assign({}, existing);\n        }\n        clone[k] = newPropValue;\n      }\n    }\n    return clone || existing;\n  };\n}\n\n/**\n * @param selector - Index of item in the array or a predicate function\n * that can be provided in `Array.prototype.findIndex`\n * @param operatorOrValue - New value under the `selector` index or a\n * function that can be applied to an existing value\n */\nfunction updateItem(selector, operatorOrValue) {\n  return function updateItemOperator(existing) {\n    let index = -1;\n    if (isPredicate(selector)) {\n      index = existing.findIndex(selector);\n    } else if (isNumber(selector)) {\n      index = selector;\n    }\n    if (invalidIndex(index)) {\n      return existing;\n    }\n    let value = null;\n    // Need to check if the new item value will change the existing item value\n    // then, only if it will change it then clone the array and set the item\n    const theOperatorOrValue = operatorOrValue;\n    if (isStateOperator(theOperatorOrValue)) {\n      value = theOperatorOrValue(existing[index]);\n    } else {\n      value = theOperatorOrValue;\n    }\n    // If the value hasn't been mutated\n    // then we just return `existing` array\n    if (value === existing[index]) {\n      return existing;\n    }\n    const clone = existing.slice();\n    clone[index] = value;\n    return clone;\n  };\n}\n\n/**\n * @param selector - index or predicate to remove an item from an array by\n */\nfunction removeItem(selector) {\n  return function removeItemOperator(existing) {\n    let index = -1;\n    if (isPredicate(selector)) {\n      index = existing.findIndex(selector);\n    } else if (isNumber(selector)) {\n      index = selector;\n    }\n    if (invalidIndex(index)) {\n      return existing;\n    }\n    const clone = existing.slice();\n    clone.splice(index, 1);\n    return clone;\n  };\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { append, compose, iif, insertItem, isPredicate, isStateOperator, patch, removeItem, updateItem };\n//# sourceMappingURL=ngxs-store-operators.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}