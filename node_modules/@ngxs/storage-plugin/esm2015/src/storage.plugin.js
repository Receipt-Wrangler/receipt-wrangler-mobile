import { PLATFORM_ID, Inject, Injectable } from '@angular/core';
import { isPlatformServer } from '@angular/common';
import { setValue, getValue, InitState, UpdateState, actionMatcher } from '@ngxs/store';
import { tap } from 'rxjs/operators';
import { DEFAULT_STATE_KEY, getStorageKey } from './internals';
import { FINAL_NGXS_STORAGE_PLUGIN_OPTIONS } from './internals/final-options';
import * as i0 from "@angular/core";
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
export class NgxsStoragePlugin {
    constructor(_options, _platformId) {
        this._options = _options;
        this._platformId = _platformId;
        this._keysWithEngines = this._options.keysWithEngines;
        // We default to `[DEFAULT_STATE_KEY]` if the user explicitly does not provide the `key` option.
        this._usesDefaultStateKey = this._keysWithEngines.length === 1 && this._keysWithEngines[0].key === DEFAULT_STATE_KEY;
    }
    handle(state, event, next) {
        var _a;
        if (isPlatformServer(this._platformId)) {
            return next(state, event);
        }
        const matches = actionMatcher(event);
        const isInitAction = matches(InitState);
        const isUpdateAction = matches(UpdateState);
        const isInitOrUpdateAction = isInitAction || isUpdateAction;
        let hasMigration = false;
        if (isInitOrUpdateAction) {
            const addedStates = isUpdateAction && event.addedStates;
            for (const { key, engine } of this._keysWithEngines) {
                // We're checking what states have been added by NGXS and if any of these states should be handled by
                // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added
                // the `user` state, the storage plugin will be rerun and will do redundant deserialization.
                // `usesDefaultStateKey` is necessary to check since `event.addedStates` never contains `@@STATE`.
                if (!this._usesDefaultStateKey && addedStates) {
                    // We support providing keys that can be deeply nested via dot notation, for instance,
                    // `keys: ['myState.myProperty']` is a valid key.
                    // The state name should always go first. The below code checks if the `key` includes dot
                    // notation and extracts the state name out of the key.
                    // Given the `key` is `myState.myProperty`, the `addedStates` will only contain `myState`.
                    const dotNotationIndex = key.indexOf(DOT);
                    const stateName = dotNotationIndex > -1 ? key.slice(0, dotNotationIndex) : key;
                    if (!addedStates.hasOwnProperty(stateName)) {
                        continue;
                    }
                }
                const storageKey = getStorageKey(key, this._options);
                let storedValue = engine.getItem(storageKey);
                if (storedValue !== 'undefined' && storedValue != null) {
                    try {
                        const newVal = this._options.deserialize(storedValue);
                        storedValue = this._options.afterDeserialize(newVal, key);
                    }
                    catch (_b) {
                        if (NG_DEV_MODE) {
                            console.error(`Error ocurred while deserializing the ${storageKey} store value, falling back to empty object, the value obtained from the store: `, storedValue);
                        }
                        storedValue = {};
                    }
                    (_a = this._options.migrations) === null || _a === void 0 ? void 0 : _a.forEach(strategy => {
                        const versionMatch = strategy.version === getValue(storedValue, strategy.versionKey || 'version');
                        const keyMatch = (!strategy.key && this._usesDefaultStateKey) || strategy.key === key;
                        if (versionMatch && keyMatch) {
                            storedValue = strategy.migrate(storedValue);
                            hasMigration = true;
                        }
                    });
                    if (!this._usesDefaultStateKey) {
                        state = setValue(state, key, storedValue);
                    }
                    else {
                        // The `UpdateState` action is dispatched whenever the feature
                        // state is added. The condition below is satisfied only when
                        // the `UpdateState` action is dispatched. Let's consider two states:
                        // `counter` and `@ngxs/router-plugin` state. When we call `NgxsModule.forRoot()`,
                        // `CounterState` is provided at the root level, while `@ngxs/router-plugin`
                        // is provided as a feature state. Beforehand, the storage plugin may have
                        // stored the value of the counter state as `10`. If `CounterState` implements
                        // the `ngxsOnInit` hook and calls `ctx.setState(999)`, the storage plugin
                        // will rehydrate the entire state when the `RouterState` is registered.
                        // Consequently, the `counter` state will revert back to `10` instead of `999`.
                        if (storedValue && addedStates && Object.keys(addedStates).length > 0) {
                            storedValue = Object.keys(addedStates).reduce((accumulator, addedState) => {
                                // The `storedValue` can be equal to the entire state when the default
                                // state key is used. However, if `addedStates` only contains the `router` value,
                                // we only want to merge the state with the `router` value.
                                // Let's assume that the `storedValue` is an object:
                                // `{ counter: 10, router: {...} }`
                                // This will pick only the `router` object from the `storedValue` and `counter`
                                // state will not be rehydrated unnecessary.
                                if (storedValue.hasOwnProperty(addedState)) {
                                    accumulator[addedState] = storedValue[addedState];
                                }
                                return accumulator;
                            }, {});
                        }
                        state = Object.assign(Object.assign({}, state), storedValue);
                    }
                }
            }
        }
        return next(state, event).pipe(tap(nextState => {
            if (isInitOrUpdateAction && !hasMigration) {
                return;
            }
            for (const { key, engine } of this._keysWithEngines) {
                let storedValue = nextState;
                const storageKey = getStorageKey(key, this._options);
                if (key !== DEFAULT_STATE_KEY) {
                    storedValue = getValue(nextState, key);
                }
                try {
                    const newStoredValue = this._options.beforeSerialize(storedValue, key);
                    engine.setItem(storageKey, this._options.serialize(newStoredValue));
                }
                catch (error) {
                    if (NG_DEV_MODE) {
                        if (error &&
                            (error.name === 'QuotaExceededError' ||
                                error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {
                            console.error(`The ${storageKey} store value exceeds the browser storage quota: `, storedValue);
                        }
                        else {
                            console.error(`Error ocurred while serializing the ${storageKey} store value, value not updated, the value obtained from the store: `, storedValue);
                        }
                    }
                }
            }
        }));
    }
}
/** @nocollapse */ NgxsStoragePlugin.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: NgxsStoragePlugin, deps: [{ token: FINAL_NGXS_STORAGE_PLUGIN_OPTIONS }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NgxsStoragePlugin.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: NgxsStoragePlugin });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: NgxsStoragePlugin, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [FINAL_NGXS_STORAGE_PLUGIN_OPTIONS]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; } });
const DOT = '.';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS5wbHVnaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wYWNrYWdlcy9zdG9yYWdlLXBsdWdpbi9zcmMvc3RvcmFnZS5wbHVnaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRW5ELE9BQU8sRUFFTCxRQUFRLEVBQ1IsUUFBUSxFQUNSLFNBQVMsRUFDVCxXQUFXLEVBQ1gsYUFBYSxFQUVkLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVyQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsYUFBYSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQy9ELE9BQU8sRUFFTCxpQ0FBaUMsRUFDbEMsTUFBTSwyQkFBMkIsQ0FBQzs7QUFJbkMsTUFBTSxXQUFXLEdBQUcsT0FBTyxTQUFTLEtBQUssV0FBVyxJQUFJLFNBQVMsQ0FBQztBQUdsRSxNQUFNLE9BQU8saUJBQWlCO0lBTTVCLFlBQ3FELFFBQXVDLEVBQzdELFdBQW1CO1FBREcsYUFBUSxHQUFSLFFBQVEsQ0FBK0I7UUFDN0QsZ0JBQVcsR0FBWCxXQUFXLENBQVE7UUFQMUMscUJBQWdCLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUM7UUFDekQsZ0dBQWdHO1FBQ3hGLHlCQUFvQixHQUMxQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLGlCQUFpQixDQUFDO0lBS3hGLENBQUM7SUFFSixNQUFNLENBQUMsS0FBVSxFQUFFLEtBQVUsRUFBRSxJQUFzQjs7UUFDbkQsSUFBSSxnQkFBZ0IsQ0FBQyxJ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c0NvbnRlbnQiOlsiaW1wb3J0IHsgUExBVEZPUk1fSUQsIEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybVNlcnZlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBQbGFpbk9iamVjdCB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XG5pbXBvcnQge1xuICBOZ3hzUGx1Z2luLFxuICBzZXRWYWx1ZSxcbiAgZ2V0VmFsdWUsXG4gIEluaXRTdGF0ZSxcbiAgVXBkYXRlU3RhdGUsXG4gIGFjdGlvbk1hdGNoZXIsXG4gIE5neHNOZXh0UGx1Z2luRm5cbn0gZnJvbSAnQG5neHMvc3RvcmUnO1xuaW1wb3J0IHsgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBERUZBVUxUX1NUQVRFX0tFWSwgZ2V0U3RvcmFnZUtleSB9IGZyb20gJy4vaW50ZXJuYWxzJztcbmltcG9ydCB7XG4gIEZpbmFsTmd4c1N0b3JhZ2VQbHVnaW5PcHRpb25zLFxuICBGSU5BTF9OR1hTX1NUT1JBR0VfUExVR0lOX09QVElPTlNcbn0gZnJvbSAnLi9pbnRlcm5hbHMvZmluYWwtb3B0aW9ucyc7XG5cbmRlY2xhcmUgY29uc3QgbmdEZXZNb2RlOiBib29sZWFuO1xuXG5jb25zdCBOR19ERVZfTU9ERSA9IHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5neHNTdG9yYWdlUGx1Z2luIGltcGxlbWVudHMgTmd4c1BsdWdpbiB7XG4gIHByaXZhdGUgX2tleXNXaXRoRW5naW5lcyA9IHRoaXMuX29wdGlvbnMua2V5c1dpdGhFbmdpbmVzO1xuICAvLyBXZSBkZWZhdWx0IHRvIGBbREVGQVVMVF9TVEFURV9LRVldYCBpZiB0aGUgdXNlciBleHBsaWNpdGx5IGRvZXMgbm90IHByb3ZpZGUgdGhlIGBrZXlgIG9wdGlvbi5cbiAgcHJpdmF0ZSBfdXNlc0RlZmF1bHRTdGF0ZUtleSA9XG4gICAgdGhpcy5fa2V5c1dpdGhFbmdpbmVzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLl9rZXlzV2l0aEVuZ2luZXNbMF0ua2V5ID09PSBERUZBVUxUX1NUQVRFX0tFWTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KEZJTkFMX05HWFNfU1RPUkFHRV9QTFVHSU5fT1BUSU9OUykgcHJpdmF0ZSBfb3B0aW9uczogRmluYWxOZ3hzU3RvcmFnZVBsdWdpbk9wdGlvbnMsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBfcGxhdGZvcm1JZDogc3RyaW5nXG4gICkge31cblxuICBoYW5kbGUoc3RhdGU6IGFueSwgZXZlbnQ6IGFueSwgbmV4dDogTmd4c05leHRQbHVnaW5Gbikge1xuICAgIGlmIChpc1BsYXRmb3JtU2VydmVyKHRoaXMuX3BsYXRmb3JtSWQpKSB7XG4gICAgICByZXR1cm4gbmV4dChzdGF0ZSwgZXZlbnQpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdGNoZXMgPSBhY3Rpb25NYXRjaGVyKGV2ZW50KTtcbiAgICBjb25zdCBpc0luaXRBY3Rpb24gPSBtYXRjaGVzKEluaXRTdGF0ZSk7XG4gICAgY29uc3QgaXNVcGRhdGVBY3Rpb24gPSBtYXRjaGVzKFVwZGF0ZVN0YXRlKTtcbiAgICBjb25zdCBpc0luaXRPclVwZGF0ZUFjdGlvbiA9IGlzSW5pdEFjdGlvbiB8fCBpc1VwZGF0ZUFjdGlvbjtcbiAgICBsZXQgaGFzTWlncmF0aW9uID0gZmFsc2U7XG5cbiAgICBpZiAoaXNJbml0T3JVcGRhdGVBY3Rpb24pIHtcbiAgICAgIGNvbnN0IGFkZGVkU3RhdGVzID0gaXNVcGRhdGVBY3Rpb24gJiYgZXZlbnQuYWRkZWRTdGF0ZXM7XG5cbiAgICAgIGZvciAoY29uc3QgeyBrZXksIGVuZ2luZSB9IG9mIHRoaXMuX2tleXNXaXRoRW5naW5lcykge1xuICAgICAgICAvLyBXZSdyZSBjaGVja2luZyB3aGF0IHN0YXRlcyBoYXZlIGJlZW4gYWRkZWQgYnkgTkdYUyBhbmQgaWYgYW55IG9mIHRoZXNlIHN0YXRlcyBzaG91bGQgYmUgaGFuZGxlZCBieVxuICAgICAgICAvLyB0aGUgc3RvcmFnZSBwbHVnaW4uIEZvciBpbnN0YW5jZSwgd2Ugb25seSB3YW50IHRvIGRlc2VyaWFsaXplIHRoZSBgYXV0aGAgc3RhdGUsIE5HWFMgaGFzIGFkZGVkXG4gICAgICAgIC8vIHRoZSBgdXNlcmAgc3RhdGUsIHRoZSBzdG9yYWdlIHBsdWdpbiB3aWxsIGJlIHJlcnVuIGFuZCB3aWxsIGRvIHJlZHVuZGFudCBkZXNlcmlhbGl6YXRpb24uXG4gICAgICAgIC8vIGB1c2VzRGVmYXVsdFN0YXRlS2V5YCBpcyBuZWNlc3NhcnkgdG8gY2hlY2sgc2luY2UgYGV2ZW50LmFkZGVkU3RhdGVzYCBuZXZlciBjb250YWlucyBgQEBTVEFURWAuXG4gICAgICAgIGlmICghdGhpcy5fdXNlc0RlZmF1bHRTdGF0ZUtleSAmJiBhZGRlZFN0YXRlcykge1xuICAgICAgICAgIC8vIFdlIHN1cHBvcnQgcHJvdmlkaW5nIGtleXMgdGhhdCBjYW4gYmUgZGVlcGx5IG5lc3RlZCB2aWEgZG90IG5vdGF0aW9uLCBmb3IgaW5zdGFuY2UsXG4gICAgICAgICAgLy8gYGtleXM6IFsnbXlTdGF0ZS5teVByb3BlcnR5J11gIGlzIGEgdmFsaWQga2V5LlxuICAgICAgICAgIC8vIFRoZSBzdGF0ZSBuYW1lIHNob3VsZCBhbHdheXMgZ28gZmlyc3QuIFRoZSBiZWxvdyBjb2RlIGNoZWNrcyBpZiB0aGUgYGtleWAgaW5jbHVkZXMgZG90XG4gICAgICAgICAgLy8gbm90YXRpb24gYW5kIGV4dHJhY3RzIHRoZSBzdGF0ZSBuYW1lIG91dCBvZiB0aGUga2V5LlxuICAgICAgICAgIC8vIEdpdmVuIHRoZSBga2V5YCBpcyBgbXlTdGF0ZS5teVByb3BlcnR5YCwgdGhlIGBhZGRlZFN0YXRlc2Agd2lsbCBvbmx5IGNvbnRhaW4gYG15U3RhdGVgLlxuICAgICAgICAgIGNvbnN0IGRvdE5vdGF0aW9uSW5kZXggPSBrZXkuaW5kZXhPZihET1QpO1xuICAgICAgICAgIGNvbnN0IHN0YXRlTmFtZSA9IGRvdE5vdGF0aW9uSW5kZXggPiAtMSA/IGtleS5zbGljZSgwLCBkb3ROb3RhdGlvbkluZGV4KSA6IGtleTtcbiAgICAgICAgICBpZiAoIWFkZGVkU3RhdGVzLmhhc093blByb3BlcnR5KHN0YXRlTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBnZXRTdG9yYWdlS2V5KGtleSwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICAgIGxldCBzdG9yZWRWYWx1ZTogYW55ID0gZW5naW5lLmdldEl0ZW0oc3RvcmFnZUtleSk7XG5cbiAgICAgICAgaWYgKHN0b3JlZFZhbHVlICE9PSAndW5kZWZpbmVkJyAmJiBzdG9yZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbCA9IHRoaXMuX29wdGlvbnMuZGVzZXJpYWxpemUhKHN0b3JlZFZhbHVlKTtcbiAgICAgICAgICAgIHN0b3JlZFZhbHVlID0gdGhpcy5fb3B0aW9ucy5hZnRlckRlc2VyaWFsaXplIShuZXdWYWwsIGtleSk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBpZiAoTkdfREVWX01PREUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBgRXJyb3Igb2N1cnJlZCB3aGlsZSBkZXNlcmlhbGl6aW5nIHRoZSAke3N0b3JhZ2VLZXl9IHN0b3JlIHZhbHVlLCBmYWxsaW5nIGJhY2sgdG8gZW1wdHkgb2JqZWN0LCB0aGUgdmFsdWUgb2J0YWluZWQgZnJvbSB0aGUgc3RvcmU6IGAsXG4gICAgICAgICAgICAgICAgc3RvcmVkVmFsdWVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JlZFZhbHVlID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fb3B0aW9ucy5taWdyYXRpb25zPy5mb3JFYWNoKHN0cmF0ZWd5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb25NYXRjaCA9XG4gICAgICAgICAgICAgIHN0cmF0ZWd5LnZlcnNpb24gPT09IGdldFZhbHVlKHN0b3JlZFZhbHVlLCBzdHJhdGVneS52ZXJzaW9uS2V5IHx8ICd2ZXJzaW9uJyk7XG4gICAgICAgICAgICBjb25zdCBrZXlNYXRjaCA9XG4gICAgICAgICAgICAgICghc3RyYXRlZ3kua2V5ICYmIHRoaXMuX3VzZXNEZWZhdWx0U3RhdGVLZXkpIHx8IHN0cmF0ZWd5LmtleSA9PT0ga2V5O1xuICAgICAgICAgICAgaWYgKHZlcnNpb25NYXRjaCAmJiBrZXlNYXRjaCkge1xuICAgICAgICAgICAgICBzdG9yZWRWYWx1ZSA9IHN0cmF0ZWd5Lm1pZ3JhdGUoc3RvcmVkVmFsdWUpO1xuICAgICAgICAgICAgICBoYXNNaWdyYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl91c2VzRGVmYXVsdFN0YXRlS2V5KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHNldFZhbHVlKHN0YXRlLCBrZXksIHN0b3JlZFZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGBVcGRhdGVTdGF0ZWAgYWN0aW9uIGlzIGRpc3BhdGNoZWQgd2hlbmV2ZXIgdGhlIGZlYXR1cmVcbiAgICAgICAgICAgIC8vIHN0YXRlIGlzIGFkZGVkLiBUaGUgY29uZGl0aW9uIGJlbG93IGlzIHNhdGlzZmllZCBvbmx5IHdoZW5cbiAgICAgICAgICAgIC8vIHRoZSBgVXBkYXRlU3RhdGVgIGFjdGlvbiBpcyBkaXNwYXRjaGVkLiBMZXQncyBjb25zaWRlciB0d28gc3RhdGVzOlxuICAgICAgICAgICAgLy8gYGNvdW50ZXJgIGFuZCBgQG5neHMvcm91dGVyLXBsdWdpbmAgc3RhdGUuIFdoZW4gd2UgY2FsbCBgTmd4c01vZHVsZS5mb3JSb290KClgLFxuICAgICAgICAgICAgLy8gYENvdW50ZXJTdGF0ZWAgaXMgcHJvdmlkZWQgYXQgdGhlIHJvb3QgbGV2ZWwsIHdoaWxlIGBAbmd4cy9yb3V0ZXItcGx1Z2luYFxuICAgICAgICAgICAgLy8gaXMgcHJvdmlkZWQgYXMgYSBmZWF0dXJlIHN0YXRlLiBCZWZvcmVoYW5kLCB0aGUgc3RvcmFnZSBwbHVnaW4gbWF5IGhhdmVcbiAgICAgICAgICAgIC8vIHN0b3JlZCB0aGUgdmFsdWUgb2YgdGhlIGNvdW50ZXIgc3RhdGUgYXMgYDEwYC4gSWYgYENvdW50ZXJTdGF0ZWAgaW1wbGVtZW50c1xuICAgICAgICAgICAgLy8gdGhlIGBuZ3hzT25Jbml0YCBob29rIGFuZCBjYWxscyBgY3R4LnNldFN0YXRlKDk5OSlgLCB0aGUgc3RvcmFnZSBwbHVnaW5cbiAgICAgICAgICAgIC8vIHdpbGwgcmVoeWRyYXRlIHRoZSBlbnRpcmUgc3RhdGUgd2hlbiB0aGUgYFJvdXRlclN0YXRlYCBpcyByZWdpc3RlcmVkLlxuICAgICAgICAgICAgLy8gQ29uc2VxdWVudGx5LCB0aGUgYGNvdW50ZXJgIHN0YXRlIHdpbGwgcmV2ZXJ0IGJhY2sgdG8gYDEwYCBpbnN0ZWFkIG9mIGA5OTlgLlxuICAgICAgICAgICAgaWYgKHN0b3JlZFZhbHVlICYmIGFkZGVkU3RhdGVzICYmIE9iamVjdC5rZXlzKGFkZGVkU3RhdGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHN0b3JlZFZhbHVlID0gT2JqZWN0LmtleXMoYWRkZWRTdGF0ZXMpLnJlZHVjZSgoYWNjdW11bGF0b3IsIGFkZGVkU3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYHN0b3JlZFZhbHVlYCBjYW4gYmUgZXF1YWwgdG8gdGhlIGVudGlyZSBzdGF0ZSB3aGVuIHRoZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gc3RhdGUga2V5IGlzIHVzZWQuIEhvd2V2ZXIsIGlmIGBhZGRlZFN0YXRlc2Agb25seSBjb250YWlucyB0aGUgYHJvdXRlcmAgdmFsdWUsXG4gICAgICAgICAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIG1lcmdlIHRoZSBzdGF0ZSB3aXRoIHRoZSBgcm91dGVyYCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBhc3N1bWUgdGhhdCB0aGUgYHN0b3JlZFZhbHVlYCBpcyBhbiBvYmplY3Q6XG4gICAgICAgICAgICAgICAgLy8gYHsgY291bnRlcjogMTAsIHJvdXRlcjogey4uLn0gfWBcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcGljayBvbmx5IHRoZSBgcm91dGVyYCBvYmplY3QgZnJvbSB0aGUgYHN0b3JlZFZhbHVlYCBhbmQgYGNvdW50ZXJgXG4gICAgICAgICAgICAgICAgLy8gc3RhdGUgd2lsbCBub3QgYmUgcmVoeWRyYXRlZCB1bm5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkVmFsdWUuaGFzT3duUHJvcGVydHkoYWRkZWRTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdG9yW2FkZGVkU3RhdGVdID0gc3RvcmVkVmFsdWVbYWRkZWRTdGF0ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgICAgICAgfSwgPFBsYWluT2JqZWN0Pnt9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGUgPSB7IC4uLnN0YXRlLCAuLi5zdG9yZWRWYWx1ZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXh0KHN0YXRlLCBldmVudCkucGlwZShcbiAgICAgIHRhcChuZXh0U3RhdGUgPT4ge1xuICAgICAgICBpZiAoaXNJbml0T3JVcGRhdGVBY3Rpb24gJiYgIWhhc01pZ3JhdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgeyBrZXksIGVuZ2luZSB9IG9mIHRoaXMuX2tleXNXaXRoRW5naW5lcykge1xuICAgICAgICAgIGxldCBzdG9yZWRWYWx1ZSA9IG5leHRTdGF0ZTtcblxuICAgICAgICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBnZXRTdG9yYWdlS2V5KGtleSwgdGhpcy5fb3B0aW9ucyk7XG5cbiAgICAgICAgICBpZiAoa2V5ICE9PSBERUZBVUxUX1NUQVRFX0tFWSkge1xuICAgICAgICAgICAgc3RvcmVkVmFsdWUgPSBnZXRWYWx1ZShuZXh0U3RhdGUsIGtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0b3JlZFZhbHVlID0gdGhpcy5fb3B0aW9ucy5iZWZvcmVTZXJpYWxpemUhKHN0b3JlZFZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgZW5naW5lLnNldEl0ZW0oc3RvcmFnZUtleSwgdGhpcy5fb3B0aW9ucy5zZXJpYWxpemUhKG5ld1N0b3JlZFZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChOR19ERVZfTU9ERSkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZXJyb3IgJiZcbiAgICAgICAgICAgICAgICAoZXJyb3IubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicgfHxcbiAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPT09ICdOU19FUlJPUl9ET01fUVVPVEFfUkVBQ0hFRCcpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBgVGhlICR7c3RvcmFnZUtleX0gc3RvcmUgdmFsdWUgZXhjZWVkcyB0aGUgYnJvd3NlciBzdG9yYWdlIHF1b3RhOiBgLFxuICAgICAgICAgICAgICAgICAgc3RvcmVkVmFsdWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBgRXJyb3Igb2N1cnJlZCB3aGlsZSBzZXJpYWxpemluZyB0aGUgJHtzdG9yYWdlS2V5fSBzdG9yZSB2YWx1ZSwgdmFsdWUgbm90IHVwZGF0ZWQsIHRoZSB2YWx1ZSBvYnRhaW5lZCBmcm9tIHRoZSBzdG9yZTogYCxcbiAgICAgICAgICAgICAgICAgIHN0b3JlZFZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5cbmNvbnN0IERPVCA9ICcuJztcbiJdfQ==