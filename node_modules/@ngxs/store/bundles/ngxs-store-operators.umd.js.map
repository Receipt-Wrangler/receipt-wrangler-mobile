{"version":3,"file":"ngxs-store-operators.umd.js","sources":["../../../packages/store/operators/src/append.ts","../../../packages/store/operators/src/compose.ts","../../../packages/store/operators/src/utils.ts","../../../packages/store/operators/src/iif.ts","../../../packages/store/operators/src/insert-item.ts","../../../packages/store/operators/src/patch.ts","../../../packages/store/operators/src/update-item.ts","../../../packages/store/operators/src/remove-item.ts","../../../packages/store/operators/src/index.ts","../../../packages/store/operators/src/ngxs-store-operators.ts"],"sourcesContent":["import { ExistingState, NoInfer, StateOperator } from './types';\n\n/**\n * @param items - Specific items to append to the end of an array\n */\nexport function append<T>(items: NoInfer<T[]>): StateOperator<T[]> {\n  return function appendOperator(existing: ExistingState<T[]>): T[] {\n    // If `items` is `undefined` or `null` or `[]` but `existing` is provided\n    // just return `existing`\n    const itemsNotProvidedButExistingIs = (!items || !items.length) && existing;\n    if (itemsNotProvidedButExistingIs) {\n      return (existing as unknown) as T[];\n    }\n\n    if (Array.isArray(existing)) {\n      return existing.concat((items as unknown) as ExistingState<T[]>);\n    }\n\n    // For example if some property is added dynamically\n    // and didn't exist before thus it's not `ArrayLike`\n    return (items as unknown) as T[];\n  };\n}\n","import { ExistingState, NoInfer, StateOperator } from './types';\n\nexport function compose<T>(...operators: NoInfer<StateOperator<T>[]>): StateOperator<T> {\n  return function composeOperator(existing: ExistingState<T>): T {\n    return operators.reduce(\n      (accumulator, operator) => operator(accumulator as ExistingState<T>),\n      existing as T\n    );\n  };\n}\n","import { StateOperator } from './types';\n\nexport type Predicate<T = any> = (value: T | Readonly<T>) => boolean;\n\nexport function isStateOperator<T>(value: T | StateOperator<T>): value is StateOperator<T> {\n  return typeof value === 'function';\n}\n\nexport function isUndefined(value: any): value is undefined {\n  return typeof value === 'undefined';\n}\n\nexport function isPredicate<T>(value: Predicate<T> | boolean | number): value is Predicate<T> {\n  return typeof value === 'function';\n}\n\nexport function isNumber(value: any): value is number {\n  return typeof value === 'number';\n}\n\nexport function invalidIndex(index: number): boolean {\n  return Number.isNaN(index) || index === -1;\n}\n\nexport function isNil<T>(value: T | null | undefined): value is null | undefined {\n  return value === null || isUndefined(value);\n}\n","import { ExistingState, NoInfer, StateOperator } from './types';\n\nimport { isStateOperator, isUndefined, isPredicate, Predicate } from './utils';\n\nfunction retrieveValue<T>(\n  operatorOrValue: StateOperator<T> | T,\n  existing: ExistingState<T>\n): T {\n  // If state operator is a function\n  // then call it with an original value\n  if (isStateOperator(operatorOrValue)) {\n    const value = operatorOrValue(existing);\n    return value as T;\n  }\n\n  // If operator or value was not provided\n  // e.g. `elseOperatorOrValue` is `undefined`\n  // then we just return an original value\n  if (isUndefined(operatorOrValue)) {\n    return existing as T;\n  }\n\n  return operatorOrValue as T;\n}\n\n/**\n * @param condition - Condition can be a plain boolean value or a function,\n * that returns boolean, also this function can take a value as an argument\n * to which this state operator applies\n * @param trueOperatorOrValue - Any value or a state operator\n * @param elseOperatorOrValue - Any value or a state operator\n */\nexport function iif<T>(\n  condition: NoInfer<Predicate<T>> | boolean,\n  trueOperatorOrValue: NoInfer<StateOperator<T> | T>,\n  elseOperatorOrValue?: NoInfer<StateOperator<T> | T>\n): StateOperator<T> {\n  return function iifOperator(existing: ExistingState<T>): T {\n    // Convert the value to a boolean\n    let result = !!condition;\n    // but if it is a function then run it to get the result\n    if (isPredicate(condition)) {\n      result = condition(existing as T);\n    }\n\n    if (result) {\n      return retrieveValue<T>(trueOperatorOrValue as StateOperator<T> | T, existing);\n    }\n\n    return retrieveValue<T>(elseOperatorOrValue! as StateOperator<T> | T, existing);\n  };\n}\n","import { ExistingState, NoInfer, StateOperator } from './types';\nimport { isNil } from './utils';\n\n/**\n * @param value - Value to insert\n * @param [beforePosition] -  Specified index to insert value before, optional\n */\nexport function insertItem<T>(value: NoInfer<T>, beforePosition?: number): StateOperator<T[]> {\n  return function insertItemOperator(existing: ExistingState<T[]>): T[] {\n    // Have to check explicitly for `null` and `undefined`\n    // because `value` can be `0`, thus `!value` will return `true`\n    if (isNil(value) && existing) {\n      return existing as T[];\n    }\n\n    // Property may be dynamic and might not existed before\n    if (!Array.isArray(existing)) {\n      return [(value as unknown) as T];\n    }\n\n    const clone = existing.slice();\n\n    let index = 0;\n\n    // No need to call `isNumber`\n    // as we are checking `> 0` not `>= 0`\n    // everything except number will return false here\n    if (beforePosition! > 0) {\n      index = beforePosition!;\n    }\n\n    clone.splice(index, 0, (value as unknown) as T);\n    return clone;\n  };\n}\n","import { ExistingState, NoInfer, StateOperator } from './types';\nimport { isStateOperator } from './utils';\n\ntype NotUndefined<T> = T extends undefined ? never : T;\n\nexport type ɵPatchSpec<T> = { [P in keyof T]?: T[P] | StateOperator<NotUndefined<T[P]>> };\n\nexport function patch<T extends Record<string, any>>(\n  patchObject: NoInfer<ɵPatchSpec<T>>\n): StateOperator<T> {\n  return function patchStateOperator(existing: ExistingState<T>): T {\n    let clone = null;\n    for (const k in patchObject) {\n      const newValue = patchObject[k];\n      const existingPropValue = existing?.[k];\n      const newPropValue = isStateOperator(newValue)\n        ? newValue(<any>existingPropValue)\n        : newValue;\n      if (newPropValue !== existingPropValue) {\n        if (!clone) {\n          clone = { ...(<any>existing) };\n        }\n        clone[k] = newPropValue;\n      }\n    }\n    return clone || existing;\n  };\n}\n","import { ExistingState, NoInfer, StateOperator } from './types';\n\nimport { isStateOperator, isPredicate, isNumber, invalidIndex, Predicate } from './utils';\n\n/**\n * @param selector - Index of item in the array or a predicate function\n * that can be provided in `Array.prototype.findIndex`\n * @param operatorOrValue - New value under the `selector` index or a\n * function that can be applied to an existing value\n */\nexport function updateItem<T>(\n  selector: number | NoInfer<Predicate<T>>,\n  operatorOrValue: NoInfer<T> | NoInfer<StateOperator<T>>\n): StateOperator<T[]> {\n  return function updateItemOperator(existing: ExistingState<T[]>): T[] {\n    let index = -1;\n\n    if (isPredicate(selector)) {\n      index = existing.findIndex(selector as Predicate<T>);\n    } else if (isNumber(selector)) {\n      index = selector;\n    }\n\n    if (invalidIndex(index)) {\n      return existing as T[];\n    }\n\n    let value: T = null!;\n    // Need to check if the new item value will change the existing item value\n    // then, only if it will change it then clone the array and set the item\n    const theOperatorOrValue = operatorOrValue as T | StateOperator<T>;\n    if (isStateOperator(theOperatorOrValue)) {\n      value = theOperatorOrValue(existing[index] as ExistingState<T>);\n    } else {\n      value = theOperatorOrValue;\n    }\n\n    // If the value hasn't been mutated\n    // then we just return `existing` array\n    if (value === existing[index]) {\n      return existing as T[];\n    }\n\n    const clone = existing.slice();\n    clone[index] = value as T;\n    return clone;\n  };\n}\n","import { ExistingState, NoInfer, StateOperator } from './types';\nimport { isPredicate, isNumber, invalidIndex, Predicate } from './utils';\n\n/**\n * @param selector - index or predicate to remove an item from an array by\n */\nexport function removeItem<T>(selector: number | NoInfer<Predicate<T>>): StateOperator<T[]> {\n  return function removeItemOperator(existing: ExistingState<T[]>): T[] {\n    let index = -1;\n\n    if (isPredicate(selector)) {\n      index = existing.findIndex(selector);\n    } else if (isNumber(selector)) {\n      index = selector;\n    }\n\n    if (invalidIndex(index)) {\n      return existing as T[];\n    }\n\n    const clone = existing.slice();\n    clone.splice(index, 1);\n    return clone;\n  };\n}\n","/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\nexport { append } from './append';\nexport { compose } from './compose';\nexport { iif } from './iif';\nexport { insertItem } from './insert-item';\nexport { patch, ɵPatchSpec } from './patch';\nexport { isStateOperator, isPredicate, Predicate } from './utils';\nexport { updateItem } from './update-item';\nexport { removeItem } from './remove-item';\nexport { ExistingState, NoInfer, StateOperator } from './types';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}