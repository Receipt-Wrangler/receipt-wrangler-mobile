(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@ngxs/store/internals'), require('@angular/common'), require('rxjs'), require('rxjs/operators'), require('@ngxs/store/operators')) :
  typeof define === 'function' && define.amd ? define('@ngxs/store', ['exports', '@angular/core', '@ngxs/store/internals', '@angular/common', 'rxjs', 'rxjs/operators', '@ngxs/store/operators'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ngxs = global.ngxs || {}, global.ngxs.store = {}), global.ng.core, global.ngxs.store.internals, global.ng.common, global.rxjs, global.rxjs.operators, global.ngxs.store.operators));
})(this, (function (exports, i0, i5, common, rxjs, operators, operators$1) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
  var i5__namespace = /*#__PURE__*/_interopNamespace(i5);

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise, SuppressedError, Symbol */
  var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b)
              if (Object.prototype.hasOwnProperty.call(b, p))
                  d[p] = b[p]; };
      return extendStatics(d, b);
  };
  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function () {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s)
                  if (Object.prototype.hasOwnProperty.call(s, p))
                      t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  function __rest(s, e) {
      var t = {};
      for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
          }
      return t;
  }
  function __decorate(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
      else
          for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                  r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
      return function (target, key) { decorator(target, key, paramIndex); };
  }
  function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) { if (f !== void 0 && typeof f !== "function")
          throw new TypeError("Function expected"); return f; }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
          var context = {};
          for (var p in contextIn)
              context[p] = p === "access" ? {} : contextIn[p];
          for (var p in contextIn.access)
              context.access[p] = contextIn.access[p];
          context.addInitializer = function (f) { if (done)
              throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
          var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
              if (result === void 0)
                  continue;
              if (result === null || typeof result !== "object")
                  throw new TypeError("Object expected");
              if (_ = accept(result.get))
                  descriptor.get = _;
              if (_ = accept(result.set))
                  descriptor.set = _;
              if (_ = accept(result.init))
                  initializers.unshift(_);
          }
          else if (_ = accept(result)) {
              if (kind === "field")
                  initializers.unshift(_);
              else
                  descriptor[key] = _;
          }
      }
      if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
  }
  ;
  function __runInitializers(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
          value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : void 0;
  }
  ;
  function __propKey(x) {
      return typeof x === "symbol" ? x : "".concat(x);
  }
  ;
  function __setFunctionName(f, name, prefix) {
      if (typeof name === "symbol")
          name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
  }
  ;
  function __metadata(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try {
              step(generator.next(value));
          }
          catch (e) {
              reject(e);
          } }
          function rejected(value) { try {
              step(generator["throw"](value));
          }
          catch (e) {
              reject(e);
          } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }
  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function () { if (t[0] & 1)
              throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f)
              throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _)
              try {
                  if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                      return t;
                  if (y = 0, t)
                      op = [op[0] & 2, t.value];
                  switch (op[0]) {
                      case 0:
                      case 1:
                          t = op;
                          break;
                      case 4:
                          _.label++;
                          return { value: op[1], done: false };
                      case 5:
                          _.label++;
                          y = op[1];
                          op = [0];
                          continue;
                      case 7:
                          op = _.ops.pop();
                          _.trys.pop();
                          continue;
                      default:
                          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                              _ = 0;
                              continue;
                          }
                          if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                              _.label = op[1];
                              break;
                          }
                          if (op[0] === 6 && _.label < t[1]) {
                              _.label = t[1];
                              t = op;
                              break;
                          }
                          if (t && _.label < t[2]) {
                              _.label = t[2];
                              _.ops.push(op);
                              break;
                          }
                          if (t[2])
                              _.ops.pop();
                          _.trys.pop();
                          continue;
                  }
                  op = body.call(thisArg, _);
              }
              catch (e) {
                  op = [6, e];
                  y = 0;
              }
              finally {
                  f = t = 0;
              }
          if (op[0] & 5)
              throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
      }
  }
  var __createBinding = Object.create ? (function (o, m, k, k2) {
      if (k2 === undefined)
          k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function () { return m[k]; } };
      }
      Object.defineProperty(o, k2, desc);
  }) : (function (o, m, k, k2) {
      if (k2 === undefined)
          k2 = k;
      o[k2] = m[k];
  });
  function __exportStar(m, o) {
      for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding(o, m, p);
  }
  function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
          return m.call(o);
      if (o && typeof o.length === "number")
          return {
              next: function () {
                  if (o && i >= o.length)
                      o = void 0;
                  return { value: o && o[i++], done: !o };
              }
          };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
          return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
      }
      catch (error) {
          e = { error: error };
      }
      finally {
          try {
              if (r && !r.done && (m = i["return"]))
                  m.call(i);
          }
          finally {
              if (e)
                  throw e.error;
          }
      }
      return ar;
  }
  /** @deprecated */
  function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
      return ar;
  }
  /** @deprecated */
  function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
      return r;
  }
  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                  if (!ar)
                      ar = Array.prototype.slice.call(from, 0, i);
                  ar[i] = from[i];
              }
          }
      return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
      function verb(n) { if (g[n])
          i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
      function resume(n, v) { try {
          step(g[n](v));
      }
      catch (e) {
          settle(q[0][3], e);
      } }
      function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
      function fulfill(value) { resume("next", value); }
      function reject(value) { resume("throw", value); }
      function settle(f, v) { if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]); }
  }
  function __asyncDelegator(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
      function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
  }
  function __asyncValues(o) {
      if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
      function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
      function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
  }
  function __makeTemplateObject(cooked, raw) {
      if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
      }
      else {
          cooked.raw = raw;
      }
      return cooked;
  }
  ;
  var __setModuleDefault = Object.create ? (function (o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function (o, v) {
      o["default"] = v;
  };
  function __importStar(mod) {
      if (mod && mod.__esModule)
          return mod;
      var result = {};
      if (mod != null)
          for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                  __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  }
  function __importDefault(mod) {
      return (mod && mod.__esModule) ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, state, kind, f) {
      if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
      if (kind === "m")
          throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
  }
  function __classPrivateFieldIn(state, receiver) {
      if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function"))
          throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
  }
  function __addDisposableResource(env, value, async) {
      if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
              throw new TypeError("Object expected.");
          var dispose;
          if (async) {
              if (!Symbol.asyncDispose)
                  throw new TypeError("Symbol.asyncDispose is not defined.");
              dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
              if (!Symbol.dispose)
                  throw new TypeError("Symbol.dispose is not defined.");
              dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
              throw new TypeError("Object not disposable.");
          env.stack.push({ value: value, dispose: dispose, async: async });
      }
      else if (async) {
          env.stack.push({ async: true });
      }
      return value;
  }
  var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };
  function __disposeResources(env) {
      function fail(e) {
          env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
          env.hasError = true;
      }
      function next() {
          while (env.stack.length) {
              var rec = env.stack.pop();
              try {
                  var result = rec.dispose && rec.dispose.call(rec.value);
                  if (rec.async)
                      return Promise.resolve(result).then(next, function (e) { fail(e); return next(); });
              }
              catch (e) {
                  fail(e);
              }
          }
          if (env.hasError)
              throw env.error;
      }
      return next();
  }
  var tslib_es6 = {
      __extends: __extends,
      __assign: __assign,
      __rest: __rest,
      __decorate: __decorate,
      __param: __param,
      __metadata: __metadata,
      __awaiter: __awaiter,
      __generator: __generator,
      __createBinding: __createBinding,
      __exportStar: __exportStar,
      __values: __values,
      __read: __read,
      __spread: __spread,
      __spreadArrays: __spreadArrays,
      __spreadArray: __spreadArray,
      __await: __await,
      __asyncGenerator: __asyncGenerator,
      __asyncDelegator: __asyncDelegator,
      __asyncValues: __asyncValues,
      __makeTemplateObject: __makeTemplateObject,
      __importStar: __importStar,
      __importDefault: __importDefault,
      __classPrivateFieldGet: __classPrivateFieldGet,
      __classPrivateFieldSet: __classPrivateFieldSet,
      __classPrivateFieldIn: __classPrivateFieldIn,
      __addDisposableResource: __addDisposableResource,
      __disposeResources: __disposeResources,
  };

  /**
   * Returns the type from an action instance/class.
   * @ignore
   */
  function getActionTypeFromInstance(action) {
      if (action.constructor && action.constructor.type) {
          return action.constructor.type;
      }
      else {
          return action.type;
      }
  }
  /**
   * Matches a action
   * @ignore
   */
  function actionMatcher(action1) {
      var type1 = getActionTypeFromInstance(action1);
      return function (action2) {
          return type1 === getActionTypeFromInstance(action2);
      };
  }
  /**
   * Set a deeply nested value. Example:
   *
   *   setValue({ foo: { bar: { eat: false } } },
   *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }
   *
   * While it traverses it also creates new objects from top down.
   *
   * @ignore
   */
  var setValue = function (obj, prop, val) {
      obj = Object.assign({}, obj);
      var split = prop.split('.');
      var lastIndex = split.length - 1;
      split.reduce(function (acc, part, index) {
          if (index === lastIndex) {
              acc[part] = val;
          }
          else {
              acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);
          }
          return acc && acc[part];
      }, obj);
      return obj;
  };
  /**
   * Get a deeply nested value. Example:
   *
   *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
   *
   * @ignore
   */
  var getValue = function (obj, prop) { return prop.split('.').reduce(function (acc, part) { return acc && acc[part]; }, obj); };
  /**
   * Simple object check.
   *
   *    isObject({a:1}) //=> true
   *    isObject(1) //=> false
   *
   * @ignore
   */
  var isObject$1 = function (item) {
      return item && typeof item === 'object' && !Array.isArray(item);
  };
  /**
   * Deep merge two objects.
   *
   *    mergeDeep({a:1, b:{x: 1, y:2}}, {b:{x: 3}, c:4}) //=> {a:1, b:{x:3, y:2}, c:4}
   *
   * @param base base object onto which `sources` will be applied
   */
  var mergeDeep = function (base) {
      var _a, _b;
      var sources = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          sources[_i - 1] = arguments[_i];
      }
      if (!sources.length)
          return base;
      var source = sources.shift();
      if (isObject$1(base) && isObject$1(source)) {
          for (var key in source) {
              if (isObject$1(source[key])) {
                  if (!base[key])
                      Object.assign(base, (_a = {}, _a[key] = {}, _a));
                  mergeDeep(base[key], source[key]);
              }
              else {
                  Object.assign(base, (_b = {}, _b[key] = source[key], _b));
              }
          }
      }
      return mergeDeep.apply(void 0, __spreadArray([base], __read(sources)));
  };

  function throwStateNameError(name) {
      throw new Error(name + " is not a valid state name. It needs to be a valid object property name.");
  }
  function throwStateNamePropertyError() {
      throw new Error("States must register a 'name' property.");
  }
  function throwStateUniqueError(current, newName, oldName) {
      throw new Error("State name '" + current + "' from " + newName + " already exists in " + oldName + ".");
  }
  function throwStateDecoratorError(name) {
      throw new Error("States must be decorated with @State() decorator, but \"" + name + "\" isn't.");
  }
  function throwActionDecoratorError() {
      throw new Error('@Action() decorator cannot be used with static methods.');
  }
  function throwSelectorDecoratorError() {
      throw new Error('Selectors only work on methods.');
  }
  function getZoneWarningMessage() {
      return ('Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\n' +
          'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\n' +
          'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })');
  }
  function getUndecoratedStateInIvyWarningMessage(name) {
      return "'" + name + "' class should be decorated with @Injectable() right after the @State() decorator";
  }
  function throwSelectFactoryNotConnectedError() {
      throw new Error('You have forgotten to import the NGXS module!');
  }
  function throwPatchingArrayError() {
      throw new Error('Patching arrays is not supported.');
  }
  function throwPatchingPrimitiveError() {
      throw new Error('Patching primitives is not supported.');
  }

  var DispatchOutsideZoneNgxsExecutionStrategy = /** @class */ (function () {
      function DispatchOutsideZoneNgxsExecutionStrategy(_ngZone, _platformId) {
          this._ngZone = _ngZone;
          this._platformId = _platformId;
          // Caretaker note: we have still left the `typeof` condition in order to avoid
          // creating a breaking change for projects that still use the View Engine.
          if (typeof ngDevMode === 'undefined' || ngDevMode) {
              verifyZoneIsNotNooped(_ngZone);
          }
      }
      DispatchOutsideZoneNgxsExecutionStrategy.prototype.enter = function (func) {
          if (common.isPlatformServer(this._platformId)) {
              return this.runInsideAngular(func);
          }
          return this.runOutsideAngular(func);
      };
      DispatchOutsideZoneNgxsExecutionStrategy.prototype.leave = function (func) {
          return this.runInsideAngular(func);
      };
      DispatchOutsideZoneNgxsExecutionStrategy.prototype.runInsideAngular = function (func) {
          if (i0.NgZone.isInAngularZone()) {
              return func();
          }
          return this._ngZone.run(func);
      };
      DispatchOutsideZoneNgxsExecutionStrategy.prototype.runOutsideAngular = function (func) {
          if (i0.NgZone.isInAngularZone()) {
              return this._ngZone.runOutsideAngular(func);
          }
          return func();
      };
      return DispatchOutsideZoneNgxsExecutionStrategy;
  }());
  /** @nocollapse */ DispatchOutsideZoneNgxsExecutionStrategy.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: DispatchOutsideZoneNgxsExecutionStrategy, deps: [{ token: i0__namespace.NgZone }, { token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ DispatchOutsideZoneNgxsExecutionStrategy.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: DispatchOutsideZoneNgxsExecutionStrategy, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: DispatchOutsideZoneNgxsExecutionStrategy, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () {
          return [{ type: i0__namespace.NgZone }, { type: undefined, decorators: [{
                          type: i0.Inject,
                          args: [i0.PLATFORM_ID]
                      }] }];
      } });
  // Caretaker note: this should exist as a separate function and not a class method,
  // since class methods are not tree-shakable.
  function verifyZoneIsNotNooped(ngZone) {
      // `NoopNgZone` is not exposed publicly as it doesn't expect
      // to be used outside of the core Angular code, thus we just have
      // to check if the zone doesn't extend or instanceof `NgZone`.
      if (ngZone instanceof i0.NgZone) {
          return;
      }
      console.warn(getZoneWarningMessage());
  }

  var ROOT_OPTIONS = new i0.InjectionToken('ROOT_OPTIONS');
  var ROOT_STATE_TOKEN = new i0.InjectionToken('ROOT_STATE_TOKEN');
  var FEATURE_STATE_TOKEN = new i0.InjectionToken('FEATURE_STATE_TOKEN');
  var NGXS_PLUGINS = new i0.InjectionToken('NGXS_PLUGINS');
  var META_KEY = 'NGXS_META';
  var META_OPTIONS_KEY = 'NGXS_OPTIONS_META';
  var SELECTOR_META_KEY = 'NGXS_SELECTOR_META';
  /**
   * The NGXS config settings.
   */
  var NgxsConfig = /** @class */ (function () {
      function NgxsConfig() {
          /**
           * Defining the default state before module initialization
           * This is convenient if we need to create a define our own set of states.
           * @deprecated will be removed after v4
           * (default: {})
           */
          this.defaultsState = {};
          /**
           * Defining shared selector options
           */
          this.selectorOptions = {
              injectContainerState: true,
              suppressErrors: true // TODO: default is true in v3, will change in v4
          };
          this.compatibility = {
              strictContentSecurityPolicy: false
          };
          this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;
      }
      return NgxsConfig;
  }());
  /** @nocollapse */ NgxsConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ NgxsConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsConfig, providedIn: 'root', useFactory: function (options) { return mergeDeep(new NgxsConfig(), options); }, deps: [{ token: ROOT_OPTIONS }] });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsConfig, decorators: [{
              type: i0.Injectable,
              args: [{
                      providedIn: 'root',
                      useFactory: function (options) { return mergeDeep(new NgxsConfig(), options); },
                      deps: [ROOT_OPTIONS]
                  }]
          }], ctorParameters: function () { return []; } });
  /**
   * Represents a basic change from a previous to a new value for a single state instance.
   * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.
   */
  var NgxsSimpleChange = /** @class */ (function () {
      function NgxsSimpleChange(previousValue, currentValue, firstChange) {
          this.previousValue = previousValue;
          this.currentValue = currentValue;
          this.firstChange = firstChange;
      }
      return NgxsSimpleChange;
  }());

  var NoopNgxsExecutionStrategy = /** @class */ (function () {
      function NoopNgxsExecutionStrategy() {
      }
      NoopNgxsExecutionStrategy.prototype.enter = function (func) {
          return func();
      };
      NoopNgxsExecutionStrategy.prototype.leave = function (func) {
          return func();
      };
      return NoopNgxsExecutionStrategy;
  }());
  /** @nocollapse */ NoopNgxsExecutionStrategy.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NoopNgxsExecutionStrategy, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ NoopNgxsExecutionStrategy.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NoopNgxsExecutionStrategy, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NoopNgxsExecutionStrategy, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }] });

  /**
   * The strategy that might be provided by users through `options.executionStrategy`.
   */
  var USER_PROVIDED_NGXS_EXECUTION_STRATEGY = new i0.InjectionToken('USER_PROVIDED_NGXS_EXECUTION_STRATEGY');
  /*
   * Internal execution strategy injection token
   */
  var NGXS_EXECUTION_STRATEGY = new i0.InjectionToken('NGXS_EXECUTION_STRATEGY', {
      providedIn: 'root',
      factory: function () {
          var injector = i0.inject(i0.INJECTOR);
          var executionStrategy = injector.get(USER_PROVIDED_NGXS_EXECUTION_STRATEGY);
          return executionStrategy
              ? injector.get(executionStrategy)
              : injector.get(typeof i0["ɵglobal"].Zone !== 'undefined'
                  ? DispatchOutsideZoneNgxsExecutionStrategy
                  : NoopNgxsExecutionStrategy);
      }
  });

  /**
   * Ensures metadata is attached to the class and returns it.
   *
   * @ignore
   */
  function ensureStoreMetadata$1(target) {
      if (!target.hasOwnProperty(META_KEY)) {
          var defaultMetadata_1 = {
              name: null,
              actions: {},
              defaults: {},
              path: null,
              makeRootSelector: function (context) {
                  return context.getStateGetter(defaultMetadata_1.name);
              },
              children: []
          };
          Object.defineProperty(target, META_KEY, { value: defaultMetadata_1 });
      }
      return getStoreMetadata$1(target);
  }
  /**
   * Get the metadata attached to the state class if it exists.
   *
   * @ignore
   */
  function getStoreMetadata$1(target) {
      return target[META_KEY];
  }
  /**
   * Ensures metadata is attached to the selector and returns it.
   *
   * @ignore
   */
  function ensureSelectorMetadata$1(target) {
      if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
          var defaultMetadata = {
              makeRootSelector: null,
              originalFn: null,
              containerClass: null,
              selectorName: null,
              getSelectorOptions: function () { return ({}); }
          };
          Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
      }
      return getSelectorMetadata$1(target);
  }
  /**
   * Get the metadata attached to the selector if it exists.
   *
   * @ignore
   */
  function getSelectorMetadata$1(target) {
      return target[SELECTOR_META_KEY];
  }
  /**
   * Get a deeply nested value. Example:
   *
   *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
   *
   * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
   * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
   *
   * @ignore
   */
  function compliantPropGetter(paths) {
      var copyOfPaths = paths.slice();
      return function (obj) { return copyOfPaths.reduce(function (acc, part) { return acc && acc[part]; }, obj); };
  }
  /**
   * The generated function is faster than:
   * - pluck (Observable operator)
   * - memoize
   *
   * @ignore
   */
  function fastPropGetter(paths) {
      var segments = paths;
      var seg = 'store.' + segments[0];
      var i = 0;
      var l = segments.length;
      var expr = seg;
      while (++i < l) {
          expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
      }
      var fn = new Function('store', 'return ' + expr + ';');
      return fn;
  }
  /**
   * Get a deeply nested value. Example:
   *
   *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
   *
   * @ignore
   */
  function propGetter(paths, config) {
      if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
          return compliantPropGetter(paths);
      }
      else {
          return fastPropGetter(paths);
      }
  }
  /**
   * Given an array of states, it will return a object graph. Example:
   *    const states = [
   *      Cart,
   *      CartSaved,
   *      CartSavedItems
   *    ]
   *
   * would return:
   *
   *  const graph = {
   *    cart: ['saved'],
   *    saved: ['items'],
   *    items: []
   *  };
   *
   * @ignore
   */
  function buildGraph(stateClasses) {
      var findName = function (stateClass) {
          var meta = stateClasses.find(function (g) { return g === stateClass; });
          // Caretaker note: we have still left the `typeof` condition in order to avoid
          // creating a breaking change for projects that still use the View Engine.
          if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {
              throw new Error("Child state not found: " + stateClass + ". \r\nYou may have forgotten to add states to module");
          }
          return meta[META_KEY].name;
      };
      return stateClasses.reduce(function (result, stateClass) {
          var _a = stateClass[META_KEY], name = _a.name, children = _a.children;
          result[name] = (children || []).map(findName);
          return result;
      }, {});
  }
  /**
   * Given a states array, returns object graph
   * returning the name and state metadata. Example:
   *
   *  const graph = {
   *    cart: { metadata }
   *  };
   *
   * @ignore
   */
  function nameToState(states) {
      return states.reduce(function (result, stateClass) {
          var meta = stateClass[META_KEY];
          result[meta.name] = stateClass;
          return result;
      }, {});
  }
  /**
   * Given a object relationship graph will return the full path
   * for the child items. Example:
   *
   *  const graph = {
   *    cart: ['saved'],
   *    saved: ['items'],
   *    items: []
   *  };
   *
   * would return:
   *
   *  const r = {
   *    cart: 'cart',
   *    saved: 'cart.saved',
   *    items: 'cart.saved.items'
   *  };
   *
   * @ignore
   */
  function findFullParentPath(obj, newObj) {
      if (newObj === void 0) { newObj = {}; }
      var visit = function (child, keyToFind) {
          for (var key in child) {
              if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                  var parent = visit(child, key);
                  return parent !== null ? parent + "." + key : key;
              }
          }
          return null;
      };
      for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
              var parent = visit(obj, key);
              newObj[key] = parent ? parent + "." + key : key;
          }
      }
      return newObj;
  }
  /**
   * Given a object graph, it will return the items topologically sorted Example:
   *
   *  const graph = {
   *    cart: ['saved'],
   *    saved: ['items'],
   *    items: []
   *  };
   *
   * would return:
   *
   *  const results = [
   *    'items',
   *    'saved',
   *    'cart'
   *  ];
   *
   * @ignore
   */
  function topologicalSort(graph) {
      var sorted = [];
      var visited = {};
      var visit = function (name, ancestors) {
          if (ancestors === void 0) { ancestors = []; }
          if (!Array.isArray(ancestors)) {
              ancestors = [];
          }
          ancestors.push(name);
          visited[name] = true;
          graph[name].forEach(function (dep) {
              // Caretaker note: we have still left the `typeof` condition in order to avoid
              // creating a breaking change for projects that still use the View Engine.
              if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {
                  throw new Error("Circular dependency '" + dep + "' is required by '" + name + "': " + ancestors.join(' -> '));
              }
              if (visited[dep]) {
                  return;
              }
              visit(dep, ancestors.slice(0));
          });
          if (sorted.indexOf(name) < 0) {
              sorted.push(name);
          }
      };
      Object.keys(graph).forEach(function (k) { return visit(k); });
      return sorted.reverse();
  }
  /**
   * Returns if the parameter is a object or not.
   *
   * @ignore
   */
  function isObject(obj) {
      return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
  }

  /**
   * RxJS operator for selecting out specific actions.
   *
   * This will grab actions that have just been dispatched as well as actions that have completed
   */
  function ofAction() {
      var allowedTypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          allowedTypes[_i] = arguments[_i];
      }
      return ofActionOperator(allowedTypes);
  }
  /**
   * RxJS operator for selecting out specific actions.
   *
   * This will ONLY grab actions that have just been dispatched
   */
  function ofActionDispatched() {
      var allowedTypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          allowedTypes[_i] = arguments[_i];
      }
      return ofActionOperator(allowedTypes, ["DISPATCHED" /* Dispatched */]);
  }
  /**
   * RxJS operator for selecting out specific actions.
   *
   * This will ONLY grab actions that have just been successfully completed
   */
  function ofActionSuccessful() {
      var allowedTypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          allowedTypes[_i] = arguments[_i];
      }
      return ofActionOperator(allowedTypes, ["SUCCESSFUL" /* Successful */]);
  }
  /**
   * RxJS operator for selecting out specific actions.
   *
   * This will ONLY grab actions that have just been canceled
   */
  function ofActionCanceled() {
      var allowedTypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          allowedTypes[_i] = arguments[_i];
      }
      return ofActionOperator(allowedTypes, ["CANCELED" /* Canceled */]);
  }
  /**
   * RxJS operator for selecting out specific actions.
   *
   * This will ONLY grab actions that have just been completed
   */
  function ofActionCompleted() {
      var allowedTypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          allowedTypes[_i] = arguments[_i];
      }
      var allowedStatuses = [
          "SUCCESSFUL" /* Successful */,
          "CANCELED" /* Canceled */,
          "ERRORED" /* Errored */
      ];
      return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);
  }
  /**
   * RxJS operator for selecting out specific actions.
   *
   * This will ONLY grab actions that have just thrown an error
   */
  function ofActionErrored() {
      var allowedTypes = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          allowedTypes[_i] = arguments[_i];
      }
      return ofActionOperator(allowedTypes, ["ERRORED" /* Errored */]);
  }
  function ofActionOperator(allowedTypes, statuses, 
  // This actually could've been `OperatorFunction<ActionContext, ActionCompletion | any>`,
  // since it maps either to `ctx.action` OR to `ActionCompletion`. But `ActionCompleteion | any`
  // defaults to `any`, thus there is no sense from union type.
  mapOperator) {
      if (mapOperator === void 0) { mapOperator = mapAction; }
      var allowedMap = createAllowedActionTypesMap(allowedTypes);
      var allowedStatusMap = statuses && createAllowedStatusesMap(statuses);
      return function (o) {
          return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());
      };
  }
  function filterStatus(allowedTypes, allowedStatuses) {
      return operators.filter(function (ctx) {
          var actionType = getActionTypeFromInstance(ctx.action);
          var typeMatch = allowedTypes[actionType];
          var statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;
          return typeMatch && statusMatch;
      });
  }
  function mapActionResult() {
      return operators.map(function (_a) {
          var action = _a.action, status = _a.status, error = _a.error;
          return {
              action: action,
              result: {
                  successful: "SUCCESSFUL" /* Successful */ === status,
                  canceled: "CANCELED" /* Canceled */ === status,
                  error: error
              }
          };
      });
  }
  function mapAction() {
      return operators.map(function (ctx) { return ctx.action; });
  }
  function createAllowedActionTypesMap(types) {
      return types.reduce(function (filterMap, klass) {
          filterMap[getActionTypeFromInstance(klass)] = true;
          return filterMap;
      }, {});
  }
  function createAllowedStatusesMap(statuses) {
      return statuses.reduce(function (filterMap, status) {
          filterMap[status] = true;
          return filterMap;
      }, {});
  }

  var stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');
  function ensureStateNameIsValid(name) {
      if (!name) {
          throwStateNamePropertyError();
      }
      else if (!stateNameRegex.test(name)) {
          throwStateNameError(name);
      }
  }
  function ensureStateNameIsUnique(stateName, state, statesByName) {
      var existingState = statesByName[stateName];
      if (existingState && existingState !== state) {
          throwStateUniqueError(stateName, state.name, existingState.name);
      }
  }
  function ensureStatesAreDecorated(stateClasses) {
      stateClasses.forEach(function (stateClass) {
          if (!getStoreMetadata$1(stateClass)) {
              throwStateDecoratorError(stateClass.name);
          }
      });
  }

  /**
   * All provided or injected tokens must have `@Injectable` decorator
   * (previously, injected tokens without `@Injectable` were allowed
   * if another decorator was used, e.g. pipes).
   */
  function ensureStateClassIsInjectable(stateClass) {
      if (jit_hasInjectableAnnotation(stateClass) || aot_hasNgInjectableDef(stateClass)) {
          return;
      }
      console.warn(getUndecoratedStateInIvyWarningMessage(stateClass.name));
  }
  function aot_hasNgInjectableDef(stateClass) {
      // `ɵprov` is a static property added by the NGCC compiler. It always exists in
      // AOT mode because this property is added before runtime. If an application is running in
      // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`
      // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.
      return !!stateClass.ɵprov;
  }
  function jit_hasInjectableAnnotation(stateClass) {
      // `ɵprov` doesn't exist in JIT mode (for instance when running unit tests with Jest).
      var annotations = stateClass.__annotations__ || [];
      return annotations.some(function (annotation) { return (annotation === null || annotation === void 0 ? void 0 : annotation.ngMetadataName) === 'Injectable'; });
  }

  /**
   * Init action
   */
  var InitState = /** @class */ (function () {
      function InitState() {
      }
      return InitState;
  }());
  InitState.type = '@@INIT';
  /**
   * Update action
   */
  var UpdateState = /** @class */ (function () {
      function UpdateState(addedStates) {
          this.addedStates = addedStates;
      }
      return UpdateState;
  }());
  UpdateState.type = '@@UPDATE_STATE';

  var NGXS_DEVELOPMENT_OPTIONS = new i0.InjectionToken('NGXS_DEVELOPMENT_OPTIONS', {
      providedIn: 'root',
      factory: function () { return ({ warnOnUnhandledActions: true }); }
  });

  var NgxsUnhandledActionsLogger = /** @class */ (function () {
      function NgxsUnhandledActionsLogger(options) {
          /**
           * These actions should be ignored by default; the user can increase this
           * list in the future via the `ignoreActions` method.
           */
          this._ignoredActions = new Set([InitState.type, UpdateState.type]);
          if (typeof options.warnOnUnhandledActions === 'object') {
              this.ignoreActions.apply(this, __spreadArray([], __read(options.warnOnUnhandledActions.ignore)));
          }
      }
      /**
       * Adds actions to the internal list of actions that should be ignored.
       */
      NgxsUnhandledActionsLogger.prototype.ignoreActions = function () {
          var e_1, _a;
          var actions = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              actions[_i] = arguments[_i];
          }
          try {
              for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                  var action = actions_1_1.value;
                  this._ignoredActions.add(action.type);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      /** @internal */
      NgxsUnhandledActionsLogger.prototype.warn = function (action) {
          var actionShouldBeIgnored = Array.from(this._ignoredActions).some(function (type) { return type === getActionTypeFromInstance(action); });
          if (actionShouldBeIgnored) {
              return;
          }
          action =
              action.constructor && action.constructor.name !== 'Object'
                  ? action.constructor.name
                  : action.type;
          console.warn("The " + action + " action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.");
      };
      return NgxsUnhandledActionsLogger;
  }());
  /** @nocollapse */ NgxsUnhandledActionsLogger.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsUnhandledActionsLogger, deps: [{ token: NGXS_DEVELOPMENT_OPTIONS }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ NgxsUnhandledActionsLogger.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsUnhandledActionsLogger });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsUnhandledActionsLogger, decorators: [{
              type: i0.Injectable
          }], ctorParameters: function () {
          return [{ type: undefined, decorators: [{
                          type: i0.Inject,
                          args: [NGXS_DEVELOPMENT_OPTIONS]
                      }] }];
      } });

  /**
   * Returns operator that will run
   * `subscribe` outside of the ngxs execution context
   */
  function leaveNgxs(ngxsExecutionStrategy) {
      return function (source) {
          return new rxjs.Observable(function (sink) {
              return source.subscribe({
                  next: function (value) {
                      ngxsExecutionStrategy.leave(function () { return sink.next(value); });
                  },
                  error: function (error) {
                      ngxsExecutionStrategy.leave(function () { return sink.error(error); });
                  },
                  complete: function () {
                      ngxsExecutionStrategy.leave(function () { return sink.complete(); });
                  }
              });
          });
      };
  }

  /**
   * This wraps the provided function, and will enforce the following:
   * - The calls will execute in the order that they are made
   * - A call will only be initiated when the previous call has completed
   * - If there is a call currently executing then the new call will be added
   *   to the queue and the function will return immediately
   *
   * NOTE: The following assumptions about the operation must hold true:
   * - The operation is synchronous in nature
   * - If any asynchronous side effects of the call exist, it should not
   *   have any bearing on the correctness of the next call in the queue
   * - The operation has a void return
   * - The caller should not assume that the call has completed upon
   *   return of the function
   * - The caller can assume that all the queued calls will complete
   *   within the current microtask
   * - The only way that a call will encounter another call in the queue
   *   would be if the call at the front of the queue initiated this call
   *   as part of its synchronous execution
   */
  function orderedQueueOperation(operation) {
      var callsQueue = [];
      var busyPushingNext = false;
      return function callOperation() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          if (busyPushingNext) {
              callsQueue.unshift(args);
              return;
          }
          busyPushingNext = true;
          operation.apply(void 0, __spreadArray([], __read(args)));
          while (callsQueue.length > 0) {
              var nextCallArgs = callsQueue.pop();
              nextCallArgs && operation.apply(void 0, __spreadArray([], __read(nextCallArgs)));
          }
          busyPushingNext = false;
      };
  }
  /**
   * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
   * A standard Subject does not have this guarantee.
   * For example, given the following code:
   * ```typescript
   *   const subject = new Subject<string>();
       subject.subscribe(value => {
         if (value === 'start') subject.next('end');
       });
       subject.subscribe(value => { });
       subject.next('start');
   * ```
   * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
   * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
   */
  var OrderedSubject = /** @class */ (function (_super) {
      __extends(OrderedSubject, _super);
      function OrderedSubject() {
          var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
          _this._orderedNext = orderedQueueOperation(function (value) { return _super.prototype.next.call(_this, value); });
          return _this;
      }
      OrderedSubject.prototype.next = function (value) {
          this._orderedNext(value);
      };
      return OrderedSubject;
  }(rxjs.Subject));
  /**
   * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.
   * A standard BehaviorSubject does not have this guarantee.
   * For example, given the following code:
   * ```typescript
   *   const subject = new BehaviorSubject<string>();
       subject.subscribe(value => {
         if (value === 'start') subject.next('end');
       });
       subject.subscribe(value => { });
       subject.next('start');
   * ```
   * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.
   * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.
   */
  var OrderedBehaviorSubject = /** @class */ (function (_super) {
      __extends(OrderedBehaviorSubject, _super);
      function OrderedBehaviorSubject(value) {
          var _this = _super.call(this, value) || this;
          _this._orderedNext = orderedQueueOperation(function (value) { return _super.prototype.next.call(_this, value); });
          _this._currentValue = value;
          return _this;
      }
      OrderedBehaviorSubject.prototype.getValue = function () {
          return this._currentValue;
      };
      OrderedBehaviorSubject.prototype.next = function (value) {
          this._currentValue = value;
          this._orderedNext(value);
      };
      return OrderedBehaviorSubject;
  }(rxjs.BehaviorSubject));

  var InternalNgxsExecutionStrategy = /** @class */ (function () {
      function InternalNgxsExecutionStrategy(_executionStrategy) {
          this._executionStrategy = _executionStrategy;
      }
      InternalNgxsExecutionStrategy.prototype.enter = function (func) {
          return this._executionStrategy.enter(func);
      };
      InternalNgxsExecutionStrategy.prototype.leave = function (func) {
          return this._executionStrategy.leave(func);
      };
      return InternalNgxsExecutionStrategy;
  }());
  /** @nocollapse */ InternalNgxsExecutionStrategy.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalNgxsExecutionStrategy, deps: [{ token: NGXS_EXECUTION_STRATEGY }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ InternalNgxsExecutionStrategy.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalNgxsExecutionStrategy, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalNgxsExecutionStrategy, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () {
          return [{ type: undefined, decorators: [{
                          type: i0.Inject,
                          args: [NGXS_EXECUTION_STRATEGY]
                      }] }];
      } });

  /**
   * Internal Action stream that is emitted anytime an action is dispatched.
   */
  var InternalActions = /** @class */ (function (_super) {
      __extends(InternalActions, _super);
      function InternalActions() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      InternalActions.prototype.ngOnDestroy = function () {
          this.complete();
      };
      return InternalActions;
  }(OrderedSubject));
  /** @nocollapse */ InternalActions.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalActions, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ InternalActions.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalActions, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalActions, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }] });
  /**
   * Action stream that is emitted anytime an action is dispatched.
   *
   * You can listen to this in services to react without stores.
   */
  var Actions = /** @class */ (function (_super) {
      __extends(Actions, _super);
      function Actions(internalActions$, internalExecutionStrategy) {
          var _this = this;
          var sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy), 
          // The `InternalActions` subject emits outside of the Angular zone.
          // We have to re-enter the Angular zone for any incoming consumer.
          // The `share()` operator reduces the number of change detections.
          // This would call leave only once for any stream emission across all active subscribers.
          operators.share());
          _this = _super.call(this, function (observer) {
              var childSubscription = sharedInternalActions$.subscribe({
                  next: function (ctx) { return observer.next(ctx); },
                  error: function (error) { return observer.error(error); },
                  complete: function () { return observer.complete(); }
              });
              observer.add(childSubscription);
          }) || this;
          return _this;
      }
      return Actions;
  }(rxjs.Observable));
  /** @nocollapse */ Actions.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: Actions, deps: [{ token: InternalActions }, { token: InternalNgxsExecutionStrategy }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ Actions.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: Actions, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: Actions, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () { return [{ type: InternalActions }, { type: InternalNgxsExecutionStrategy }]; } });

  /**
   * Composes a array of functions from left to right. Example:
   *
   *      compose([fn, final])(state, action);
   *
   * then the funcs have a signature like:
   *
   *      function fn (state, action, next) {
   *          console.log('here', state, action, next);
   *          return next(state, action);
   *      }
   *
   *      function final (state, action) {
   *          console.log('here', state, action);
   *          return state;
   *      }
   *
   * the last function should not call `next`.
   *
   * @ignore
   */
  var compose = function (funcs) { return function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      var curr = funcs.shift();
      return curr.apply(void 0, __spreadArray(__spreadArray([], __read(args)), [function () {
              var nextArgs = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  nextArgs[_i] = arguments[_i];
              }
              return compose(funcs).apply(void 0, __spreadArray([], __read(nextArgs)));
          }]));
  }; };

  /**
   * This operator is used for piping the observable result
   * from the `dispatch()`. It has a "smart" error handling
   * strategy that allows us to decide whether we propagate
   * errors to Angular's `ErrorHandler` or enable users to
   * handle them manually. We consider following cases:
   * 1) `store.dispatch()` (no subscribe) -> call `handleError()`
   * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`
   * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`
   * 4) `toPromise()` without `catch` -> do `handleError()`
   * 5) `toPromise()` with `catch` -> don't `handleError()`
   */
  function ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {
      return function (source) {
          var subscribed = false;
          source.subscribe({
              error: function (error) {
                  // Do not trigger change detection for a microtask. This depends on the execution
                  // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`
                  // leaves the Angular zone.
                  ngxsExecutionStrategy.enter(function () { return Promise.resolve().then(function () {
                      if (!subscribed) {
                          ngxsExecutionStrategy.leave(function () { return internalErrorReporter.reportErrorSafely(error); });
                      }
                  }); });
              }
          });
          return new rxjs.Observable(function (subscriber) {
              subscribed = true;
              return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);
          });
      };
  }
  var InternalErrorReporter = /** @class */ (function () {
      function InternalErrorReporter(_injector) {
          this._injector = _injector;
          /** Will be set lazily to be backward compatible. */
          this._errorHandler = null;
      }
      InternalErrorReporter.prototype.reportErrorSafely = function (error) {
          if (this._errorHandler === null) {
              this._errorHandler = this._injector.get(i0.ErrorHandler);
          }
          // The `try-catch` is used to avoid handling the error twice. Suppose we call
          // `handleError` which re-throws the error internally. The re-thrown error will
          // be caught by zone.js which will then get to the `zone.onError.emit()` and the
          // `onError` subscriber will call `handleError` again.
          try {
              this._errorHandler.handleError(error);
          }
          catch (_a) { }
      };
      return InternalErrorReporter;
  }());
  /** @nocollapse */ InternalErrorReporter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalErrorReporter, deps: [{ token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ InternalErrorReporter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalErrorReporter, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalErrorReporter, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () { return [{ type: i0__namespace.Injector }]; } });

  var PluginManager = /** @class */ (function () {
      function PluginManager(_parentManager, _pluginHandlers) {
          this._parentManager = _parentManager;
          this._pluginHandlers = _pluginHandlers;
          this.plugins = [];
          this.registerHandlers();
      }
      Object.defineProperty(PluginManager.prototype, "rootPlugins", {
          get: function () {
              return (this._parentManager && this._parentManager.plugins) || this.plugins;
          },
          enumerable: false,
          configurable: true
      });
      PluginManager.prototype.registerHandlers = function () {
          var _a;
          var pluginHandlers = this.getPluginHandlers();
          (_a = this.rootPlugins).push.apply(_a, __spreadArray([], __read(pluginHandlers)));
      };
      PluginManager.prototype.getPluginHandlers = function () {
          var handlers = this._pluginHandlers || [];
          return handlers.map(function (plugin) { return (plugin.handle ? plugin.handle.bind(plugin) : plugin); });
      };
      return PluginManager;
  }());
  /** @nocollapse */ PluginManager.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: PluginManager, deps: [{ token: PluginManager, optional: true, skipSelf: true }, { token: NGXS_PLUGINS, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ PluginManager.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: PluginManager });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: PluginManager, decorators: [{
              type: i0.Injectable
          }], ctorParameters: function () {
          return [{ type: PluginManager, decorators: [{
                          type: i0.Optional
                      }, {
                          type: i0.SkipSelf
                      }] }, { type: undefined, decorators: [{
                          type: i0.Inject,
                          args: [NGXS_PLUGINS]
                      }, {
                          type: i0.Optional
                      }] }];
      } });

  /**
   * BehaviorSubject of the entire state.
   * @ignore
   */
  var StateStream = /** @class */ (function (_super) {
      __extends(StateStream, _super);
      function StateStream() {
          return _super.call(this, {}) || this;
      }
      StateStream.prototype.ngOnDestroy = function () {
          // The `StateStream` should never emit values once the root view is removed, e.g. when the `NgModuleRef.destroy()` is called.
          // This will eliminate memory leaks in server-side rendered apps where the `StateStream` is created per each HTTP request, users
          // might forget to unsubscribe from `store.select` or `store.subscribe`, thus this will lead to huge memory leaks in SSR apps.
          this.complete();
      };
      return StateStream;
  }(OrderedBehaviorSubject));
  /** @nocollapse */ StateStream.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: StateStream, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ StateStream.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: StateStream, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: StateStream, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () { return []; } });

  /**
   * Internal Action result stream that is emitted when an action is completed.
   * This is used as a method of returning the action result to the dispatcher
   * for the observable returned by the dispatch(...) call.
   * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.
   */
  var InternalDispatchedActionResults = /** @class */ (function (_super) {
      __extends(InternalDispatchedActionResults, _super);
      function InternalDispatchedActionResults() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      return InternalDispatchedActionResults;
  }(rxjs.Subject));
  /** @nocollapse */ InternalDispatchedActionResults.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalDispatchedActionResults, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ InternalDispatchedActionResults.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalDispatchedActionResults, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalDispatchedActionResults, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }] });
  var InternalDispatcher = /** @class */ (function () {
      function InternalDispatcher(_actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy, _internalErrorReporter) {
          this._actions = _actions;
          this._actionResults = _actionResults;
          this._pluginManager = _pluginManager;
          this._stateStream = _stateStream;
          this._ngxsExecutionStrategy = _ngxsExecutionStrategy;
          this._internalErrorReporter = _internalErrorReporter;
      }
      /**
       * Dispatches event(s).
       */
      InternalDispatcher.prototype.dispatch = function (actionOrActions) {
          var _this = this;
          var result = this._ngxsExecutionStrategy.enter(function () { return _this.dispatchByEvents(actionOrActions); });
          return result.pipe(ngxsErrorHandler(this._internalErrorReporter, this._ngxsExecutionStrategy));
      };
      InternalDispatcher.prototype.dispatchByEvents = function (actionOrActions) {
          var _this = this;
          if (Array.isArray(actionOrActions)) {
              if (actionOrActions.length === 0)
                  return rxjs.of(this._stateStream.getValue());
              return rxjs.forkJoin(actionOrActions.map(function (action) { return _this.dispatchSingle(action); }));
          }
          else {
              return this.dispatchSingle(actionOrActions);
          }
      };
      InternalDispatcher.prototype.dispatchSingle = function (action) {
          var _this = this;
          if (typeof ngDevMode === 'undefined' || ngDevMode) {
              var type = getActionTypeFromInstance(action);
              if (!type) {
                  var error = new Error("This action doesn't have a type property: " + action.constructor.name);
                  return rxjs.throwError(error);
              }
          }
          var prevState = this._stateStream.getValue();
          var plugins = this._pluginManager.plugins;
          return compose(__spreadArray(__spreadArray([], __read(plugins)), [
              function (nextState, nextAction) {
                  if (nextState !== prevState) {
                      _this._stateStream.next(nextState);
                  }
                  var actionResult$ = _this.getActionResultStream(nextAction);
                  actionResult$.subscribe(function (ctx) { return _this._actions.next(ctx); });
                  _this._actions.next({ action: nextAction, status: "DISPATCHED" /* Dispatched */ });
                  return _this.createDispatchObservable(actionResult$);
              }
          ]))(prevState, action).pipe(operators.shareReplay());
      };
      InternalDispatcher.prototype.getActionResultStream = function (action) {
          return this._actionResults.pipe(operators.filter(function (ctx) { return ctx.action === action && ctx.status !== "DISPATCHED"; } /* Dispatched */), operators.take(1), operators.shareReplay());
      };
      InternalDispatcher.prototype.createDispatchObservable = function (actionResult$) {
          var _this = this;
          return actionResult$
              .pipe(operators.exhaustMap(function (ctx) {
              switch (ctx.status) {
                  case "SUCCESSFUL" /* Successful */:
                      return rxjs.of(_this._stateStream.getValue());
                  case "ERRORED" /* Errored */:
                      return rxjs.throwError(ctx.error);
                  default:
                      return rxjs.EMPTY;
              }
          }))
              .pipe(operators.shareReplay());
      };
      return InternalDispatcher;
  }());
  /** @nocollapse */ InternalDispatcher.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalDispatcher, deps: [{ token: InternalActions }, { token: InternalDispatchedActionResults }, { token: PluginManager }, { token: StateStream }, { token: InternalNgxsExecutionStrategy }, { token: InternalErrorReporter }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ InternalDispatcher.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalDispatcher, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalDispatcher, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () { return [{ type: InternalActions }, { type: InternalDispatchedActionResults }, { type: PluginManager }, { type: StateStream }, { type: InternalNgxsExecutionStrategy }, { type: InternalErrorReporter }]; } });

  function simplePatch(value) {
      return function (existingState) {
          if (typeof ngDevMode === 'undefined' || ngDevMode) {
              if (Array.isArray(value)) {
                  throwPatchingArrayError();
              }
              else if (typeof value !== 'object') {
                  throwPatchingPrimitiveError();
              }
          }
          var newState = Object.assign({}, existingState);
          for (var key in value) {
              // deep clone for patch compatibility
              newState[key] = value[key];
          }
          return newState;
      };
  }

  /**
   * Object freeze code
   * https://github.com/jsdf/deep-freeze
   */
  var deepFreeze = function (o) {
      Object.freeze(o);
      var oIsFunction = typeof o === 'function';
      var hasOwnProp = Object.prototype.hasOwnProperty;
      Object.getOwnPropertyNames(o).forEach(function (prop) {
          if (hasOwnProp.call(o, prop) &&
              (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&
              o[prop] !== null &&
              (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&
              !Object.isFrozen(o[prop])) {
              deepFreeze(o[prop]);
          }
      });
      return o;
  };

  /**
   * @ignore
   */
  var InternalStateOperations = /** @class */ (function () {
      function InternalStateOperations(_stateStream, _dispatcher, _config) {
          this._stateStream = _stateStream;
          this._dispatcher = _dispatcher;
          this._config = _config;
      }
      /**
       * Returns the root state operators.
       */
      InternalStateOperations.prototype.getRootStateOperations = function () {
          var _this = this;
          var rootStateOperations = {
              getState: function () { return _this._stateStream.getValue(); },
              setState: function (newState) { return _this._stateStream.next(newState); },
              dispatch: function (actionOrActions) { return _this._dispatcher.dispatch(actionOrActions); }
          };
          if (typeof ngDevMode === 'undefined' || ngDevMode) {
              return this._config.developmentMode
                  ? ensureStateAndActionsAreImmutable(rootStateOperations)
                  : rootStateOperations;
          }
          else {
              return rootStateOperations;
          }
      };
      InternalStateOperations.prototype.setStateToTheCurrentWithNew = function (results) {
          var stateOperations = this.getRootStateOperations();
          // Get our current stream
          var currentState = stateOperations.getState();
          // Set the state to the current + new
          stateOperations.setState(Object.assign(Object.assign({}, currentState), results.defaults));
      };
      return InternalStateOperations;
  }());
  /** @nocollapse */ InternalStateOperations.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalStateOperations, deps: [{ token: StateStream }, { token: InternalDispatcher }, { token: NgxsConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ InternalStateOperations.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalStateOperations, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: InternalStateOperations, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () { return [{ type: StateStream }, { type: InternalDispatcher }, { type: NgxsConfig }]; } });
  function ensureStateAndActionsAreImmutable(root) {
      return {
          getState: function () { return root.getState(); },
          setState: function (value) {
              var frozenValue = deepFreeze(value);
              return root.setState(frozenValue);
          },
          dispatch: function (actions) {
              return root.dispatch(actions);
          }
      };
  }

  /**
   * State Context factory class
   * @ignore
   */
  var StateContextFactory = /** @class */ (function () {
      function StateContextFactory(_internalStateOperations) {
          this._internalStateOperations = _internalStateOperations;
      }
      /**
       * Create the state context
       */
      StateContextFactory.prototype.createStateContext = function (mappedStore) {
          var root = this._internalStateOperations.getRootStateOperations();
          return {
              getState: function () {
                  var currentAppState = root.getState();
                  return getState(currentAppState, mappedStore.path);
              },
              patchState: function (val) {
                  var currentAppState = root.getState();
                  var patchOperator = simplePatch(val);
                  return setStateFromOperator(root, currentAppState, patchOperator, mappedStore.path);
              },
              setState: function (val) {
                  var currentAppState = root.getState();
                  return operators$1.isStateOperator(val)
                      ? setStateFromOperator(root, currentAppState, val, mappedStore.path)
                      : setStateValue(root, currentAppState, val, mappedStore.path);
              },
              dispatch: function (actions) {
                  return root.dispatch(actions);
              }
          };
      };
      return StateContextFactory;
  }());
  /** @nocollapse */ StateContextFactory.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: StateContextFactory, deps: [{ token: InternalStateOperations }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ StateContextFactory.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: StateContextFactory, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: StateContextFactory, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () { return [{ type: InternalStateOperations }]; } });
  function setStateValue(root, currentAppState, newValue, path) {
      var newAppState = setValue(currentAppState, path, newValue);
      root.setState(newAppState);
      return newAppState;
      // In doing this refactoring I noticed that there is a 'bug' where the
      // application state is returned instead of this state slice.
      // This has worked this way since the beginning see:
      // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts
      // This needs to be fixed, but is a 'breaking' change.
      // I will do this fix in a subsequent PR and we can decide how to handle it.
  }
  function setStateFromOperator(root, currentAppState, stateOperator, path) {
      var local = getState(currentAppState, path);
      var newValue = stateOperator(local);
      return setStateValue(root, currentAppState, newValue, path);
  }
  function getState(currentAppState, path) {
      return getValue(currentAppState, path);
  }

  var NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
  /**
   * The `StateFactory` class adds root and feature states to the graph.
   * This extracts state names from state classes, checks if they already
   * exist in the global graph, throws errors if their names are invalid, etc.
   * See its constructor, state factories inject state factories that are
   * parent-level providers. This is required to get feature states from the
   * injector on the same level.
   *
   * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.
   * The `StateFactory` is initialized on the feature level and goes through `...states`
   * to get them from the injector through `injector.get(state)`.
   * @ignore
   */
  var StateFactory = /** @class */ (function () {
      function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
          var _this = this;
          this._injector = _injector;
          this._config = _config;
          this._parentFactory = _parentFactory;
          this._actions = _actions;
          this._actionResults = _actionResults;
          this._stateContextFactory = _stateContextFactory;
          this._initialState = _initialState;
          this._actionsSubscription = null;
          this._states = [];
          this._statesByName = {};
          this._statePaths = {};
          this.getRuntimeSelectorContext = i5.memoize(function () {
              // eslint-disable-next-line @typescript-eslint/no-this-alias
              var stateFactory = _this;
              function resolveGetter(key) {
                  var path = stateFactory.statePaths[key];
                  return path ? propGetter(path.split('.'), stateFactory._config) : null;
              }
              var context = _this._parentFactory
                  ? _this._parentFactory.getRuntimeSelectorContext()
                  : {
                      getStateGetter: function (key) {
                          var getter = resolveGetter(key);
                          if (getter) {
                              return getter;
                          }
                          return function () {
                              var args = [];
                              for (var _i = 0; _i < arguments.length; _i++) {
                                  args[_i] = arguments[_i];
                              }
                              // Late loaded getter
                              if (!getter) {
                                  getter = resolveGetter(key);
                              }
                              return getter ? getter.apply(void 0, __spreadArray([], __read(args))) : undefined;
                          };
                      },
                      getSelectorOptions: function (localOptions) {
                          var globalSelectorOptions = stateFactory._config.selectorOptions;
                          return Object.assign(Object.assign({}, globalSelectorOptions), (localOptions || {}));
                      }
                  };
              return context;
          });
      }
      Object.defineProperty(StateFactory.prototype, "states", {
          get: function () {
              return this._parentFactory ? this._parentFactory.states : this._states;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(StateFactory.prototype, "statesByName", {
          get: function () {
              return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(StateFactory.prototype, "statePaths", {
          get: function () {
              return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
          },
          enumerable: false,
          configurable: true
      });
      StateFactory._cloneDefaults = function (defaults) {
          var value = defaults;
          if (Array.isArray(defaults)) {
              value = defaults.slice();
          }
          else if (isObject(defaults)) {
              value = Object.assign({}, defaults);
          }
          else if (defaults === undefined) {
              value = {};
          }
          return value;
      };
      StateFactory.prototype.ngOnDestroy = function () {
          var _a;
          (_a = this._actionsSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
      };
      /**
       * Add a new state to the global defs.
       */
      StateFactory.prototype.add = function (stateClasses) {
          var e_1, _b;
          if (NG_DEV_MODE) {
              ensureStatesAreDecorated(stateClasses);
          }
          var newStates = this.addToStatesMap(stateClasses).newStates;
          if (!newStates.length)
              return [];
          var stateGraph = buildGraph(newStates);
          var sortedStates = topologicalSort(stateGraph);
          var paths = findFullParentPath(stateGraph);
          var nameGraph = nameToState(newStates);
          var bootstrappedStores = [];
          try {
              for (var sortedStates_1 = __values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                  var name = sortedStates_1_1.value;
                  var stateClass = nameGraph[name];
                  var path = paths[name];
                  var meta = stateClass[META_KEY];
                  this.addRuntimeInfoToMeta(meta, path);
                  // Note: previously we called `ensureStateClassIsInjectable` within the
                  // `State` decorator. This check is moved here because the `ɵprov` property
                  // will not exist on the class in JIT mode (because it's set asynchronously
                  // during JIT compilation through `Object.defineProperty`).
                  if (NG_DEV_MODE) {
                      ensureStateClassIsInjectable(stateClass);
                  }
                  var stateMap = {
                      name: name,
                      path: path,
                      isInitialised: false,
                      actions: meta.actions,
                      instance: this._injector.get(stateClass),
                      defaults: StateFactory._cloneDefaults(meta.defaults)
                  };
                  // ensure our store hasn't already been added
                  // but don't throw since it could be lazy
                  // loaded from different paths
                  if (!this.hasBeenMountedAndBootstrapped(name, path)) {
                      bootstrappedStores.push(stateMap);
                  }
                  this.states.push(stateMap);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (sortedStates_1_1 && !sortedStates_1_1.done && (_b = sortedStates_1.return)) _b.call(sortedStates_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
          return bootstrappedStores;
      };
      /**
       * Add a set of states to the store and return the defaults
       */
      StateFactory.prototype.addAndReturnDefaults = function (stateClasses) {
          var classes = stateClasses || [];
          var mappedStores = this.add(classes);
          var defaults = mappedStores.reduce(function (result, mappedStore) { return setValue(result, mappedStore.path, mappedStore.defaults); }, {});
          return { defaults: defaults, states: mappedStores };
      };
      StateFactory.prototype.connectActionHandlers = function () {
          var _this = this;
          // Note: We have to connect actions only once when the `StateFactory`
          //       is being created for the first time. This checks if we're in
          //       a child state factory and the parent state factory already exists.
          if (this._parentFactory || this._actionsSubscription !== null) {
              return;
          }
          var dispatched$ = new rxjs.Subject();
          this._actionsSubscription = this._actions
              .pipe(operators.filter(function (ctx) { return ctx.status === "DISPATCHED"; } /* Dispatched */), operators.mergeMap(function (ctx) {
              dispatched$.next(ctx);
              var action = ctx.action;
              return _this.invokeActions(dispatched$, action).pipe(operators.map(function () { return ({ action: action, status: "SUCCESSFUL" /* Successful */ }); }), operators.defaultIfEmpty({ action: action, status: "CANCELED" /* Canceled */ }), operators.catchError(function (error) { return rxjs.of({ action: action, status: "ERRORED" /* Errored */, error: error }); }));
          }))
              .subscribe(function (ctx) { return _this._actionResults.next(ctx); });
      };
      /**
       * Invoke actions on the states.
       */
      StateFactory.prototype.invokeActions = function (dispatched$, action) {
          var e_2, _b, e_3, _c;
          var type = getActionTypeFromInstance(action);
          var results = [];
          // Determines whether the dispatched action has been handled, this is assigned
          // to `true` within the below `for` loop if any `actionMetas` has been found.
          var actionHasBeenHandled = false;
          try {
              for (var _d = __values(this.states), _e = _d.next(); !_e.done; _e = _d.next()) {
                  var metadata = _e.value;
                  var actionMetas = metadata.actions[type];
                  if (actionMetas) {
                      try {
                          for (var actionMetas_1 = (e_3 = void 0, __values(actionMetas)), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                              var actionMeta = actionMetas_1_1.value;
                              var stateContext = this._stateContextFactory.createStateContext(metadata);
                              try {
                                  var result = metadata.instance[actionMeta.fn](stateContext, action);
                                  if (result instanceof Promise) {
                                      result = rxjs.from(result);
                                  }
                                  if (rxjs.isObservable(result)) {
                                      // If this observable has been completed w/o emitting
                                      // any value then we wouldn't want to complete the whole chain
                                      // of actions. Since if any observable completes then
                                      // action will be canceled.
                                      // For instance if any action handler would've had such statement:
                                      // `handler(ctx) { return EMPTY; }`
                                      // then the action will be canceled.
                                      // See https://github.com/ngxs/store/issues/1568
                                      result = result.pipe(operators.mergeMap(function (value) {
                                          if (value instanceof Promise) {
                                              return rxjs.from(value);
                                          }
                                          if (rxjs.isObservable(value)) {
                                              return value;
                                          }
                                          return rxjs.of(value);
                                      }), operators.defaultIfEmpty({}));
                                      if (actionMeta.options.cancelUncompleted) {
                                          // todo: ofActionDispatched should be used with action class
                                          result = result.pipe(operators.takeUntil(dispatched$.pipe(ofActionDispatched(action))));
                                      }
                                  }
                                  else {
                                      result = rxjs.of({}).pipe(operators.shareReplay());
                                  }
                                  results.push(result);
                              }
                              catch (e) {
                                  results.push(rxjs.throwError(e));
                              }
                              actionHasBeenHandled = true;
                          }
                      }
                      catch (e_3_1) { e_3 = { error: e_3_1 }; }
                      finally {
                          try {
                              if (actionMetas_1_1 && !actionMetas_1_1.done && (_c = actionMetas_1.return)) _c.call(actionMetas_1);
                          }
                          finally { if (e_3) throw e_3.error; }
                      }
                  }
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
              }
              finally { if (e_2) throw e_2.error; }
          }
          // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions
          // only during development.
          if (NG_DEV_MODE && !actionHasBeenHandled) {
              var unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);
              // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the
              // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`
              // didn't return `null` so we may ensure the module has been imported.
              if (unhandledActionsLogger) {
                  unhandledActionsLogger.warn(action);
              }
          }
          if (!results.length) {
              results.push(rxjs.of({}));
          }
          return rxjs.forkJoin(results);
      };
      StateFactory.prototype.addToStatesMap = function (stateClasses) {
          var e_4, _b;
          var newStates = [];
          var statesMap = this.statesByName;
          try {
              for (var stateClasses_1 = __values(stateClasses), stateClasses_1_1 = stateClasses_1.next(); !stateClasses_1_1.done; stateClasses_1_1 = stateClasses_1.next()) {
                  var stateClass = stateClasses_1_1.value;
                  var stateName = getStoreMetadata$1(stateClass).name;
                  if (NG_DEV_MODE) {
                      ensureStateNameIsUnique(stateName, stateClass, statesMap);
                  }
                  var unmountedState = !statesMap[stateName];
                  if (unmountedState) {
                      newStates.push(stateClass);
                      statesMap[stateName] = stateClass;
                  }
              }
          }
          catch (e_4_1) { e_4 = { error: e_4_1 }; }
          finally {
              try {
                  if (stateClasses_1_1 && !stateClasses_1_1.done && (_b = stateClasses_1.return)) _b.call(stateClasses_1);
              }
              finally { if (e_4) throw e_4.error; }
          }
          return { newStates: newStates };
      };
      StateFactory.prototype.addRuntimeInfoToMeta = function (meta, path) {
          this.statePaths[meta.name] = path;
          // TODO: v4 - we plan to get rid of the path property because it is non-deterministic
          // we can do this when we get rid of the incorrectly exposed getStoreMetadata
          // We will need to come up with an alternative in v4 because this is used by many plugins
          meta.path = path;
      };
      StateFactory.prototype.hasBeenMountedAndBootstrapped = function (name, path) {
          var valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
          // This checks whether a state has been already added to the global graph and
          // its lifecycle is in 'bootstrapped' state.
          return this.statesByName[name] && valueIsBootstrappedInInitialState;
      };
      return StateFactory;
  }());
  /** @nocollapse */ StateFactory.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: StateFactory, deps: [{ token: i0__namespace.Injector }, { token: NgxsConfig }, { token: StateFactory, optional: true, skipSelf: true }, { token: InternalActions }, { token: InternalDispatchedActionResults }, { token: StateContextFactory }, { token: i5.INITIAL_STATE_TOKEN, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ StateFactory.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: StateFactory });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: StateFactory, decorators: [{
              type: i0.Injectable
          }], ctorParameters: function () {
          return [{ type: i0__namespace.Injector }, { type: NgxsConfig }, { type: StateFactory, decorators: [{
                          type: i0.Optional
                      }, {
                          type: i0.SkipSelf
                      }] }, { type: InternalActions }, { type: InternalDispatchedActionResults }, { type: StateContextFactory }, { type: undefined, decorators: [{
                          type: i0.Optional
                      }, {
                          type: i0.Inject,
                          args: [i5.INITIAL_STATE_TOKEN]
                      }] }];
      } });

  function createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {
      return function (context) {
          var _a = getRuntimeSelectorInfo(context, selectorMetaData, selectors), argumentSelectorFunctions = _a.argumentSelectorFunctions, selectorOptions = _a.selectorOptions;
          return function selectFromRoot(rootState) {
              // Determine arguments from the app state using the selectors
              var results = argumentSelectorFunctions.map(function (argFn) { return argFn(rootState); });
              // if the lambda tries to access a something on the
              // state that doesn't exist, it will throw a TypeError.
              // since this is quite usual behaviour, we simply return undefined if so.
              try {
                  return memoizedSelectorFn.apply(void 0, __spreadArray([], __read(results)));
              }
              catch (ex) {
                  if (ex instanceof TypeError && selectorOptions.suppressErrors) {
                      return undefined;
                  }
                  throw ex;
              }
          };
      };
  }
  function createMemoizedSelectorFn(originalFn, creationMetadata) {
      var containerClass = creationMetadata && creationMetadata.containerClass;
      var wrappedFn = function wrappedSelectorFn() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          var returnValue = originalFn.apply(containerClass, args);
          if (returnValue instanceof Function) {
              var innerMemoizedFn = i5.memoize.apply(null, [returnValue]);
              return innerMemoizedFn;
          }
          return returnValue;
      };
      var memoizedFn = i5.memoize(wrappedFn);
      Object.setPrototypeOf(memoizedFn, originalFn);
      return memoizedFn;
  }
  function getRuntimeSelectorInfo(context, selectorMetaData, selectors) {
      if (selectors === void 0) { selectors = []; }
      var localSelectorOptions = selectorMetaData.getSelectorOptions();
      var selectorOptions = context.getSelectorOptions(localSelectorOptions);
      var selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);
      var argumentSelectorFunctions = selectorsToApply.map(function (selector) {
          var factory = getRootSelectorFactory(selector);
          return factory(context);
      });
      return {
          selectorOptions: selectorOptions,
          argumentSelectorFunctions: argumentSelectorFunctions,
      };
  }
  function getSelectorsToApply(selectors, selectorOptions, containerClass) {
      if (selectors === void 0) { selectors = []; }
      var selectorsToApply = [];
      var canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;
      if (containerClass && canInjectContainerState) {
          // If we are on a state class, add it as the first selector parameter
          var metadata = getStoreMetadata$1(containerClass);
          if (metadata) {
              selectorsToApply.push(containerClass);
          }
      }
      if (selectors) {
          selectorsToApply.push.apply(selectorsToApply, __spreadArray([], __read(selectors)));
      }
      return selectorsToApply;
  }
  /**
   * This function gets the factory function to create the selector to get the selected slice from the app state
   * @ignore
   */
  function getRootSelectorFactory(selector) {
      var metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);
      return (metadata && metadata.makeRootSelector) || (function () { return selector; });
  }

  // tslint:disable:unified-signatures
  var Store = /** @class */ (function () {
      function Store(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {
          this._stateStream = _stateStream;
          this._internalStateOperations = _internalStateOperations;
          this._config = _config;
          this._internalExecutionStrategy = _internalExecutionStrategy;
          this._stateFactory = _stateFactory;
          /**
           * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,
           * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.
           * All selects would use this stream, and it would call leave only once for any state change across all active selectors.
           */
          this._selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), operators.shareReplay({ bufferSize: 1, refCount: true }));
          this.initStateStream(initialStateValue);
      }
      /**
       * Dispatches event(s).
       */
      Store.prototype.dispatch = function (actionOrActions) {
          return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);
      };
      Store.prototype.select = function (selector) {
          var _this = this;
          var selectorFn = this.getStoreBoundSelectorFn(selector);
          return this._selectableStateStream.pipe(operators.map(selectorFn), operators.catchError(function (err) {
              // if error is TypeError we swallow it to prevent usual errors with property access
              var suppressErrors = _this._config.selectorOptions.suppressErrors;
              if (err instanceof TypeError && suppressErrors) {
                  return rxjs.of(undefined);
              }
              // rethrow other errors
              return rxjs.throwError(err);
          }), operators.distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));
      };
      Store.prototype.selectOnce = function (selector) {
          return this.select(selector).pipe(operators.take(1));
      };
      Store.prototype.selectSnapshot = function (selector) {
          var selectorFn = this.getStoreBoundSelectorFn(selector);
          return selectorFn(this._stateStream.getValue());
      };
      /**
       * Allow the user to subscribe to the root of the state
       */
      Store.prototype.subscribe = function (fn) {
          return this._selectableStateStream
              .pipe(leaveNgxs(this._internalExecutionStrategy))
              .subscribe(fn);
      };
      /**
       * Return the raw value of the state.
       */
      Store.prototype.snapshot = function () {
          return this._internalStateOperations.getRootStateOperations().getState();
      };
      /**
       * Reset the state to a specific point in time. This method is useful
       * for plugin's who need to modify the state directly or unit testing.
       */
      Store.prototype.reset = function (state) {
          return this._internalStateOperations.getRootStateOperations().setState(state);
      };
      Store.prototype.getStoreBoundSelectorFn = function (selector) {
          var makeSelectorFn = getRootSelectorFactory(selector);
          var runtimeContext = this._stateFactory.getRuntimeSelectorContext();
          return makeSelectorFn(runtimeContext);
      };
      Store.prototype.initStateStream = function (initialStateValue) {
          var value = this._stateStream.value;
          var storeIsEmpty = !value || Object.keys(value).length === 0;
          if (storeIsEmpty) {
              var defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;
              var storeValues = defaultStateNotEmpty
                  ? Object.assign(Object.assign({}, this._config.defaultsState), initialStateValue) : initialStateValue;
              this._stateStream.next(storeValues);
          }
      };
      return Store;
  }());
  /** @nocollapse */ Store.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: Store, deps: [{ token: StateStream }, { token: InternalStateOperations }, { token: NgxsConfig }, { token: InternalNgxsExecutionStrategy }, { token: StateFactory }, { token: i5.INITIAL_STATE_TOKEN, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ Store.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: Store, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: Store, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () {
          return [{ type: StateStream }, { type: InternalStateOperations }, { type: NgxsConfig }, { type: InternalNgxsExecutionStrategy }, { type: StateFactory }, { type: undefined, decorators: [{
                          type: i0.Optional
                      }, {
                          type: i0.Inject,
                          args: [i5.INITIAL_STATE_TOKEN]
                      }] }];
      } });

  /**
   * Allows the select decorator to get access to the DI store, this is used internally
   * in `@Select` decorator.
   */
  var SelectFactory = /** @class */ (function () {
      function SelectFactory(store, config) {
          SelectFactory.store = store;
          SelectFactory.config = config;
      }
      SelectFactory.prototype.ngOnDestroy = function () {
          SelectFactory.store = null;
          SelectFactory.config = null;
      };
      return SelectFactory;
  }());
  SelectFactory.store = null;
  SelectFactory.config = null;
  /** @nocollapse */ SelectFactory.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: SelectFactory, deps: [{ token: Store }, { token: NgxsConfig }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ SelectFactory.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: SelectFactory, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: SelectFactory, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () { return [{ type: Store }, { type: NgxsConfig }]; } });

  var LifecycleStateManager = /** @class */ (function () {
      function LifecycleStateManager(_store, _internalErrorReporter, _internalStateOperations, _stateContextFactory, _bootstrapper) {
          this._store = _store;
          this._internalErrorReporter = _internalErrorReporter;
          this._internalStateOperations = _internalStateOperations;
          this._stateContextFactory = _stateContextFactory;
          this._bootstrapper = _bootstrapper;
          this._destroy$ = new rxjs.Subject();
      }
      LifecycleStateManager.prototype.ngOnDestroy = function () {
          this._destroy$.next();
      };
      LifecycleStateManager.prototype.ngxsBootstrap = function (action, results) {
          var _this = this;
          this._internalStateOperations
              .getRootStateOperations()
              .dispatch(action)
              .pipe(operators.filter(function () { return !!results; }), operators.tap(function () { return _this._invokeInitOnStates(results.states); }), operators.mergeMap(function () { return _this._bootstrapper.appBootstrapped$; }), operators.filter(function (appBootstrapped) { return !!appBootstrapped; }), operators.catchError(function (error) {
              // The `SafeSubscriber` (which is used by most RxJS operators) re-throws
              // errors asynchronously (`setTimeout(() => { throw error })`). This might
              // break existing user's code or unit tests. We catch the error manually to
              // be backward compatible with the old behavior.
              _this._internalErrorReporter.reportErrorSafely(error);
              return rxjs.EMPTY;
          }), operators.takeUntil(this._destroy$))
              .subscribe(function () { return _this._invokeBootstrapOnStates(results.states); });
      };
      LifecycleStateManager.prototype._invokeInitOnStates = function (mappedStores) {
          var e_1, _a;
          var _loop_1 = function (mappedStore) {
              var instance = mappedStore.instance;
              if (instance.ngxsOnChanges) {
                  this_1._store
                      .select(function (state) { return getValue(state, mappedStore.path); })
                      .pipe(operators.startWith(undefined), operators.pairwise(), operators.takeUntil(this_1._destroy$))
                      .subscribe(function (_a) {
                      var _b = __read(_a, 2), previousValue = _b[0], currentValue = _b[1];
                      var change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);
                      instance.ngxsOnChanges(change);
                  });
              }
              if (instance.ngxsOnInit) {
                  instance.ngxsOnInit(this_1._getStateContext(mappedStore));
              }
              mappedStore.isInitialised = true;
          };
          var this_1 = this;
          try {
              for (var mappedStores_1 = __values(mappedStores), mappedStores_1_1 = mappedStores_1.next(); !mappedStores_1_1.done; mappedStores_1_1 = mappedStores_1.next()) {
                  var mappedStore = mappedStores_1_1.value;
                  _loop_1(mappedStore);
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (mappedStores_1_1 && !mappedStores_1_1.done && (_a = mappedStores_1.return)) _a.call(mappedStores_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
      LifecycleStateManager.prototype._invokeBootstrapOnStates = function (mappedStores) {
          var e_2, _a;
          try {
              for (var mappedStores_2 = __values(mappedStores), mappedStores_2_1 = mappedStores_2.next(); !mappedStores_2_1.done; mappedStores_2_1 = mappedStores_2.next()) {
                  var mappedStore = mappedStores_2_1.value;
                  var instance = mappedStore.instance;
                  if (instance.ngxsAfterBootstrap) {
                      instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));
                  }
              }
          }
          catch (e_2_1) { e_2 = { error: e_2_1 }; }
          finally {
              try {
                  if (mappedStores_2_1 && !mappedStores_2_1.done && (_a = mappedStores_2.return)) _a.call(mappedStores_2);
              }
              finally { if (e_2) throw e_2.error; }
          }
      };
      LifecycleStateManager.prototype._getStateContext = function (mappedStore) {
          return this._stateContextFactory.createStateContext(mappedStore);
      };
      return LifecycleStateManager;
  }());
  /** @nocollapse */ LifecycleStateManager.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: LifecycleStateManager, deps: [{ token: Store }, { token: InternalErrorReporter }, { token: InternalStateOperations }, { token: StateContextFactory }, { token: i5__namespace.NgxsBootstrapper }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
  /** @nocollapse */ LifecycleStateManager.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: LifecycleStateManager, providedIn: 'root' });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: LifecycleStateManager, decorators: [{
              type: i0.Injectable,
              args: [{ providedIn: 'root' }]
          }], ctorParameters: function () { return [{ type: Store }, { type: InternalErrorReporter }, { type: InternalStateOperations }, { type: StateContextFactory }, { type: i5__namespace.NgxsBootstrapper }]; } });

  /**
   * Root module
   * @ignore
   */
  var NgxsRootModule = /** @class */ (function () {
      function NgxsRootModule(factory, internalStateOperations, _store, _select, states, lifecycleStateManager) {
          if (states === void 0) { states = []; }
          // Add stores to the state graph and return their defaults
          var results = factory.addAndReturnDefaults(states);
          internalStateOperations.setStateToTheCurrentWithNew(results);
          // Connect our actions stream
          factory.connectActionHandlers();
          // Dispatch the init action and invoke init and bootstrap functions after
          lifecycleStateManager.ngxsBootstrap(new InitState(), results);
      }
      return NgxsRootModule;
  }());
  /** @nocollapse */ NgxsRootModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsRootModule, deps: [{ token: StateFactory }, { token: InternalStateOperations }, { token: Store }, { token: SelectFactory }, { token: ROOT_STATE_TOKEN, optional: true }, { token: LifecycleStateManager }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
  /** @nocollapse */ NgxsRootModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsRootModule });
  /** @nocollapse */ NgxsRootModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsRootModule });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsRootModule, decorators: [{
              type: i0.NgModule
          }], ctorParameters: function () {
          return [{ type: StateFactory }, { type: InternalStateOperations }, { type: Store }, { type: SelectFactory }, { type: undefined, decorators: [{
                          type: i0.Optional
                      }, {
                          type: i0.Inject,
                          args: [ROOT_STATE_TOKEN]
                      }] }, { type: LifecycleStateManager }];
      } });

  /**
   * Feature module
   * @ignore
   */
  var NgxsFeatureModule = /** @class */ (function () {
      function NgxsFeatureModule(_store, internalStateOperations, factory, states, lifecycleStateManager) {
          if (states === void 0) { states = []; }
          // Since FEATURE_STATE_TOKEN is a multi token, we need to
          // flatten it [[Feature1State, Feature2State], [Feature3State]]
          var flattenedStates = NgxsFeatureModule.flattenStates(states);
          // add stores to the state graph and return their defaults
          var results = factory.addAndReturnDefaults(flattenedStates);
          if (results.states.length) {
              internalStateOperations.setStateToTheCurrentWithNew(results);
              // dispatch the update action and invoke init and bootstrap functions after
              lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);
          }
      }
      NgxsFeatureModule.flattenStates = function (states) {
          if (states === void 0) { states = []; }
          return states.reduce(function (total, values) { return total.concat(values); }, []);
      };
      return NgxsFeatureModule;
  }());
  /** @nocollapse */ NgxsFeatureModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsFeatureModule, deps: [{ token: Store }, { token: InternalStateOperations }, { token: StateFactory }, { token: FEATURE_STATE_TOKEN, optional: true }, { token: LifecycleStateManager }], target: i0__namespace.ɵɵFactoryTarget.NgModule });
  /** @nocollapse */ NgxsFeatureModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsFeatureModule });
  /** @nocollapse */ NgxsFeatureModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsFeatureModule });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsFeatureModule, decorators: [{
              type: i0.NgModule
          }], ctorParameters: function () {
          return [{ type: Store }, { type: InternalStateOperations }, { type: StateFactory }, { type: undefined, decorators: [{
                          type: i0.Optional
                      }, {
                          type: i0.Inject,
                          args: [FEATURE_STATE_TOKEN]
                      }] }, { type: LifecycleStateManager }];
      } });

  /**
   * Ngxs Module
   */
  var NgxsModule = /** @class */ (function () {
      function NgxsModule() {
      }
      /**
       * Root module factory
       */
      NgxsModule.forRoot = function (states, options) {
          if (states === void 0) { states = []; }
          if (options === void 0) { options = {}; }
          return {
              ngModule: NgxsRootModule,
              providers: __spreadArray(__spreadArray([
                  StateFactory,
                  PluginManager
              ], __read(states)), __read(NgxsModule.ngxsTokenProviders(states, options)))
          };
      };
      /**
       * Feature module factory
       */
      NgxsModule.forFeature = function (states) {
          if (states === void 0) { states = []; }
          return {
              ngModule: NgxsFeatureModule,
              providers: __spreadArray(__spreadArray([
                  // This is required on the feature level, see comments in `state-factory.ts`.
                  StateFactory,
                  PluginManager
              ], __read(states)), [
                  {
                      provide: FEATURE_STATE_TOKEN,
                      multi: true,
                      useValue: states
                  }
              ])
          };
      };
      NgxsModule.ngxsTokenProviders = function (states, options) {
          return [
              {
                  provide: USER_PROVIDED_NGXS_EXECUTION_STRATEGY,
                  useValue: options.executionStrategy
              },
              {
                  provide: ROOT_STATE_TOKEN,
                  useValue: states
              },
              {
                  provide: ROOT_OPTIONS,
                  useValue: options
              },
              {
                  provide: i0.APP_BOOTSTRAP_LISTENER,
                  useFactory: NgxsModule.appBootstrapListenerFactory,
                  multi: true,
                  deps: [i5.NgxsBootstrapper]
              },
              {
                  provide: i5["ɵNGXS_STATE_CONTEXT_FACTORY"],
                  useExisting: StateContextFactory
              },
              {
                  provide: i5["ɵNGXS_STATE_FACTORY"],
                  useExisting: StateFactory
              }
          ];
      };
      NgxsModule.appBootstrapListenerFactory = function (bootstrapper) {
          return function () { return bootstrapper.bootstrap(); };
      };
      return NgxsModule;
  }());
  /** @nocollapse */ NgxsModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
  /** @nocollapse */ NgxsModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsModule });
  /** @nocollapse */ NgxsModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsModule });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsModule, decorators: [{
              type: i0.NgModule
          }] });

  /**
   * Decorates a method with a action information.
   */
  function Action(actions, options) {
      return function (target, name) {
          var e_1, _a;
          // Caretaker note: we have still left the `typeof` condition in order to avoid
          // creating a breaking change for projects that still use the View Engine.
          if (typeof ngDevMode === 'undefined' || ngDevMode) {
              var isStaticMethod = target.hasOwnProperty('prototype');
              if (isStaticMethod) {
                  throwActionDecoratorError();
              }
          }
          var meta = ensureStoreMetadata$1(target.constructor);
          if (!Array.isArray(actions)) {
              actions = [actions];
          }
          try {
              for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                  var action = actions_1_1.value;
                  var type = action.type;
                  if (!meta.actions[type]) {
                      meta.actions[type] = [];
                  }
                  meta.actions[type].push({
                      fn: name,
                      options: options || {},
                      type: type
                  });
              }
          }
          catch (e_1_1) { e_1 = { error: e_1_1 }; }
          finally {
              try {
                  if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
              }
              finally { if (e_1) throw e_1.error; }
          }
      };
  }

  /**
   * Decorates a class with ngxs state information.
   */
  function State(options) {
      return function (target) {
          var stateClass = target;
          var meta = ensureStoreMetadata$1(stateClass);
          var inheritedStateClass = Object.getPrototypeOf(stateClass);
          var optionsWithInheritance = getStateOptions(inheritedStateClass, options);
          mutateMetaData({ meta: meta, inheritedStateClass: inheritedStateClass, optionsWithInheritance: optionsWithInheritance });
          stateClass[META_OPTIONS_KEY] = optionsWithInheritance;
      };
  }
  function getStateOptions(inheritedStateClass, options) {
      var inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};
      return Object.assign(Object.assign({}, inheritanceOptions), options);
  }
  function mutateMetaData(params) {
      var meta = params.meta, inheritedStateClass = params.inheritedStateClass, optionsWithInheritance = params.optionsWithInheritance;
      var children = optionsWithInheritance.children, defaults = optionsWithInheritance.defaults, name = optionsWithInheritance.name;
      var stateName = typeof name === 'string' ? name : (name && name.getName()) || null;
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
          ensureStateNameIsValid(stateName);
      }
      if (inheritedStateClass.hasOwnProperty(META_KEY)) {
          var inheritedMeta = inheritedStateClass[META_KEY] || {};
          meta.actions = Object.assign(Object.assign({}, meta.actions), inheritedMeta.actions);
      }
      meta.children = children;
      meta.defaults = defaults;
      meta.name = stateName;
  }

  var DOLLAR_CHAR_CODE = 36;
  function createSelectObservable(selector) {
      if (!SelectFactory.store) {
          throwSelectFactoryNotConnectedError();
      }
      return SelectFactory.store.select(selector);
  }
  function createSelectorFn(name, rawSelector, paths) {
      if (paths === void 0) { paths = []; }
      rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;
      if (typeof rawSelector === 'string') {
          var propsArray = paths.length
              ? __spreadArray([rawSelector], __read(paths)) : rawSelector.split('.');
          return propGetter(propsArray, SelectFactory.config);
      }
      return rawSelector;
  }
  /**
   * @example If `foo$` => make it just `foo`
   */
  function removeDollarAtTheEnd(name) {
      var lastCharIndex = name.length - 1;
      var dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;
      return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;
  }

  /**
   * Decorator for selecting a slice of state from the store.
   */
  function Select(rawSelector) {
      var paths = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          paths[_i - 1] = arguments[_i];
      }
      return function (target, key) {
          var _a;
          var name = key.toString();
          var selectorId = "__" + name + "__selector";
          var selector = createSelectorFn(name, rawSelector, paths);
          Object.defineProperties(target, (_a = {},
              _a[selectorId] = {
                  writable: true,
                  enumerable: false,
                  configurable: true
              },
              _a[name] = {
                  enumerable: true,
                  configurable: true,
                  get: function () {
                      return this[selectorId] || (this[selectorId] = createSelectObservable(selector));
                  }
              },
              _a));
      };
  }

  var SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';
  var selectorOptionsMetaAccessor = {
      getOptions: function (target) {
          return (target && target[SELECTOR_OPTIONS_META_KEY]) || {};
      },
      defineOptions: function (target, options) {
          if (!target)
              return;
          target[SELECTOR_OPTIONS_META_KEY] = options;
      },
  };
  function setupSelectorMetadata(originalFn, creationMetadata) {
      var selectorMetaData = ensureSelectorMetadata$1(originalFn);
      selectorMetaData.originalFn = originalFn;
      var getExplicitSelectorOptions = function () { return ({}); };
      if (creationMetadata) {
          selectorMetaData.containerClass = creationMetadata.containerClass;
          selectorMetaData.selectorName = creationMetadata.selectorName || null;
          getExplicitSelectorOptions =
              creationMetadata.getSelectorOptions || getExplicitSelectorOptions;
      }
      var selectorMetaDataClone = Object.assign({}, selectorMetaData);
      selectorMetaData.getSelectorOptions = function () { return getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions()); };
      return selectorMetaData;
  }
  function getLocalSelectorOptions(selectorMetaData, explicitOptions) {
      return Object.assign(Object.assign(Object.assign(Object.assign({}, (selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {})), (selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {})), (selectorMetaData.getSelectorOptions() || {})), explicitOptions);
  }

  /**
   * Decorator for setting selector options at a method or class level.
   */
  function SelectorOptions(options) {
      return (function decorate(target, methodName, descriptor) {
          if (methodName) {
              descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, methodName));
              // Method Decorator
              var originalFn = descriptor.value || descriptor.originalFn;
              if (originalFn) {
                  selectorOptionsMetaAccessor.defineOptions(originalFn, options);
              }
          }
          else {
              // Class Decorator
              selectorOptionsMetaAccessor.defineOptions(target, options);
          }
      });
  }

  function ensureStoreMetadata(target) {
      return ensureStoreMetadata$1(target);
  }
  function getStoreMetadata(target) {
      return getStoreMetadata$1(target);
  }
  function ensureSelectorMetadata(target) {
      return ensureSelectorMetadata$1(target);
  }
  function getSelectorMetadata(target) {
      return getSelectorMetadata$1(target);
  }

  function createSelector(selectors, projector, creationMetadata) {
      var memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);
      var selectorMetaData = setupSelectorMetadata(projector, creationMetadata);
      selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);
      return memoizedFn;
  }

  function Selector(selectors) {
      return function (target, key, descriptor) {
          descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, key));
          var originalFn = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
          // Caretaker note: we have still left the `typeof` condition in order to avoid
          // creating a breaking change for projects that still use the View Engine.
          if (typeof ngDevMode === 'undefined' || ngDevMode) {
              if (originalFn && typeof originalFn !== 'function') {
                  throwSelectorDecoratorError();
              }
          }
          var memoizedFn = createSelector(selectors, originalFn, {
              containerClass: target,
              selectorName: key.toString(),
              getSelectorOptions: function () {
                  return {};
              },
          });
          var newDescriptor = {
              configurable: true,
              get: function () {
                  return memoizedFn;
              },
          };
          // Add hidden property to descriptor
          newDescriptor['originalFn'] = originalFn;
          return newDescriptor;
      };
  }

  var StateToken = /** @class */ (function () {
      function StateToken(name) {
          var _this = this;
          this.name = name;
          var selectorMetadata = ensureSelectorMetadata$1(this);
          selectorMetadata.makeRootSelector = function (runtimeContext) {
              return runtimeContext.getStateGetter(_this.name);
          };
      }
      StateToken.prototype.getName = function () {
          return this.name;
      };
      StateToken.prototype.toString = function () {
          return "StateToken[" + this.name + "]";
      };
      return StateToken;
  }());

  var NgxsDevelopmentModule = /** @class */ (function () {
      function NgxsDevelopmentModule() {
      }
      NgxsDevelopmentModule.forRoot = function (options) {
          return {
              ngModule: NgxsDevelopmentModule,
              providers: [
                  NgxsUnhandledActionsLogger,
                  { provide: NGXS_DEVELOPMENT_OPTIONS, useValue: options }
              ]
          };
      };
      return NgxsDevelopmentModule;
  }());
  /** @nocollapse */ NgxsDevelopmentModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsDevelopmentModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
  /** @nocollapse */ NgxsDevelopmentModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsDevelopmentModule });
  /** @nocollapse */ NgxsDevelopmentModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsDevelopmentModule });
  i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsDevelopmentModule, decorators: [{
              type: i0.NgModule
          }] });

  function ensureValidSelector(selector, context) {
      if (context === void 0) { context = {}; }
      var noun = context.noun || 'selector';
      var prefix = context.prefix ? context.prefix + ': ' : '';
      ensureValueProvided(selector, { noun: noun, prefix: context.prefix });
      var metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);
      if (!metadata) {
          throw new Error(prefix + "The value provided as the " + noun + " is not a valid selector.");
      }
  }
  function ensureValueProvided(value, context) {
      if (context === void 0) { context = {}; }
      var noun = context.noun || 'value';
      var prefix = context.prefix ? context.prefix + ': ' : '';
      if (!value) {
          throw new Error(prefix + "A " + noun + " must be provided.");
      }
  }

  function createModelSelector(selectorMap) {
      var selectorKeys = Object.keys(selectorMap);
      var selectors = Object.values(selectorMap);
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
          ensureValidSelectorMap({
              prefix: '[createModelSelector]',
              selectorMap: selectorMap,
              selectorKeys: selectorKeys,
              selectors: selectors
          });
      }
      return createSelector(selectors, function () {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
          }
          return selectorKeys.reduce(function (obj, key, index) {
              obj[key] = args[index];
              return obj;
          }, {});
      });
  }
  function ensureValidSelectorMap(_a) {
      var prefix = _a.prefix, selectorMap = _a.selectorMap, selectorKeys = _a.selectorKeys, selectors = _a.selectors;
      ensureValueProvided(selectorMap, { prefix: prefix, noun: 'selector map' });
      ensureValueProvided(typeof selectorMap === 'object', { prefix: prefix, noun: 'valid selector map' });
      ensureValueProvided(selectorKeys.length, { prefix: prefix, noun: 'non-empty selector map' });
      selectors.forEach(function (selector, index) { return ensureValidSelector(selector, {
          prefix: prefix,
          noun: "selector for the '" + selectorKeys[index] + "' property"
      }); });
  }

  function createPickSelector(selector, keys) {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
          ensureValidSelector(selector, { prefix: '[createPickSelector]' });
      }
      var validKeys = keys.filter(Boolean);
      var selectors = validKeys.map(function (key) { return createSelector([selector], function (s) { return s[key]; }); });
      return createSelector(__spreadArray([], __read(selectors)), function () {
          var props = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              props[_i] = arguments[_i];
          }
          return validKeys.reduce(function (acc, key, index) {
              acc[key] = props[index];
              return acc;
          }, {});
      });
  }

  function createPropertySelectors(parentSelector) {
      if (typeof ngDevMode === 'undefined' || ngDevMode) {
          ensureValidSelector(parentSelector, {
              prefix: '[createPropertySelectors]',
              noun: 'parent selector'
          });
      }
      var cache = {};
      return new Proxy({}, {
          get: function (_target, prop) {
              var selector = cache[prop] ||
                  createSelector([parentSelector], function (s) { return s === null || s === void 0 ? void 0 : s[prop]; });
              cache[prop] = selector;
              return selector;
          }
      });
  }

  /**
   * The public api for consumers of @ngxs/store
   */

  /**
   * Generated bundle index. Do not edit.
   */

  exports.Action = Action;
  exports.Actions = Actions;
  exports.InitState = InitState;
  exports.NGXS_PLUGINS = NGXS_PLUGINS;
  exports.NgxsDevelopmentModule = NgxsDevelopmentModule;
  exports.NgxsModule = NgxsModule;
  exports.NgxsSimpleChange = NgxsSimpleChange;
  exports.NgxsUnhandledActionsLogger = NgxsUnhandledActionsLogger;
  exports.NoopNgxsExecutionStrategy = NoopNgxsExecutionStrategy;
  exports.Select = Select;
  exports.Selector = Selector;
  exports.SelectorOptions = SelectorOptions;
  exports.State = State;
  exports.StateStream = StateStream;
  exports.StateToken = StateToken;
  exports.Store = Store;
  exports.UpdateState = UpdateState;
  exports.actionMatcher = actionMatcher;
  exports.createModelSelector = createModelSelector;
  exports.createPickSelector = createPickSelector;
  exports.createPropertySelectors = createPropertySelectors;
  exports.createSelector = createSelector;
  exports.ensureSelectorMetadata = ensureSelectorMetadata;
  exports.ensureStoreMetadata = ensureStoreMetadata;
  exports.getActionTypeFromInstance = getActionTypeFromInstance;
  exports.getSelectorMetadata = getSelectorMetadata;
  exports.getStoreMetadata = getStoreMetadata;
  exports.getValue = getValue;
  exports.ofAction = ofAction;
  exports.ofActionCanceled = ofActionCanceled;
  exports.ofActionCompleted = ofActionCompleted;
  exports.ofActionDispatched = ofActionDispatched;
  exports.ofActionErrored = ofActionErrored;
  exports.ofActionSuccessful = ofActionSuccessful;
  exports.setValue = setValue;
  exports["ɵNgxsFeatureModule"] = NgxsFeatureModule;
  exports["ɵNgxsRootModule"] = NgxsRootModule;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngxs-store.umd.js.map
