(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('@ngxs/store/operators', ['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ngxs = global.ngxs || {}, global.ngxs.store = global.ngxs.store || {}, global.ngxs.store.operators = {})));
})(this, (function (exports) { 'use strict';

    /**
     * @param items - Specific items to append to the end of an array
     */
    function append(items) {
        return function appendOperator(existing) {
            // If `items` is `undefined` or `null` or `[]` but `existing` is provided
            // just return `existing`
            var itemsNotProvidedButExistingIs = (!items || !items.length) && existing;
            if (itemsNotProvidedButExistingIs) {
                return existing;
            }
            if (Array.isArray(existing)) {
                return existing.concat(items);
            }
            // For example if some property is added dynamically
            // and didn't exist before thus it's not `ArrayLike`
            return items;
        };
    }

    function compose() {
        var operators = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operators[_i] = arguments[_i];
        }
        return function composeOperator(existing) {
            return operators.reduce(function (accumulator, operator) { return operator(accumulator); }, existing);
        };
    }

    function isStateOperator(value) {
        return typeof value === 'function';
    }
    function isUndefined(value) {
        return typeof value === 'undefined';
    }
    function isPredicate(value) {
        return typeof value === 'function';
    }
    function isNumber(value) {
        return typeof value === 'number';
    }
    function invalidIndex(index) {
        return Number.isNaN(index) || index === -1;
    }
    function isNil(value) {
        return value === null || isUndefined(value);
    }

    function retrieveValue(operatorOrValue, existing) {
        // If state operator is a function
        // then call it with an original value
        if (isStateOperator(operatorOrValue)) {
            var value = operatorOrValue(existing);
            return value;
        }
        // If operator or value was not provided
        // e.g. `elseOperatorOrValue` is `undefined`
        // then we just return an original value
        if (isUndefined(operatorOrValue)) {
            return existing;
        }
        return operatorOrValue;
    }
    /**
     * @param condition - Condition can be a plain boolean value or a function,
     * that returns boolean, also this function can take a value as an argument
     * to which this state operator applies
     * @param trueOperatorOrValue - Any value or a state operator
     * @param elseOperatorOrValue - Any value or a state operator
     */
    function iif(condition, trueOperatorOrValue, elseOperatorOrValue) {
        return function iifOperator(existing) {
            // Convert the value to a boolean
            var result = !!condition;
            // but if it is a function then run it to get the result
            if (isPredicate(condition)) {
                result = condition(existing);
            }
            if (result) {
                return retrieveValue(trueOperatorOrValue, existing);
            }
            return retrieveValue(elseOperatorOrValue, existing);
        };
    }

    /**
     * @param value - Value to insert
     * @param [beforePosition] -  Specified index to insert value before, optional
     */
    function insertItem(value, beforePosition) {
        return function insertItemOperator(existing) {
            // Have to check explicitly for `null` and `undefined`
            // because `value` can be `0`, thus `!value` will return `true`
            if (isNil(value) && existing) {
                return existing;
            }
            // Property may be dynamic and might not existed before
            if (!Array.isArray(existing)) {
                return [value];
            }
            var clone = existing.slice();
            var index = 0;
            // No need to call `isNumber`
            // as we are checking `> 0` not `>= 0`
            // everything except number will return false here
            if (beforePosition > 0) {
                index = beforePosition;
            }
            clone.splice(index, 0, value);
            return clone;
        };
    }

    function patch(patchObject) {
        return function patchStateOperator(existing) {
            var clone = null;
            for (var k in patchObject) {
                var newValue = patchObject[k];
                var existingPropValue = existing === null || existing === void 0 ? void 0 : existing[k];
                var newPropValue = isStateOperator(newValue)
                    ? newValue(existingPropValue)
                    : newValue;
                if (newPropValue !== existingPropValue) {
                    if (!clone) {
                        clone = Object.assign({}, existing);
                    }
                    clone[k] = newPropValue;
                }
            }
            return clone || existing;
        };
    }

    /**
     * @param selector - Index of item in the array or a predicate function
     * that can be provided in `Array.prototype.findIndex`
     * @param operatorOrValue - New value under the `selector` index or a
     * function that can be applied to an existing value
     */
    function updateItem(selector, operatorOrValue) {
        return function updateItemOperator(existing) {
            var index = -1;
            if (isPredicate(selector)) {
                index = existing.findIndex(selector);
            }
            else if (isNumber(selector)) {
                index = selector;
            }
            if (invalidIndex(index)) {
                return existing;
            }
            var value = null;
            // Need to check if the new item value will change the existing item value
            // then, only if it will change it then clone the array and set the item
            var theOperatorOrValue = operatorOrValue;
            if (isStateOperator(theOperatorOrValue)) {
                value = theOperatorOrValue(existing[index]);
            }
            else {
                value = theOperatorOrValue;
            }
            // If the value hasn't been mutated
            // then we just return `existing` array
            if (value === existing[index]) {
                return existing;
            }
            var clone = existing.slice();
            clone[index] = value;
            return clone;
        };
    }

    /**
     * @param selector - index or predicate to remove an item from an array by
     */
    function removeItem(selector) {
        return function removeItemOperator(existing) {
            var index = -1;
            if (isPredicate(selector)) {
                index = existing.findIndex(selector);
            }
            else if (isNumber(selector)) {
                index = selector;
            }
            if (invalidIndex(index)) {
                return existing;
            }
            var clone = existing.slice();
            clone.splice(index, 1);
            return clone;
        };
    }

    /**
     * @module
     * @description
     * Entry point for all public APIs of this package.
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.append = append;
    exports.compose = compose;
    exports.iif = iif;
    exports.insertItem = insertItem;
    exports.isPredicate = isPredicate;
    exports.isStateOperator = isStateOperator;
    exports.patch = patch;
    exports.removeItem = removeItem;
    exports.updateItem = updateItem;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngxs-store-operators.umd.js.map
