import { memoize } from '@ngxs/store/internals';
import { getSelectorMetadata, getStoreMetadata, } from '../internal/internals';
export function createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {
    return (context) => {
        const { argumentSelectorFunctions, selectorOptions } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);
        return function selectFromRoot(rootState) {
            // Determine arguments from the app state using the selectors
            const results = argumentSelectorFunctions.map((argFn) => argFn(rootState));
            // if the lambda tries to access a something on the
            // state that doesn't exist, it will throw a TypeError.
            // since this is quite usual behaviour, we simply return undefined if so.
            try {
                return memoizedSelectorFn(...results);
            }
            catch (ex) {
                if (ex instanceof TypeError && selectorOptions.suppressErrors) {
                    return undefined;
                }
                throw ex;
            }
        };
    };
}
export function createMemoizedSelectorFn(originalFn, creationMetadata) {
    const containerClass = creationMetadata && creationMetadata.containerClass;
    const wrappedFn = function wrappedSelectorFn(...args) {
        const returnValue = originalFn.apply(containerClass, args);
        if (returnValue instanceof Function) {
            const innerMemoizedFn = memoize.apply(null, [returnValue]);
            return innerMemoizedFn;
        }
        return returnValue;
    };
    const memoizedFn = memoize(wrappedFn);
    Object.setPrototypeOf(memoizedFn, originalFn);
    return memoizedFn;
}
function getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {
    const localSelectorOptions = selectorMetaData.getSelectorOptions();
    const selectorOptions = context.getSelectorOptions(localSelectorOptions);
    const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);
    const argumentSelectorFunctions = selectorsToApply.map((selector) => {
        const factory = getRootSelectorFactory(selector);
        return factory(context);
    });
    return {
        selectorOptions,
        argumentSelectorFunctions,
    };
}
function getSelectorsToApply(selectors = [], selectorOptions, containerClass) {
    const selectorsToApply = [];
    const canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;
    if (containerClass && canInjectContainerState) {
        // If we are on a state class, add it as the first selector parameter
        const metadata = getStoreMetadata(containerClass);
        if (metadata) {
            selectorsToApply.push(containerClass);
        }
    }
    if (selectors) {
        selectorsToApply.push(...selectors);
    }
    return selectorsToApply;
}
/**
 * This function gets the factory function to create the selector to get the selected slice from the app state
 * @ignore
 */
export function getRootSelectorFactory(selector) {
    const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);
    return (metadata && metadata.makeRootSelector) || (() => selector);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0b3ItdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9zdG9yZS9zcmMvc2VsZWN0b3JzL3NlbGVjdG9yLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVoRCxPQUFPLEVBQ0wsbUJBQW1CLEVBQ25CLGdCQUFnQixHQUtqQixNQUFNLHVCQUF1QixDQUFDO0FBRy9CLE1BQU0sVUFBVSx5QkFBeUIsQ0FDdkMsZ0JBQXVDLEVBQ3ZDLFNBQTRCLEVBQzVCLGtCQUFxQjtJQUVyQixPQUFPLENBQUMsT0FBK0IsRUFBRSxFQUFFO1FBQ3pDLE1BQU0sRUFBRSx5QkFBeUIsRUFBRSxlQUFlLEVBQUUsR0FBRyxzQkFBc0IsQ0FDM0UsT0FBTyxFQUNQLGdCQUFnQixFQUNoQixTQUFTLENBQ1YsQ0FBQztRQUVGLE9BQU8sU0FBUyxjQUFjLENBQUMsU0FBYztZQUMzQyw2REFBNkQ7WUFDN0QsTUFBTSxPQUFPLEdBQUcseUJBQXlCLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUUzRSxtREFBbUQ7WUFDbkQsdURBQXVEO1lBQ3ZELHlFQUF5RTtZQUN6RSxJQUFJO2dCQUNGLE9BQU8sa0JBQWtCLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQzthQUN2QztZQUFDLE9BQU8sRUFBRSxFQUFFO2dCQUNYLElBQUksRUFBRSxZQUFZLFNBQVMsSUFBSSxlQUFlLENBQUMsY0FBYyxFQUFFO29CQUM3RCxPQUFPLFNBQVMsQ0FBQztpQkFDbEI7Z0JBRUQsTUFBTSxFQUFFLENBQUM7YUFDVjtRQUNILENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFVBQVUsd0JBQXdCLENBQ3RDLFVBQWEsRUFDYixnQkFBdUQ7SUFFdkQsTUFBTSxjQUFjLEdBQUcsZ0JBQWdCLElBQUksZ0JBQWdCLENBQUMsY0FBYyxDQUFDO0lBQzNFLE1BQU0sU0FBUyxHQUFHLFNBQVMsaUJBQWlCLENBQUMsR0FBRyxJQUFXO1FBQ3pELE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzNELElBQUksV0FBVyxZQUFZLFFBQVEsRUFBRTtZQUNuQyxNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFDM0QsT0FBTyxlQUFlLENBQUM7U0FDeEI7UUFDRCxPQUFPLFdBQVcsQ0FBQztJQUNyQixDQUFNLENBQUM7SUFDUCxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDdEMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDOUMsT0FBTyxVQUFVLENBQUM7QUFDcEIsQ0FBQztBQUVELFNBQVMsc0JBQXNCLENBQzdCLE9BQStCLEVBQy9CLGdCQUF1QyxFQUN2QyxZQUErQixFQUFFO0lBRWpDLE1BQU0sb0JBQW9CLEdBQUcsZ0JBQWdCLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUNuRSxNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsa0JBQWtCLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUN6RSxNQUFNLGdCQUFnQixHQUFHLG1CQUFtQixDQUMxQyxTQUFTLEVBQ1QsZUFBZSxFQUNmLGdCQUFnQixDQUFDLGNBQWMsQ0FDaEMsQ0FBQztJQUVGLE1BQU0seUJBQXlCLEdBQUcsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7UUFDbEUsTUFBTSxPQUFPLEdBQUcsc0JBQXNCLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDakQsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDMUIsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPO1FBQ0wsZUFBZTtRQUNmLHlCQUF5QjtLQUMxQixDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsbUJBQW1CLENBQzFCLFlBQStCLEVBQUUsRUFDakMsZUFBc0MsRUFDdEMsY0FBbUI7SUFFbkIsTUFBTSxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7SUFDNUIsTUFBTSx1QkFBdUIsR0FDM0IsU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksZUFBZSxDQUFDLG9CQUFvQixDQUFDO0lBQ2pFLElBQUksY0FBYyxJQUFJLHVCQUF1QixFQUFFO1FBQzdDLHFFQUFxRTtRQUNyRSxNQUFNLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUNsRCxJQUFJLFFBQVEsRUFBRTtZQUNaLGdCQUFnQixDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUN2QztLQUNGO0lBQ0QsSUFBSSxTQUFTLEVBQUU7UUFDYixnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztLQUNyQztJQUNELE9BQU8sZ0JBQWdCLENBQUM7QUFDMUIsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxzQkFBc0IsQ0FBQyxRQUFhO0lBQ2xELE1BQU0sUUFBUSxHQUFHLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxJQUFJLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdFLE9BQU8sQ0FBQyxRQUFRLElBQUksUUFBUSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNyRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XG5cbmltcG9ydCB7XG4gIGdldFNlbGVjdG9yTWV0YWRhdGEsXG4gIGdldFN0b3JlTWV0YWRhdGEsXG4gIFNlbGVjdG9yTWV0YURhdGFNb2RlbCxcbiAgU2hhcmVkU2VsZWN0b3JPcHRpb25zLFxuICBSdW50aW1lU2VsZWN0b3JDb250ZXh0LFxuICBTZWxlY3RvckZhY3RvcnksXG59IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XG5pbXBvcnQgeyBDcmVhdGlvbk1ldGFkYXRhLCBSdW50aW1lU2VsZWN0b3JJbmZvIH0gZnJvbSAnLi9zZWxlY3Rvci1tb2RlbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm9vdFNlbGVjdG9yRmFjdG9yeTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuICBzZWxlY3Rvck1ldGFEYXRhOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwsXG4gIHNlbGVjdG9yczogYW55W10gfCB1bmRlZmluZWQsXG4gIG1lbW9pemVkU2VsZWN0b3JGbjogVFxuKTogU2VsZWN0b3JGYWN0b3J5IHtcbiAgcmV0dXJuIChjb250ZXh0OiBSdW50aW1lU2VsZWN0b3JDb250ZXh0KSA9PiB7XG4gICAgY29uc3QgeyBhcmd1bWVudFNlbGVjdG9yRnVuY3Rpb25zLCBzZWxlY3Rvck9wdGlvbnMgfSA9IGdldFJ1bnRpbWVTZWxlY3RvckluZm8oXG4gICAgICBjb250ZXh0LFxuICAgICAgc2VsZWN0b3JNZXRhRGF0YSxcbiAgICAgIHNlbGVjdG9yc1xuICAgICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc2VsZWN0RnJvbVJvb3Qocm9vdFN0YXRlOiBhbnkpIHtcbiAgICAgIC8vIERldGVybWluZSBhcmd1bWVudHMgZnJvbSB0aGUgYXBwIHN0YXRlIHVzaW5nIHRoZSBzZWxlY3RvcnNcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhcmd1bWVudFNlbGVjdG9yRnVuY3Rpb25zLm1hcCgoYXJnRm4pID0+IGFyZ0ZuKHJvb3RTdGF0ZSkpO1xuXG4gICAgICAvLyBpZiB0aGUgbGFtYmRhIHRyaWVzIHRvIGFjY2VzcyBhIHNvbWV0aGluZyBvbiB0aGVcbiAgICAgIC8vIHN0YXRlIHRoYXQgZG9lc24ndCBleGlzdCwgaXQgd2lsbCB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIC8vIHNpbmNlIHRoaXMgaXMgcXVpdGUgdXN1YWwgYmVoYXZpb3VyLCB3ZSBzaW1wbHkgcmV0dXJuIHVuZGVmaW5lZCBpZiBzby5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yRm4oLi4ucmVzdWx0cyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgc2VsZWN0b3JPcHRpb25zLnN1cHByZXNzRXJyb3JzKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVNZW1vaXplZFNlbGVjdG9yRm48VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbiAgb3JpZ2luYWxGbjogVCxcbiAgY3JlYXRpb25NZXRhZGF0YTogUGFydGlhbDxDcmVhdGlvbk1ldGFkYXRhPiB8IHVuZGVmaW5lZFxuKSB7XG4gIGNvbnN0IGNvbnRhaW5lckNsYXNzID0gY3JlYXRpb25NZXRhZGF0YSAmJiBjcmVhdGlvbk1ldGFkYXRhLmNvbnRhaW5lckNsYXNzO1xuICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiB3cmFwcGVkU2VsZWN0b3JGbiguLi5hcmdzOiBhbnlbXSkge1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gb3JpZ2luYWxGbi5hcHBseShjb250YWluZXJDbGFzcywgYXJncyk7XG4gICAgaWYgKHJldHVyblZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGNvbnN0IGlubmVyTWVtb2l6ZWRGbiA9IG1lbW9pemUuYXBwbHkobnVsbCwgW3JldHVyblZhbHVlXSk7XG4gICAgICByZXR1cm4gaW5uZXJNZW1vaXplZEZuO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH0gYXMgVDtcbiAgY29uc3QgbWVtb2l6ZWRGbiA9IG1lbW9pemUod3JhcHBlZEZuKTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG1lbW9pemVkRm4sIG9yaWdpbmFsRm4pO1xuICByZXR1cm4gbWVtb2l6ZWRGbjtcbn1cblxuZnVuY3Rpb24gZ2V0UnVudGltZVNlbGVjdG9ySW5mbyhcbiAgY29udGV4dDogUnVudGltZVNlbGVjdG9yQ29udGV4dCxcbiAgc2VsZWN0b3JNZXRhRGF0YTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsLFxuICBzZWxlY3RvcnM6IGFueVtdIHwgdW5kZWZpbmVkID0gW11cbik6IFJ1bnRpbWVTZWxlY3RvckluZm8ge1xuICBjb25zdCBsb2NhbFNlbGVjdG9yT3B0aW9ucyA9IHNlbGVjdG9yTWV0YURhdGEuZ2V0U2VsZWN0b3JPcHRpb25zKCk7XG4gIGNvbnN0IHNlbGVjdG9yT3B0aW9ucyA9IGNvbnRleHQuZ2V0U2VsZWN0b3JPcHRpb25zKGxvY2FsU2VsZWN0b3JPcHRpb25zKTtcbiAgY29uc3Qgc2VsZWN0b3JzVG9BcHBseSA9IGdldFNlbGVjdG9yc1RvQXBwbHkoXG4gICAgc2VsZWN0b3JzLFxuICAgIHNlbGVjdG9yT3B0aW9ucyxcbiAgICBzZWxlY3Rvck1ldGFEYXRhLmNvbnRhaW5lckNsYXNzXG4gICk7XG5cbiAgY29uc3QgYXJndW1lbnRTZWxlY3RvckZ1bmN0aW9ucyA9IHNlbGVjdG9yc1RvQXBwbHkubWFwKChzZWxlY3RvcikgPT4ge1xuICAgIGNvbnN0IGZhY3RvcnkgPSBnZXRSb290U2VsZWN0b3JGYWN0b3J5KHNlbGVjdG9yKTtcbiAgICByZXR1cm4gZmFjdG9yeShjb250ZXh0KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc2VsZWN0b3JPcHRpb25zLFxuICAgIGFyZ3VtZW50U2VsZWN0b3JGdW5jdGlvbnMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yc1RvQXBwbHkoXG4gIHNlbGVjdG9yczogYW55W10gfCB1bmRlZmluZWQgPSBbXSxcbiAgc2VsZWN0b3JPcHRpb25zOiBTaGFyZWRTZWxlY3Rvck9wdGlvbnMsXG4gIGNvbnRhaW5lckNsYXNzOiBhbnlcbikge1xuICBjb25zdCBzZWxlY3RvcnNUb0FwcGx5ID0gW107XG4gIGNvbnN0IGNhbkluamVjdENvbnRhaW5lclN0YXRlID1cbiAgICBzZWxlY3RvcnMubGVuZ3RoID09PSAwIHx8IHNlbGVjdG9yT3B0aW9ucy5pbmplY3RDb250YWluZXJTdGF0ZTtcbiAgaWYgKGNvbnRhaW5lckNsYXNzICYmIGNhbkluamVjdENvbnRhaW5lclN0YXRlKSB7XG4gICAgLy8gSWYgd2UgYXJlIG9uIGEgc3RhdGUgY2xhc3MsIGFkZCBpdCBhcyB0aGUgZmlyc3Qgc2VsZWN0b3IgcGFyYW1ldGVyXG4gICAgY29uc3QgbWV0YWRhdGEgPSBnZXRTdG9yZU1ldGFkYXRhKGNvbnRhaW5lckNsYXNzKTtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgIHNlbGVjdG9yc1RvQXBwbHkucHVzaChjb250YWluZXJDbGFzcyk7XG4gICAgfVxuICB9XG4gIGlmIChzZWxlY3RvcnMpIHtcbiAgICBzZWxlY3RvcnNUb0FwcGx5LnB1c2goLi4uc2VsZWN0b3JzKTtcbiAgfVxuICByZXR1cm4gc2VsZWN0b3JzVG9BcHBseTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGdldHMgdGhlIGZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBzZWxlY3RvciB0byBnZXQgdGhlIHNlbGVjdGVkIHNsaWNlIGZyb20gdGhlIGFwcCBzdGF0ZVxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um9vdFNlbGVjdG9yRmFjdG9yeShzZWxlY3RvcjogYW55KTogU2VsZWN0b3JGYWN0b3J5IHtcbiAgY29uc3QgbWV0YWRhdGEgPSBnZXRTZWxlY3Rvck1ldGFkYXRhKHNlbGVjdG9yKSB8fCBnZXRTdG9yZU1ldGFkYXRhKHNlbGVjdG9yKTtcbiAgcmV0dXJuIChtZXRhZGF0YSAmJiBtZXRhZGF0YS5tYWtlUm9vdFNlbGVjdG9yKSB8fCAoKCkgPT4gc2VsZWN0b3IpO1xufVxuIl19