import { ErrorHandler, Injectable, Injector } from '@angular/core';
import { Observable } from 'rxjs';
import { leaveNgxs } from '../operators/leave-ngxs';
import * as i0 from "@angular/core";
/**
 * This operator is used for piping the observable result
 * from the `dispatch()`. It has a "smart" error handling
 * strategy that allows us to decide whether we propagate
 * errors to Angular's `ErrorHandler` or enable users to
 * handle them manually. We consider following cases:
 * 1) `store.dispatch()` (no subscribe) -> call `handleError()`
 * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`
 * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`
 * 4) `toPromise()` without `catch` -> do `handleError()`
 * 5) `toPromise()` with `catch` -> don't `handleError()`
 */
export function ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {
    return (source) => {
        let subscribed = false;
        source.subscribe({
            error: error => {
                // Do not trigger change detection for a microtask. This depends on the execution
                // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`
                // leaves the Angular zone.
                ngxsExecutionStrategy.enter(() => Promise.resolve().then(() => {
                    if (!subscribed) {
                        ngxsExecutionStrategy.leave(() => internalErrorReporter.reportErrorSafely(error));
                    }
                }));
            }
        });
        return new Observable(subscriber => {
            subscribed = true;
            return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);
        });
    };
}
export class InternalErrorReporter {
    constructor(_injector) {
        this._injector = _injector;
        /** Will be set lazily to be backward compatible. */
        this._errorHandler = null;
    }
    reportErrorSafely(error) {
        if (this._errorHandler === null) {
            this._errorHandler = this._injector.get(ErrorHandler);
        }
        // The `try-catch` is used to avoid handling the error twice. Suppose we call
        // `handleError` which re-throws the error internally. The re-thrown error will
        // be caught by zone.js which will then get to the `zone.onError.emit()` and the
        // `onError` subscriber will call `handleError` again.
        try {
            this._errorHandler.handleError(error);
        }
        catch (_a) { }
    }
}
/** @nocollapse */ InternalErrorReporter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: InternalErrorReporter, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ InternalErrorReporter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: InternalErrorReporter, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: InternalErrorReporter, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3ItaGFuZGxlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3N0b3JlL3NyYy9pbnRlcm5hbC9lcnJvci1oYW5kbGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRWxDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7QUFHcEQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQzlCLHFCQUE0QyxFQUM1QyxxQkFBNEM7SUFFNUMsT0FBTyxDQUFDLE1BQXFCLEVBQUUsRUFBRTtRQUMvQixJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUM7UUFFdkIsTUFBTSxDQUFDLFNBQVMsQ0FBQztZQUNmLEtBQUssRUFBRSxLQUFLLENBQUMsRUFBRTtnQkFDYixpRkFBaUY7Z0JBQ2pGLGtGQUFrRjtnQkFDbEYsMkJBQTJCO2dCQUMzQixxQkFBcUIsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQy9CLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFO29CQUMxQixJQUFJLENBQUMsVUFBVSxFQUFFO3dCQUNmLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FDL0IscUJBQXFCLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQy9DLENBQUM7cUJBQ0g7Z0JBQ0gsQ0FBQyxDQUFDLENBQ0gsQ0FBQztZQUNKLENBQUM7U0FDRixDQUFDLENBQUM7UUFFSCxPQUFPLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ2pDLFVBQVUsR0FBRyxJQUFJLENBQUM7WUFDbEIsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzdFLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUdELE1BQU0sT0FBTyxxQkFBcUI7SUFJaEMsWUFBb0IsU0FBbUI7UUFBbkIsY0FBUyxHQUFULFNBQVMsQ0FBVTtRQUh2QyxvREFBb0Q7UUFDNUMsa0JBQWEsR0FBaUIsSUFBSyxDQUFDO0lBRUYsQ0FBQztJQUUzQyxpQkFBaUIsQ0FBQyxLQUFVO1FBQzFCLElBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxJQUFJLEVBQUU7WUFDL0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUN2RDtRQUNELDZFQUE2RTtRQUM3RSwrRUFBK0U7UUFDL0UsZ0ZBQWdGO1FBQ2hGLHNEQUFzRDtRQUN0RCxJQUFJO1lBQ0YsSUFBSSxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdkM7UUFBQyxXQUFNLEdBQUU7SUFDWixDQUFDOztzSUFqQlUscUJBQXFCOzBJQUFyQixxQkFBcUIsY0FEUixNQUFNOzRGQUNuQixxQkFBcUI7a0JBRGpDLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXJyb3JIYW5kbGVyLCBJbmplY3RhYmxlLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBsZWF2ZU5neHMgfSBmcm9tICcuLi9vcGVyYXRvcnMvbGVhdmUtbmd4cyc7XG5pbXBvcnQgeyBOZ3hzRXhlY3V0aW9uU3RyYXRlZ3kgfSBmcm9tICcuLi9leGVjdXRpb24vc3ltYm9scyc7XG5cbi8qKlxuICogVGhpcyBvcGVyYXRvciBpcyB1c2VkIGZvciBwaXBpbmcgdGhlIG9ic2VydmFibGUgcmVzdWx0XG4gKiBmcm9tIHRoZSBgZGlzcGF0Y2goKWAuIEl0IGhhcyBhIFwic21hcnRcIiBlcnJvciBoYW5kbGluZ1xuICogc3RyYXRlZ3kgdGhhdCBhbGxvd3MgdXMgdG8gZGVjaWRlIHdoZXRoZXIgd2UgcHJvcGFnYXRlXG4gKiBlcnJvcnMgdG8gQW5ndWxhcidzIGBFcnJvckhhbmRsZXJgIG9yIGVuYWJsZSB1c2VycyB0b1xuICogaGFuZGxlIHRoZW0gbWFudWFsbHkuIFdlIGNvbnNpZGVyIGZvbGxvd2luZyBjYXNlczpcbiAqIDEpIGBzdG9yZS5kaXNwYXRjaCgpYCAobm8gc3Vic2NyaWJlKSAtPiBjYWxsIGBoYW5kbGVFcnJvcigpYFxuICogMikgYHN0b3JlLmRpc3BhdGNoKCkuc3Vic2NyaWJlKClgIChubyBlcnJvciBjYWxsYmFjaykgLT4gY2FsbCBgaGFuZGxlRXJyb3IoKWBcbiAqIDMpIGBzdG9yZS5kaXNwYXRjaCgpLnN1YnNjcmliZSh7IGVycm9yOiAuLi4gfSlgIC0+IGRvbid0IGNhbGwgYGhhbmRsZUVycm9yKClgXG4gKiA0KSBgdG9Qcm9taXNlKClgIHdpdGhvdXQgYGNhdGNoYCAtPiBkbyBgaGFuZGxlRXJyb3IoKWBcbiAqIDUpIGB0b1Byb21pc2UoKWAgd2l0aCBgY2F0Y2hgIC0+IGRvbid0IGBoYW5kbGVFcnJvcigpYFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmd4c0Vycm9ySGFuZGxlcjxUPihcbiAgaW50ZXJuYWxFcnJvclJlcG9ydGVyOiBJbnRlcm5hbEVycm9yUmVwb3J0ZXIsXG4gIG5neHNFeGVjdXRpb25TdHJhdGVneTogTmd4c0V4ZWN1dGlvblN0cmF0ZWd5XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHtcbiAgICBsZXQgc3Vic2NyaWJlZCA9IGZhbHNlO1xuXG4gICAgc291cmNlLnN1YnNjcmliZSh7XG4gICAgICBlcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICAvLyBEbyBub3QgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIGZvciBhIG1pY3JvdGFzay4gVGhpcyBkZXBlbmRzIG9uIHRoZSBleGVjdXRpb25cbiAgICAgICAgLy8gc3RyYXRlZ3kgYmVpbmcgdXNlZCwgYnV0IHRoZSBkZWZhdWx0IGBEaXNwYXRjaE91dHNpZGVab25lTmd4c0V4ZWN1dGlvblN0cmF0ZWd5YFxuICAgICAgICAvLyBsZWF2ZXMgdGhlIEFuZ3VsYXIgem9uZS5cbiAgICAgICAgbmd4c0V4ZWN1dGlvblN0cmF0ZWd5LmVudGVyKCgpID0+XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgbmd4c0V4ZWN1dGlvblN0cmF0ZWd5LmxlYXZlKCgpID0+XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxFcnJvclJlcG9ydGVyLnJlcG9ydEVycm9yU2FmZWx5KGVycm9yKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlciA9PiB7XG4gICAgICBzdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzb3VyY2UucGlwZShsZWF2ZU5neHMobmd4c0V4ZWN1dGlvblN0cmF0ZWd5KSkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH0pO1xuICB9O1xufVxuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEludGVybmFsRXJyb3JSZXBvcnRlciB7XG4gIC8qKiBXaWxsIGJlIHNldCBsYXppbHkgdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZS4gKi9cbiAgcHJpdmF0ZSBfZXJyb3JIYW5kbGVyOiBFcnJvckhhbmRsZXIgPSBudWxsITtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IpIHt9XG5cbiAgcmVwb3J0RXJyb3JTYWZlbHkoZXJyb3I6IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9lcnJvckhhbmRsZXIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2Vycm9ySGFuZGxlciA9IHRoaXMuX2luamVjdG9yLmdldChFcnJvckhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBUaGUgYHRyeS1jYXRjaGAgaXMgdXNlZCB0byBhdm9pZCBoYW5kbGluZyB0aGUgZXJyb3IgdHdpY2UuIFN1cHBvc2Ugd2UgY2FsbFxuICAgIC8vIGBoYW5kbGVFcnJvcmAgd2hpY2ggcmUtdGhyb3dzIHRoZSBlcnJvciBpbnRlcm5hbGx5LiBUaGUgcmUtdGhyb3duIGVycm9yIHdpbGxcbiAgICAvLyBiZSBjYXVnaHQgYnkgem9uZS5qcyB3aGljaCB3aWxsIHRoZW4gZ2V0IHRvIHRoZSBgem9uZS5vbkVycm9yLmVtaXQoKWAgYW5kIHRoZVxuICAgIC8vIGBvbkVycm9yYCBzdWJzY3JpYmVyIHdpbGwgY2FsbCBgaGFuZGxlRXJyb3JgIGFnYWluLlxuICAgIHRyeSB7XG4gICAgICB0aGlzLl9lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgIH0gY2F0Y2gge31cbiAgfVxufVxuIl19