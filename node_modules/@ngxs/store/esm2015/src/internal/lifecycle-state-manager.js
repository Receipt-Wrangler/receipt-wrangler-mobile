import { Injectable } from '@angular/core';
import { NgxsBootstrapper } from '@ngxs/store/internals';
import { EMPTY, Subject } from 'rxjs';
import { catchError, filter, mergeMap, pairwise, startWith, takeUntil, tap } from 'rxjs/operators';
import { Store } from '../store';
import { getValue } from '../utils/utils';
import { InternalErrorReporter } from './error-handler';
import { StateContextFactory } from './state-context-factory';
import { InternalStateOperations } from './state-operations';
import { NgxsSimpleChange } from '../symbols';
import * as i0 from "@angular/core";
import * as i1 from "../store";
import * as i2 from "./error-handler";
import * as i3 from "./state-operations";
import * as i4 from "./state-context-factory";
import * as i5 from "@ngxs/store/internals";
export class LifecycleStateManager {
    constructor(_store, _internalErrorReporter, _internalStateOperations, _stateContextFactory, _bootstrapper) {
        this._store = _store;
        this._internalErrorReporter = _internalErrorReporter;
        this._internalStateOperations = _internalStateOperations;
        this._stateContextFactory = _stateContextFactory;
        this._bootstrapper = _bootstrapper;
        this._destroy$ = new Subject();
    }
    ngOnDestroy() {
        this._destroy$.next();
    }
    ngxsBootstrap(action, results) {
        this._internalStateOperations
            .getRootStateOperations()
            .dispatch(action)
            .pipe(filter(() => !!results), tap(() => this._invokeInitOnStates(results.states)), mergeMap(() => this._bootstrapper.appBootstrapped$), filter(appBootstrapped => !!appBootstrapped), catchError(error => {
            // The `SafeSubscriber` (which is used by most RxJS operators) re-throws
            // errors asynchronously (`setTimeout(() => { throw error })`). This might
            // break existing user's code or unit tests. We catch the error manually to
            // be backward compatible with the old behavior.
            this._internalErrorReporter.reportErrorSafely(error);
            return EMPTY;
        }), takeUntil(this._destroy$))
            .subscribe(() => this._invokeBootstrapOnStates(results.states));
    }
    _invokeInitOnStates(mappedStores) {
        for (const mappedStore of mappedStores) {
            const instance = mappedStore.instance;
            if (instance.ngxsOnChanges) {
                this._store
                    .select(state => getValue(state, mappedStore.path))
                    .pipe(startWith(undefined), pairwise(), takeUntil(this._destroy$))
                    .subscribe(([previousValue, currentValue]) => {
                    const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);
                    instance.ngxsOnChanges(change);
                });
            }
            if (instance.ngxsOnInit) {
                instance.ngxsOnInit(this._getStateContext(mappedStore));
            }
            mappedStore.isInitialised = true;
        }
    }
    _invokeBootstrapOnStates(mappedStores) {
        for (const mappedStore of mappedStores) {
            const instance = mappedStore.instance;
            if (instance.ngxsAfterBootstrap) {
                instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));
            }
        }
    }
    _getStateContext(mappedStore) {
        return this._stateContextFactory.createStateContext(mappedStore);
    }
}
/** @nocollapse */ LifecycleStateManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: LifecycleStateManager, deps: [{ token: i1.Store }, { token: i2.InternalErrorReporter }, { token: i3.InternalStateOperations }, { token: i4.StateContextFactory }, { token: i5.NgxsBootstrapper }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ LifecycleStateManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: LifecycleStateManager, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: LifecycleStateManager, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.Store }, { type: i2.InternalErrorReporter }, { type: i3.InternalStateOperations }, { type: i4.StateContextFactory }, { type: i5.NgxsBootstrapper }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlmZWN5Y2xlLXN0YXRlLW1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9zdG9yZS9zcmMvaW50ZXJuYWwvbGlmZWN5Y2xlLXN0YXRlLW1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0QyxPQUFPLEVBQ0wsVUFBVSxFQUNWLE1BQU0sRUFDTixRQUFRLEVBQ1IsUUFBUSxFQUNSLFNBQVMsRUFDVCxTQUFTLEVBQ1QsR0FBRyxFQUNKLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEIsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUNqQyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUMsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDeEQsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDOUQsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFN0QsT0FBTyxFQUFpQixnQkFBZ0IsRUFBZ0IsTUFBTSxZQUFZLENBQUM7Ozs7Ozs7QUFHM0UsTUFBTSxPQUFPLHFCQUFxQjtJQUdoQyxZQUNVLE1BQWEsRUFDYixzQkFBNkMsRUFDN0Msd0JBQWlELEVBQ2pELG9CQUF5QyxFQUN6QyxhQUErQjtRQUovQixXQUFNLEdBQU4sTUFBTSxDQUFPO1FBQ2IsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUF1QjtRQUM3Qyw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQXlCO1FBQ2pELHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBcUI7UUFDekMsa0JB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QUNuRSxDQUFDOztzSUExRVUscUJBQXFCOzBJQUFyQixxQkFBcUIsY0FEUixNQUFNOzRGQUNuQixxQkFBcUI7a0JBRGpDLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ3hzQm9vdHN0cmFwcGVyIH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcbmltcG9ydCB7IEVNUFRZLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBmaWx0ZXIsXG4gIG1lcmdlTWFwLFxuICBwYWlyd2lzZSxcbiAgc3RhcnRXaXRoLFxuICB0YWtlVW50aWwsXG4gIHRhcFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnLi4vc3RvcmUnO1xuaW1wb3J0IHsgZ2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgeyBJbnRlcm5hbEVycm9yUmVwb3J0ZXIgfSBmcm9tICcuL2Vycm9yLWhhbmRsZXInO1xuaW1wb3J0IHsgU3RhdGVDb250ZXh0RmFjdG9yeSB9IGZyb20gJy4vc3RhdGUtY29udGV4dC1mYWN0b3J5JztcbmltcG9ydCB7IEludGVybmFsU3RhdGVPcGVyYXRpb25zIH0gZnJvbSAnLi9zdGF0ZS1vcGVyYXRpb25zJztcbmltcG9ydCB7IE1hcHBlZFN0b3JlLCBTdGF0ZXNBbmREZWZhdWx0cyB9IGZyb20gJy4vaW50ZXJuYWxzJztcbmltcG9ydCB7IE5neHNMaWZlQ3ljbGUsIE5neHNTaW1wbGVDaGFuZ2UsIFN0YXRlQ29udGV4dCB9IGZyb20gJy4uL3N5bWJvbHMnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIExpZmVjeWNsZVN0YXRlTWFuYWdlciBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgX2Rlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9zdG9yZTogU3RvcmUsXG4gICAgcHJpdmF0ZSBfaW50ZXJuYWxFcnJvclJlcG9ydGVyOiBJbnRlcm5hbEVycm9yUmVwb3J0ZXIsXG4gICAgcHJpdmF0ZSBfaW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnM6IEludGVybmFsU3RhdGVPcGVyYXRpb25zLFxuICAgIHByaXZhdGUgX3N0YXRlQ29udGV4dEZhY3Rvcnk6IFN0YXRlQ29udGV4dEZhY3RvcnksXG4gICAgcHJpdmF0ZSBfYm9vdHN0cmFwcGVyOiBOZ3hzQm9vdHN0cmFwcGVyXG4gICkge31cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9kZXN0cm95JC5uZXh0KCk7XG4gIH1cblxuICBuZ3hzQm9vdHN0cmFwPFQ+KGFjdGlvbjogVCwgcmVzdWx0czogU3RhdGVzQW5kRGVmYXVsdHMgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICB0aGlzLl9pbnRlcm5hbFN0YXRlT3BlcmF0aW9uc1xuICAgICAgLmdldFJvb3RTdGF0ZU9wZXJhdGlvbnMoKVxuICAgICAgLmRpc3BhdGNoKGFjdGlvbilcbiAgICAgIC5waXBlKFxuICAgICAgICBmaWx0ZXIoKCkgPT4gISFyZXN1bHRzKSxcbiAgICAgICAgdGFwKCgpID0+IHRoaXMuX2ludm9rZUluaXRPblN0YXRlcyhyZXN1bHRzIS5zdGF0ZXMpKSxcbiAgICAgICAgbWVyZ2VNYXAoKCkgPT4gdGhpcy5fYm9vdHN0cmFwcGVyLmFwcEJvb3RzdHJhcHBlZCQpLFxuICAgICAgICBmaWx0ZXIoYXBwQm9vdHN0cmFwcGVkID0+ICEhYXBwQm9vdHN0cmFwcGVkKSxcbiAgICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PiB7XG4gICAgICAgICAgLy8gVGhlIGBTYWZlU3Vic2NyaWJlcmAgKHdoaWNoIGlzIHVzZWQgYnkgbW9zdCBSeEpTIG9wZXJhdG9ycykgcmUtdGhyb3dzXG4gICAgICAgICAgLy8gZXJyb3JzIGFzeW5jaHJvbm91c2x5IChgc2V0VGltZW91dCgoKSA9PiB7IHRocm93IGVycm9yIH0pYCkuIFRoaXMgbWlnaHRcbiAgICAgICAgICAvLyBicmVhayBleGlzdGluZyB1c2VyJ3MgY29kZSBvciB1bml0IHRlc3RzLiBXZSBjYXRjaCB0aGUgZXJyb3IgbWFudWFsbHkgdG9cbiAgICAgICAgICAvLyBiZSBiYWNrd2FyZCBjb21wYXRpYmxlIHdpdGggdGhlIG9sZCBiZWhhdmlvci5cbiAgICAgICAgICB0aGlzLl9pbnRlcm5hbEVycm9yUmVwb3J0ZXIucmVwb3J0RXJyb3JTYWZlbHkoZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBFTVBUWTtcbiAgICAgICAgfSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95JClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5faW52b2tlQm9vdHN0cmFwT25TdGF0ZXMocmVzdWx0cyEuc3RhdGVzKSk7XG4gIH1cblxuICBwcml2YXRlIF9pbnZva2VJbml0T25TdGF0ZXMobWFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBtYXBwZWRTdG9yZSBvZiBtYXBwZWRTdG9yZXMpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlOiBOZ3hzTGlmZUN5Y2xlID0gbWFwcGVkU3RvcmUuaW5zdGFuY2U7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5uZ3hzT25DaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuX3N0b3JlXG4gICAgICAgICAgLnNlbGVjdChzdGF0ZSA9PiBnZXRWYWx1ZShzdGF0ZSwgbWFwcGVkU3RvcmUucGF0aCkpXG4gICAgICAgICAgLnBpcGUoc3RhcnRXaXRoKHVuZGVmaW5lZCksIHBhaXJ3aXNlKCksIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95JCkpXG4gICAgICAgICAgLnN1YnNjcmliZSgoW3ByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IG5ldyBOZ3hzU2ltcGxlQ2hhbmdlKFxuICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgICAgICBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgICAgICFtYXBwZWRTdG9yZS5pc0luaXRpYWxpc2VkXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW5zdGFuY2Uubmd4c09uQ2hhbmdlcyEoY2hhbmdlKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3RhbmNlLm5neHNPbkluaXQpIHtcbiAgICAgICAgaW5zdGFuY2Uubmd4c09uSW5pdCh0aGlzLl9nZXRTdGF0ZUNvbnRleHQobWFwcGVkU3RvcmUpKTtcbiAgICAgIH1cblxuICAgICAgbWFwcGVkU3RvcmUuaXNJbml0aWFsaXNlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaW52b2tlQm9vdHN0cmFwT25TdGF0ZXMobWFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdKSB7XG4gICAgZm9yIChjb25zdCBtYXBwZWRTdG9yZSBvZiBtYXBwZWRTdG9yZXMpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlOiBOZ3hzTGlmZUN5Y2xlID0gbWFwcGVkU3RvcmUuaW5zdGFuY2U7XG4gICAgICBpZiAoaW5zdGFuY2Uubmd4c0FmdGVyQm9vdHN0cmFwKSB7XG4gICAgICAgIGluc3RhbmNlLm5neHNBZnRlckJvb3RzdHJhcCh0aGlzLl9nZXRTdGF0ZUNvbnRleHQobWFwcGVkU3RvcmUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9nZXRTdGF0ZUNvbnRleHQobWFwcGVkU3RvcmU6IE1hcHBlZFN0b3JlKTogU3RhdGVDb250ZXh0PGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZUNvbnRleHRGYWN0b3J5LmNyZWF0ZVN0YXRlQ29udGV4dChtYXBwZWRTdG9yZSk7XG4gIH1cbn1cbiJdfQ==