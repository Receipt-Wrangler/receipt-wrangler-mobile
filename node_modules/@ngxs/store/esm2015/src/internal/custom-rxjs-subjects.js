import { BehaviorSubject, Subject } from 'rxjs';
/**
 * This wraps the provided function, and will enforce the following:
 * - The calls will execute in the order that they are made
 * - A call will only be initiated when the previous call has completed
 * - If there is a call currently executing then the new call will be added
 *   to the queue and the function will return immediately
 *
 * NOTE: The following assumptions about the operation must hold true:
 * - The operation is synchronous in nature
 * - If any asynchronous side effects of the call exist, it should not
 *   have any bearing on the correctness of the next call in the queue
 * - The operation has a void return
 * - The caller should not assume that the call has completed upon
 *   return of the function
 * - The caller can assume that all the queued calls will complete
 *   within the current microtask
 * - The only way that a call will encounter another call in the queue
 *   would be if the call at the front of the queue initiated this call
 *   as part of its synchronous execution
 */
function orderedQueueOperation(operation) {
    const callsQueue = [];
    let busyPushingNext = false;
    return function callOperation(...args) {
        if (busyPushingNext) {
            callsQueue.unshift(args);
            return;
        }
        busyPushingNext = true;
        operation(...args);
        while (callsQueue.length > 0) {
            const nextCallArgs = callsQueue.pop();
            nextCallArgs && operation(...nextCallArgs);
        }
        busyPushingNext = false;
    };
}
/**
 * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard Subject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new Subject<string>();
     subject.subscribe(value => {
       if (value === 'start') subject.next('end');
     });
     subject.subscribe(value => { });
     subject.next('start');
 * ```
 * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.
 */
export class OrderedSubject extends Subject {
    constructor() {
        super(...arguments);
        this._orderedNext = orderedQueueOperation((value) => super.next(value));
    }
    next(value) {
        this._orderedNext(value);
    }
}
/**
 * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.
 * A standard BehaviorSubject does not have this guarantee.
 * For example, given the following code:
 * ```typescript
 *   const subject = new BehaviorSubject<string>();
     subject.subscribe(value => {
       if (value === 'start') subject.next('end');
     });
     subject.subscribe(value => { });
     subject.next('start');
 * ```
 * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.
 * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.
 */
export class OrderedBehaviorSubject extends BehaviorSubject {
    constructor(value) {
        super(value);
        this._orderedNext = orderedQueueOperation((value) => super.next(value));
        this._currentValue = value;
    }
    getValue() {
        return this._currentValue;
    }
    next(value) {
        this._currentValue = value;
        this._orderedNext(value);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VzdG9tLXJ4anMtc3ViamVjdHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9zdG9yZS9zcmMvaW50ZXJuYWwvY3VzdG9tLXJ4anMtc3ViamVjdHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFaEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkc7QUFDSCxTQUFTLHFCQUFxQixDQUFzQixTQUFtQztJQUNyRixNQUFNLFVBQVUsR0FBWSxFQUFFLENBQUM7SUFDL0IsSUFBSSxlQUFlLEdBQUcsS0FBSyxDQUFDO0lBQzVCLE9BQU8sU0FBUyxhQUFhLENBQUMsR0FBRyxJQUFXO1FBQzFDLElBQUksZUFBZSxFQUFFO1lBQ25CLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDekIsT0FBTztTQUNSO1FBQ0QsZUFBZSxHQUFHLElBQUksQ0FBQztRQUN2QixTQUFTLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUNuQixPQUFPLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzVCLE1BQU0sWUFBWSxHQUFHLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUN0QyxZQUFZLElBQUksU0FBUyxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUM7U0FDNUM7UUFDRCxlQUFlLEdBQUcsS0FBSyxDQUFDO0lBQzFCLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILE1BQU0sT0FBTyxjQUFrQixTQUFRLE9BQVU7SUFBakQ7O1FBQ1UsaUJBQVksR0FBRyxxQkFBcUIsQ0FBQyxDQUFDLEtBQVMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBSSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBS3BGLENBQUM7SUFIQyxJQUFJLENBQUMsS0FBUztRQUNaLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0IsQ0FBQztDQUNGO0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0dBY0c7QUFDSCxNQUFNLE9BQU8sc0JBQTBCLFNBQVEsZUFBa0I7SUFJL0QsWUFBWSxLQUFRO1FBQ2xCLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUpQLGlCQUFZLEdBQUcscUJBQXFCLENBQUMsQ0FBQyxLQUFRLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUs1RSxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztJQUM3QixDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQztJQUM1QixDQUFDO0lBRUQsSUFBSSxDQUFDLEtBQVE7UUFDWCxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztRQUMzQixJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIFRoaXMgd3JhcHMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCBhbmQgd2lsbCBlbmZvcmNlIHRoZSBmb2xsb3dpbmc6XG4gKiAtIFRoZSBjYWxscyB3aWxsIGV4ZWN1dGUgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcmUgbWFkZVxuICogLSBBIGNhbGwgd2lsbCBvbmx5IGJlIGluaXRpYXRlZCB3aGVuIHRoZSBwcmV2aW91cyBjYWxsIGhhcyBjb21wbGV0ZWRcbiAqIC0gSWYgdGhlcmUgaXMgYSBjYWxsIGN1cnJlbnRseSBleGVjdXRpbmcgdGhlbiB0aGUgbmV3IGNhbGwgd2lsbCBiZSBhZGRlZFxuICogICB0byB0aGUgcXVldWUgYW5kIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBpbW1lZGlhdGVseVxuICpcbiAqIE5PVEU6IFRoZSBmb2xsb3dpbmcgYXNzdW1wdGlvbnMgYWJvdXQgdGhlIG9wZXJhdGlvbiBtdXN0IGhvbGQgdHJ1ZTpcbiAqIC0gVGhlIG9wZXJhdGlvbiBpcyBzeW5jaHJvbm91cyBpbiBuYXR1cmVcbiAqIC0gSWYgYW55IGFzeW5jaHJvbm91cyBzaWRlIGVmZmVjdHMgb2YgdGhlIGNhbGwgZXhpc3QsIGl0IHNob3VsZCBub3RcbiAqICAgaGF2ZSBhbnkgYmVhcmluZyBvbiB0aGUgY29ycmVjdG5lc3Mgb2YgdGhlIG5leHQgY2FsbCBpbiB0aGUgcXVldWVcbiAqIC0gVGhlIG9wZXJhdGlvbiBoYXMgYSB2b2lkIHJldHVyblxuICogLSBUaGUgY2FsbGVyIHNob3VsZCBub3QgYXNzdW1lIHRoYXQgdGhlIGNhbGwgaGFzIGNvbXBsZXRlZCB1cG9uXG4gKiAgIHJldHVybiBvZiB0aGUgZnVuY3Rpb25cbiAqIC0gVGhlIGNhbGxlciBjYW4gYXNzdW1lIHRoYXQgYWxsIHRoZSBxdWV1ZWQgY2FsbHMgd2lsbCBjb21wbGV0ZVxuICogICB3aXRoaW4gdGhlIGN1cnJlbnQgbWljcm90YXNrXG4gKiAtIFRoZSBvbmx5IHdheSB0aGF0IGEgY2FsbCB3aWxsIGVuY291bnRlciBhbm90aGVyIGNhbGwgaW4gdGhlIHF1ZXVlXG4gKiAgIHdvdWxkIGJlIGlmIHRoZSBjYWxsIGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWUgaW5pdGlhdGVkIHRoaXMgY2FsbFxuICogICBhcyBwYXJ0IG9mIGl0cyBzeW5jaHJvbm91cyBleGVjdXRpb25cbiAqL1xuZnVuY3Rpb24gb3JkZXJlZFF1ZXVlT3BlcmF0aW9uPFRBcmdzIGV4dGVuZHMgYW55W10+KG9wZXJhdGlvbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiB2b2lkKSB7XG4gIGNvbnN0IGNhbGxzUXVldWU6IFRBcmdzW10gPSBbXTtcbiAgbGV0IGJ1c3lQdXNoaW5nTmV4dCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gY2FsbE9wZXJhdGlvbiguLi5hcmdzOiBUQXJncykge1xuICAgIGlmIChidXN5UHVzaGluZ05leHQpIHtcbiAgICAgIGNhbGxzUXVldWUudW5zaGlmdChhcmdzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYnVzeVB1c2hpbmdOZXh0ID0gdHJ1ZTtcbiAgICBvcGVyYXRpb24oLi4uYXJncyk7XG4gICAgd2hpbGUgKGNhbGxzUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmV4dENhbGxBcmdzID0gY2FsbHNRdWV1ZS5wb3AoKTtcbiAgICAgIG5leHRDYWxsQXJncyAmJiBvcGVyYXRpb24oLi4ubmV4dENhbGxBcmdzKTtcbiAgICB9XG4gICAgYnVzeVB1c2hpbmdOZXh0ID0gZmFsc2U7XG4gIH07XG59XG5cbi8qKlxuICogQ3VzdG9tIFN1YmplY3QgdGhhdCBlbnN1cmVzIHRoYXQgc3Vic2NyaWJlcnMgYXJlIG5vdGlmaWVkIG9mIHZhbHVlcyBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFycml2ZWQuXG4gKiBBIHN0YW5kYXJkIFN1YmplY3QgZG9lcyBub3QgaGF2ZSB0aGlzIGd1YXJhbnRlZS5cbiAqIEZvciBleGFtcGxlLCBnaXZlbiB0aGUgZm9sbG93aW5nIGNvZGU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgIGNvbnN0IHN1YmplY3QgPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XG4gICAgIHN1YmplY3Quc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICBpZiAodmFsdWUgPT09ICdzdGFydCcpIHN1YmplY3QubmV4dCgnZW5kJyk7XG4gICAgIH0pO1xuICAgICBzdWJqZWN0LnN1YnNjcmliZSh2YWx1ZSA9PiB7IH0pO1xuICAgICBzdWJqZWN0Lm5leHQoJ3N0YXJ0Jyk7XG4gKiBgYGBcbiAqIFdoZW4gYHN1YmplY3RgIGlzIGEgc3RhbmRhcmQgYFN1YmplY3Q8VD5gIHRoZSBzZWNvbmQgc3Vic2NyaWJlciB3b3VsZCByZWNpZXZlIGBlbmRgIGFuZCB0aGVuIGBzdGFydGAuXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIGBPcmRlcmVkU3ViamVjdDxUPmAgdGhlIHNlY29uZCBzdWJzY3JpYmVyIHdvdWxkIHJlY2lldmUgYHN0YXJ0YCBhbmQgdGhlbiBgZW5kYC5cbiAqL1xuZXhwb3J0IGNsYXNzIE9yZGVyZWRTdWJqZWN0PFQ+IGV4dGVuZHMgU3ViamVjdDxUPiB7XG4gIHByaXZhdGUgX29yZGVyZWROZXh0ID0gb3JkZXJlZFF1ZXVlT3BlcmF0aW9uKCh2YWx1ZT86IFQpID0+IHN1cGVyLm5leHQoPFQ+dmFsdWUpKTtcblxuICBuZXh0KHZhbHVlPzogVCk6IHZvaWQge1xuICAgIHRoaXMuX29yZGVyZWROZXh0KHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEN1c3RvbSBCZWhhdmlvclN1YmplY3QgdGhhdCBlbnN1cmVzIHRoYXQgc3Vic2NyaWJlcnMgYXJlIG5vdGlmaWVkIG9mIHZhbHVlcyBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFycml2ZWQuXG4gKiBBIHN0YW5kYXJkIEJlaGF2aW9yU3ViamVjdCBkb2VzIG5vdCBoYXZlIHRoaXMgZ3VhcmFudGVlLlxuICogRm9yIGV4YW1wbGUsIGdpdmVuIHRoZSBmb2xsb3dpbmcgY29kZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICAgY29uc3Qgc3ViamVjdCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPigpO1xuICAgICBzdWJqZWN0LnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgaWYgKHZhbHVlID09PSAnc3RhcnQnKSBzdWJqZWN0Lm5leHQoJ2VuZCcpO1xuICAgICB9KTtcbiAgICAgc3ViamVjdC5zdWJzY3JpYmUodmFsdWUgPT4geyB9KTtcbiAgICAgc3ViamVjdC5uZXh0KCdzdGFydCcpO1xuICogYGBgXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIHN0YW5kYXJkIGBCZWhhdmlvclN1YmplY3Q8VD5gIHRoZSBzZWNvbmQgc3Vic2NyaWJlciB3b3VsZCByZWNpZXZlIGBlbmRgIGFuZCB0aGVuIGBzdGFydGAuXG4gKiBXaGVuIGBzdWJqZWN0YCBpcyBhIGBPcmRlcmVkQmVoYXZpb3JTdWJqZWN0PFQ+YCB0aGUgc2Vjb25kIHN1YnNjcmliZXIgd291bGQgcmVjaWV2ZSBgc3RhcnRgIGFuZCB0aGVuIGBlbmRgLlxuICovXG5leHBvcnQgY2xhc3MgT3JkZXJlZEJlaGF2aW9yU3ViamVjdDxUPiBleHRlbmRzIEJlaGF2aW9yU3ViamVjdDxUPiB7XG4gIHByaXZhdGUgX29yZGVyZWROZXh0ID0gb3JkZXJlZFF1ZXVlT3BlcmF0aW9uKCh2YWx1ZTogVCkgPT4gc3VwZXIubmV4dCh2YWx1ZSkpO1xuICBwcml2YXRlIF9jdXJyZW50VmFsdWU6IFQ7XG5cbiAgY29uc3RydWN0b3IodmFsdWU6IFQpIHtcbiAgICBzdXBlcih2YWx1ZSk7XG4gICAgdGhpcy5fY3VycmVudFZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBnZXRWYWx1ZSgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFZhbHVlO1xuICB9XG5cbiAgbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIHRoaXMuX2N1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX29yZGVyZWROZXh0KHZhbHVlKTtcbiAgfVxufVxuIl19