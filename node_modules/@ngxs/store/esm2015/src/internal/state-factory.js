import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';
import { forkJoin, from, of, throwError, Subject, isObservable } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { INITIAL_STATE_TOKEN, memoize } from '@ngxs/store/internals';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort, getStoreMetadata } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { ensureStateNameIsUnique, ensureStatesAreDecorated } from '../utils/store-validators';
import { ensureStateClassIsInjectable } from '../ivy/ivy-enabled-in-dev-mode';
import { NgxsUnhandledActionsLogger } from '../dev-features/ngxs-unhandled-actions-logger';
import * as i0 from "@angular/core";
import * as i1 from "../symbols";
import * as i2 from "../actions-stream";
import * as i3 from "../internal/dispatcher";
import * as i4 from "../internal/state-context-factory";
const NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;
/**
 * The `StateFactory` class adds root and feature states to the graph.
 * This extracts state names from state classes, checks if they already
 * exist in the global graph, throws errors if their names are invalid, etc.
 * See its constructor, state factories inject state factories that are
 * parent-level providers. This is required to get feature states from the
 * injector on the same level.
 *
 * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.
 * The `StateFactory` is initialized on the feature level and goes through `...states`
 * to get them from the injector through `injector.get(state)`.
 * @ignore
 */
export class StateFactory {
    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._actionsSubscription = null;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = memoize(() => {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const stateFactory = this;
            function resolveGetter(key) {
                const path = stateFactory.statePaths[key];
                return path ? propGetter(path.split('.'), stateFactory._config) : null;
            }
            const context = this._parentFactory
                ? this._parentFactory.getRuntimeSelectorContext()
                : {
                    getStateGetter(key) {
                        let getter = resolveGetter(key);
                        if (getter) {
                            return getter;
                        }
                        return (...args) => {
                            // Late loaded getter
                            if (!getter) {
                                getter = resolveGetter(key);
                            }
                            return getter ? getter(...args) : undefined;
                        };
                    },
                    getSelectorOptions(localOptions) {
                        const globalSelectorOptions = stateFactory._config.selectorOptions;
                        return Object.assign(Object.assign({}, globalSelectorOptions), (localOptions || {}));
                    }
                };
            return context;
        });
    }
    get states() {
        return this._parentFactory ? this._parentFactory.states : this._states;
    }
    get statesByName() {
        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
    }
    get statePaths() {
        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
    }
    static _cloneDefaults(defaults) {
        let value = defaults;
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (isObject(defaults)) {
            value = Object.assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        return value;
    }
    ngOnDestroy() {
        var _a;
        (_a = this._actionsSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    }
    /**
     * Add a new state to the global defs.
     */
    add(stateClasses) {
        if (NG_DEV_MODE) {
            ensureStatesAreDecorated(stateClasses);
        }
        const { newStates } = this.addToStatesMap(stateClasses);
        if (!newStates.length)
            return [];
        const stateGraph = buildGraph(newStates);
        const sortedStates = topologicalSort(stateGraph);
        const paths = findFullParentPath(stateGraph);
        const nameGraph = nameToState(newStates);
        const bootstrappedStores = [];
        for (const name of sortedStates) {
            const stateClass = nameGraph[name];
            const path = paths[name];
            const meta = stateClass[META_KEY];
            this.addRuntimeInfoToMeta(meta, path);
            // Note: previously we called `ensureStateClassIsInjectable` within the
            // `State` decorator. This check is moved here because the `ɵprov` property
            // will not exist on the class in JIT mode (because it's set asynchronously
            // during JIT compilation through `Object.defineProperty`).
            if (NG_DEV_MODE) {
                ensureStateClassIsInjectable(stateClass);
            }
            const stateMap = {
                name,
                path,
                isInitialised: false,
                actions: meta.actions,
                instance: this._injector.get(stateClass),
                defaults: StateFactory._cloneDefaults(meta.defaults)
            };
            // ensure our store hasn't already been added
            // but don't throw since it could be lazy
            // loaded from different paths
            if (!this.hasBeenMountedAndBootstrapped(name, path)) {
                bootstrappedStores.push(stateMap);
            }
            this.states.push(stateMap);
        }
        return bootstrappedStores;
    }
    /**
     * Add a set of states to the store and return the defaults
     */
    addAndReturnDefaults(stateClasses) {
        const classes = stateClasses || [];
        const mappedStores = this.add(classes);
        const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});
        return { defaults, states: mappedStores };
    }
    connectActionHandlers() {
        // Note: We have to connect actions only once when the `StateFactory`
        //       is being created for the first time. This checks if we're in
        //       a child state factory and the parent state factory already exists.
        if (this._parentFactory || this._actionsSubscription !== null) {
            return;
        }
        const dispatched$ = new Subject();
        this._actionsSubscription = this._actions
            .pipe(filter((ctx) => ctx.status === "DISPATCHED" /* Dispatched */), mergeMap(ctx => {
            dispatched$.next(ctx);
            const action = ctx.action;
            return this.invokeActions(dispatched$, action).pipe(map(() => ({ action, status: "SUCCESSFUL" /* Successful */ })), defaultIfEmpty({ action, status: "CANCELED" /* Canceled */ }), catchError(error => of({ action, status: "ERRORED" /* Errored */, error })));
        }))
            .subscribe(ctx => this._actionResults.next(ctx));
    }
    /**
     * Invoke actions on the states.
     */
    invokeActions(dispatched$, action) {
        const type = getActionTypeFromInstance(action);
        const results = [];
        // Determines whether the dispatched action has been handled, this is assigned
        // to `true` within the below `for` loop if any `actionMetas` has been found.
        let actionHasBeenHandled = false;
        for (const metadata of this.states) {
            const actionMetas = metadata.actions[type];
            if (actionMetas) {
                for (const actionMeta of actionMetas) {
                    const stateContext = this._stateContextFactory.createStateContext(metadata);
                    try {
                        let result = metadata.instance[actionMeta.fn](stateContext, action);
                        if (result instanceof Promise) {
                            result = from(result);
                        }
                        if (isObservable(result)) {
                            // If this observable has been completed w/o emitting
                            // any value then we wouldn't want to complete the whole chain
                            // of actions. Since if any observable completes then
                            // action will be canceled.
                            // For instance if any action handler would've had such statement:
                            // `handler(ctx) { return EMPTY; }`
                            // then the action will be canceled.
                            // See https://github.com/ngxs/store/issues/1568
                            result = result.pipe(mergeMap((value) => {
                                if (value instanceof Promise) {
                                    return from(value);
                                }
                                if (isObservable(value)) {
                                    return value;
                                }
                                return of(value);
                            }), defaultIfEmpty({}));
                            if (actionMeta.options.cancelUncompleted) {
                                // todo: ofActionDispatched should be used with action class
                                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));
                            }
                        }
                        else {
                            result = of({}).pipe(shareReplay());
                        }
                        results.push(result);
                    }
                    catch (e) {
                        results.push(throwError(e));
                    }
                    actionHasBeenHandled = true;
                }
            }
        }
        // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions
        // only during development.
        if (NG_DEV_MODE && !actionHasBeenHandled) {
            const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);
            // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the
            // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`
            // didn't return `null` so we may ensure the module has been imported.
            if (unhandledActionsLogger) {
                unhandledActionsLogger.warn(action);
            }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    }
    addToStatesMap(stateClasses) {
        const newStates = [];
        const statesMap = this.statesByName;
        for (const stateClass of stateClasses) {
            const stateName = getStoreMetadata(stateClass).name;
            if (NG_DEV_MODE) {
                ensureStateNameIsUnique(stateName, stateClass, statesMap);
            }
            const unmountedState = !statesMap[stateName];
            if (unmountedState) {
                newStates.push(stateClass);
                statesMap[stateName] = stateClass;
            }
        }
        return { newStates };
    }
    addRuntimeInfoToMeta(meta, path) {
        this.statePaths[meta.name] = path;
        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative in v4 because this is used by many plugins
        meta.path = path;
    }
    hasBeenMountedAndBootstrapped(name, path) {
        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        // This checks whether a state has been already added to the global graph and
        // its lifecycle is in 'bootstrapped' state.
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    }
}
/** @nocollapse */ StateFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateFactory, deps: [{ token: i0.Injector }, { token: i1.NgxsConfig }, { token: StateFactory, optional: true, skipSelf: true }, { token: i2.InternalActions }, { token: i3.InternalDispatchedActionResults }, { token: i4.StateContextFactory }, { token: INITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ StateFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateFactory });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateFactory, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.NgxsConfig }, { type: StateFactory, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i2.InternalActions }, { type: i3.InternalDispatchedActionResults }, { type: i4.StateContextFactory }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [INITIAL_STATE_TOKEN]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3N0b3JlL3NyYy9pbnRlcm5hbC9zdGF0ZS1mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQzVGLE9BQU8sRUFDTCxRQUFRLEVBQ1IsSUFBSSxFQUVKLEVBQUUsRUFDRixVQUFVLEVBRVYsT0FBTyxFQUNQLFlBQVksRUFDYixNQUFNLE1BQU0sQ0FBQztBQUNkLE9BQU8sRUFDTCxVQUFVLEVBQ1YsY0FBYyxFQUNkLE1BQU0sRUFDTixHQUFHLEVBQ0gsUUFBUSxFQUNSLFdBQVcsRUFDWCxTQUFTLEVBQ1YsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsbUJBQW1CLEVBQWlCLE9BQU8sRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRXBGLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ2xELE9BQU8sRUFDTCxVQUFVLEVBQ1Ysa0JBQWtCLEVBQ2xCLFFBQVEsRUFHUixXQUFXLEVBQ1gsVUFBVSxFQUtWLGVBQWUsRUFHZixnQkFBZ0IsRUFDakIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLHlCQUF5QixFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQStCLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ2pGLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSx1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SyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ25DLHFGQUFxRjtRQUNyRiw2RUFBNkU7UUFDN0UseUZBQXlGO1FBQ3pGLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO0lBQ25CLENBQUM7SUFFTyw2QkFBNkIsQ0FBQyxJQUFZLEVBQUUsSUFBWTtRQUM5RCxNQUFNLGlDQUFpQyxHQUNyQyxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsS0FBSyxTQUFTLENBQUM7UUFDbkQsNkVBQTZFO1FBQzdFLDRDQUE0QztRQUM1QyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksaUNBQWlDLENBQUM7SUFDdEUsQ0FBQzs7NkhBalRVLFlBQVksb0VBUUcsWUFBWSw4SkFLNUIsbUJBQW1CO2lJQWJsQixZQUFZOzRGQUFaLFlBQVk7a0JBRHhCLFVBQVU7MEdBU2lCLFlBQVk7MEJBRm5DLFFBQVE7OzBCQUNSLFFBQVE7OzBCQUtSLFFBQVE7OzBCQUNSLE1BQU07MkJBQUMsbUJBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0b3IsIE9wdGlvbmFsLCBTa2lwU2VsZiwgSW5qZWN0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIGZvcmtKb2luLFxuICBmcm9tLFxuICBPYnNlcnZhYmxlLFxuICBvZixcbiAgdGhyb3dFcnJvcixcbiAgU3Vic2NyaXB0aW9uLFxuICBTdWJqZWN0LFxuICBpc09ic2VydmFibGVcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBjYXRjaEVycm9yLFxuICBkZWZhdWx0SWZFbXB0eSxcbiAgZmlsdGVyLFxuICBtYXAsXG4gIG1lcmdlTWFwLFxuICBzaGFyZVJlcGxheSxcbiAgdGFrZVVudGlsXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElOSVRJQUxfU1RBVEVfVE9LRU4sIFBsYWluT2JqZWN0T2YsIG1lbW9pemUgfSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xuXG5pbXBvcnQgeyBNRVRBX0tFWSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xuaW1wb3J0IHtcbiAgYnVpbGRHcmFwaCxcbiAgZmluZEZ1bGxQYXJlbnRQYXRoLFxuICBpc09iamVjdCxcbiAgTWFwcGVkU3RvcmUsXG4gIE1ldGFEYXRhTW9kZWwsXG4gIG5hbWVUb1N0YXRlLFxuICBwcm9wR2V0dGVyLFxuICBTdGF0ZUNsYXNzSW50ZXJuYWwsXG4gIFN0YXRlS2V5R3JhcGgsXG4gIFN0YXRlc0FuZERlZmF1bHRzLFxuICBTdGF0ZXNCeU5hbWUsXG4gIHRvcG9sb2dpY2FsU29ydCxcbiAgUnVudGltZVNlbGVjdG9yQ29udGV4dCxcbiAgU2hhcmVkU2VsZWN0b3JPcHRpb25zLFxuICBnZXRTdG9yZU1ldGFkYXRhXG59IGZyb20gJy4vaW50ZXJuYWxzJztcbmltcG9ydCB7IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UsIGdldFZhbHVlLCBzZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IG9mQWN0aW9uRGlzcGF0Y2hlZCB9IGZyb20gJy4uL29wZXJhdG9ycy9vZi1hY3Rpb24nO1xuaW1wb3J0IHsgQWN0aW9uQ29udGV4dCwgQWN0aW9uU3RhdHVzLCBJbnRlcm5hbEFjdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBTdGF0ZUNvbnRleHRGYWN0b3J5IH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtY29udGV4dC1mYWN0b3J5JztcbmltcG9ydCB7IGVuc3VyZVN0YXRlTmFtZUlzVW5pcXVlLCBlbnN1cmVTdGF0ZXNBcmVEZWNvcmF0ZWQgfSBmcm9tICcuLi91dGlscy9zdG9yZS12YWxpZGF0b3JzJztcbmltcG9ydCB7IGVuc3VyZVN0YXRlQ2xhc3NJc0luamVjdGFibGUgfSBmcm9tICcuLi9pdnkvaXZ5LWVuYWJsZWQtaW4tZGV2LW1vZGUnO1xuaW1wb3J0IHsgTmd4c1VuaGFuZGxlZEFjdGlvbnNMb2dnZXIgfSBmcm9tICcuLi9kZXYtZmVhdHVyZXMvbmd4cy11bmhhbmRsZWQtYWN0aW9ucy1sb2dnZXInO1xuXG5jb25zdCBOR19ERVZfTU9ERSA9IHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZTtcblxuLyoqXG4gKiBUaGUgYFN0YXRlRmFjdG9yeWAgY2xhc3MgYWRkcyByb290IGFuZCBmZWF0dXJlIHN0YXRlcyB0byB0aGUgZ3JhcGguXG4gKiBUaGlzIGV4dHJhY3RzIHN0YXRlIG5hbWVzIGZyb20gc3RhdGUgY2xhc3NlcywgY2hlY2tzIGlmIHRoZXkgYWxyZWFkeVxuICogZXhpc3QgaW4gdGhlIGdsb2JhbCBncmFwaCwgdGhyb3dzIGVycm9ycyBpZiB0aGVpciBuYW1lcyBhcmUgaW52YWxpZCwgZXRjLlxuICogU2VlIGl0cyBjb25zdHJ1Y3Rvciwgc3RhdGUgZmFjdG9yaWVzIGluamVjdCBzdGF0ZSBmYWN0b3JpZXMgdGhhdCBhcmVcbiAqIHBhcmVudC1sZXZlbCBwcm92aWRlcnMuIFRoaXMgaXMgcmVxdWlyZWQgdG8gZ2V0IGZlYXR1cmUgc3RhdGVzIGZyb20gdGhlXG4gKiBpbmplY3RvciBvbiB0aGUgc2FtZSBsZXZlbC5cbiAqXG4gKiBUaGUgYE5neHNNb2R1bGUuZm9yRmVhdHVyZSguLi4pYCByZXR1cm5zIGBwcm92aWRlcnM6IFtTdGF0ZUZhY3RvcnksIC4uLnN0YXRlc11gLlxuICogVGhlIGBTdGF0ZUZhY3RvcnlgIGlzIGluaXRpYWxpemVkIG9uIHRoZSBmZWF0dXJlIGxldmVsIGFuZCBnb2VzIHRocm91Z2ggYC4uLnN0YXRlc2BcbiAqIHRvIGdldCB0aGVtIGZyb20gdGhlIGluamVjdG9yIHRocm91Z2ggYGluamVjdG9yLmdldChzdGF0ZSlgLlxuICogQGlnbm9yZVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU3RhdGVGYWN0b3J5IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfYWN0aW9uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgcHJpdmF0ZSBfcGFyZW50RmFjdG9yeTogU3RhdGVGYWN0b3J5LFxuICAgIHByaXZhdGUgX2FjdGlvbnM6IEludGVybmFsQWN0aW9ucyxcbiAgICBwcml2YXRlIF9hY3Rpb25SZXN1bHRzOiBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzLFxuICAgIHByaXZhdGUgX3N0YXRlQ29udGV4dEZhY3Rvcnk6IFN0YXRlQ29udGV4dEZhY3RvcnksXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KElOSVRJQUxfU1RBVEVfVE9LRU4pXG4gICAgcHJpdmF0ZSBfaW5pdGlhbFN0YXRlOiBhbnlcbiAgKSB7fVxuXG4gIHByaXZhdGUgX3N0YXRlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xuXG4gIGdldCBzdGF0ZXMoKTogTWFwcGVkU3RvcmVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlcyA6IHRoaXMuX3N0YXRlcztcbiAgfVxuXG4gIHByaXZhdGUgX3N0YXRlc0J5TmFtZTogU3RhdGVzQnlOYW1lID0ge307XG5cbiAgZ2V0IHN0YXRlc0J5TmFtZSgpOiBTdGF0ZXNCeU5hbWUge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXNCeU5hbWUgOiB0aGlzLl9zdGF0ZXNCeU5hbWU7XG4gIH1cblxuICBwcml2YXRlIF9zdGF0ZVBhdGhzOiBQbGFpbk9iamVjdE9mPHN0cmluZz4gPSB7fTtcblxuICBwcml2YXRlIGdldCBzdGF0ZVBhdGhzKCk6IFBsYWluT2JqZWN0T2Y8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlUGF0aHMgOiB0aGlzLl9zdGF0ZVBhdGhzO1xuICB9XG5cbiAgZ2V0UnVudGltZVNlbGVjdG9yQ29udGV4dCA9IG1lbW9pemUoKCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgIGNvbnN0IHN0YXRlRmFjdG9yeSA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlR2V0dGVyKGtleTogc3RyaW5nKSB7XG4gICAgICBjb25zdCBwYXRoID0gc3RhdGVGYWN0b3J5LnN0YXRlUGF0aHNba2V5XTtcbiAgICAgIHJldHVybiBwYXRoID8gcHJvcEdldHRlcihwYXRoLnNwbGl0KCcuJyksIHN0YXRlRmFjdG9yeS5fY29uZmlnKSA6IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dDogUnVudGltZVNlbGVjdG9yQ29udGV4dCA9IHRoaXMuX3BhcmVudEZhY3RvcnlcbiAgICAgID8gdGhpcy5fcGFyZW50RmFjdG9yeS5nZXRSdW50aW1lU2VsZWN0b3JDb250ZXh0KClcbiAgICAgIDoge1xuICAgICAgICAgIGdldFN0YXRlR2V0dGVyKGtleTogc3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgZ2V0dGVyID0gcmVzb2x2ZUdldHRlcihrZXkpO1xuICAgICAgICAgICAgaWYgKGdldHRlcikge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgIC8vIExhdGUgbG9hZGVkIGdldHRlclxuICAgICAgICAgICAgICBpZiAoIWdldHRlcikge1xuICAgICAgICAgICAgICAgIGdldHRlciA9IHJlc29sdmVHZXR0ZXIoa2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyKC4uLmFyZ3MpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFNlbGVjdG9yT3B0aW9ucyhsb2NhbE9wdGlvbnM/OiBTaGFyZWRTZWxlY3Rvck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNlbGVjdG9yT3B0aW9ucyA9IHN0YXRlRmFjdG9yeS5fY29uZmlnLnNlbGVjdG9yT3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmdsb2JhbFNlbGVjdG9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgLi4uKGxvY2FsT3B0aW9ucyB8fCB7fSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9KTtcblxuICBwcml2YXRlIHN0YXRpYyBfY2xvbmVEZWZhdWx0cyhkZWZhdWx0czogYW55KTogYW55IHtcbiAgICBsZXQgdmFsdWUgPSBkZWZhdWx0cztcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmF1bHRzKSkge1xuICAgICAgdmFsdWUgPSBkZWZhdWx0cy5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGVmYXVsdHMpKSB7XG4gICAgICB2YWx1ZSA9IHsgLi4uZGVmYXVsdHMgfTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aW9uc1N1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgc3RhdGUgdG8gdGhlIGdsb2JhbCBkZWZzLlxuICAgKi9cbiAgYWRkKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10pOiBNYXBwZWRTdG9yZVtdIHtcbiAgICBpZiAoTkdfREVWX01PREUpIHtcbiAgICAgIGVuc3VyZVN0YXRlc0FyZURlY29yYXRlZChzdGF0ZUNsYXNzZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbmV3U3RhdGVzIH0gPSB0aGlzLmFkZFRvU3RhdGVzTWFwKHN0YXRlQ2xhc3Nlcyk7XG4gICAgaWYgKCFuZXdTdGF0ZXMubGVuZ3RoKSByZXR1cm4gW107XG5cbiAgICBjb25zdCBzdGF0ZUdyYXBoOiBTdGF0ZUtleUdyYXBoID0gYnVpbGRHcmFwaChuZXdTdGF0ZXMpO1xuICAgIGNvbnN0IHNvcnRlZFN0YXRlczogc3RyaW5nW10gPSB0b3BvbG9naWNhbFNvcnQoc3RhdGVHcmFwaCk7XG4gICAgY29uc3QgcGF0aHM6IFBsYWluT2JqZWN0T2Y8c3RyaW5nPiA9IGZpbmRGdWxsUGFyZW50UGF0aChzdGF0ZUdyYXBoKTtcbiAgICBjb25zdCBuYW1lR3JhcGg6IFBsYWluT2JqZWN0T2Y8U3RhdGVDbGFzc0ludGVybmFsPiA9IG5hbWVUb1N0YXRlKG5ld1N0YXRlcyk7XG4gICAgY29uc3QgYm9vdHN0cmFwcGVkU3RvcmVzOiBNYXBwZWRTdG9yZVtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygc29ydGVkU3RhdGVzKSB7XG4gICAgICBjb25zdCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwgPSBuYW1lR3JhcGhbbmFtZV07XG4gICAgICBjb25zdCBwYXRoOiBzdHJpbmcgPSBwYXRoc1tuYW1lXTtcbiAgICAgIGNvbnN0IG1ldGE6IE1ldGFEYXRhTW9kZWwgPSBzdGF0ZUNsYXNzW01FVEFfS0VZXSE7XG5cbiAgICAgIHRoaXMuYWRkUnVudGltZUluZm9Ub01ldGEobWV0YSwgcGF0aCk7XG5cbiAgICAgIC8vIE5vdGU6IHByZXZpb3VzbHkgd2UgY2FsbGVkIGBlbnN1cmVTdGF0ZUNsYXNzSXNJbmplY3RhYmxlYCB3aXRoaW4gdGhlXG4gICAgICAvLyBgU3RhdGVgIGRlY29yYXRvci4gVGhpcyBjaGVjayBpcyBtb3ZlZCBoZXJlIGJlY2F1c2UgdGhlIGDJtXByb3ZgIHByb3BlcnR5XG4gICAgICAvLyB3aWxsIG5vdCBleGlzdCBvbiB0aGUgY2xhc3MgaW4gSklUIG1vZGUgKGJlY2F1c2UgaXQncyBzZXQgYXN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGR1cmluZyBKSVQgY29tcGlsYXRpb24gdGhyb3VnaCBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCkuXG4gICAgICBpZiAoTkdfREVWX01PREUpIHtcbiAgICAgICAgZW5zdXJlU3RhdGVDbGFzc0lzSW5qZWN0YWJsZShzdGF0ZUNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhdGVNYXA6IE1hcHBlZFN0b3JlID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBpc0luaXRpYWxpc2VkOiBmYWxzZSxcbiAgICAgICAgYWN0aW9uczogbWV0YS5hY3Rpb25zLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5faW5qZWN0b3IuZ2V0KHN0YXRlQ2xhc3MpLFxuICAgICAgICBkZWZhdWx0czogU3RhdGVGYWN0b3J5Ll9jbG9uZURlZmF1bHRzKG1ldGEuZGVmYXVsdHMpXG4gICAgICB9O1xuXG4gICAgICAvLyBlbnN1cmUgb3VyIHN0b3JlIGhhc24ndCBhbHJlYWR5IGJlZW4gYWRkZWRcbiAgICAgIC8vIGJ1dCBkb24ndCB0aHJvdyBzaW5jZSBpdCBjb3VsZCBiZSBsYXp5XG4gICAgICAvLyBsb2FkZWQgZnJvbSBkaWZmZXJlbnQgcGF0aHNcbiAgICAgIGlmICghdGhpcy5oYXNCZWVuTW91bnRlZEFuZEJvb3RzdHJhcHBlZChuYW1lLCBwYXRoKSkge1xuICAgICAgICBib290c3RyYXBwZWRTdG9yZXMucHVzaChzdGF0ZU1hcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhdGVzLnB1c2goc3RhdGVNYXApO1xuICAgIH1cblxuICAgIHJldHVybiBib290c3RyYXBwZWRTdG9yZXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgc2V0IG9mIHN0YXRlcyB0byB0aGUgc3RvcmUgYW5kIHJldHVybiB0aGUgZGVmYXVsdHNcbiAgICovXG4gIGFkZEFuZFJldHVybkRlZmF1bHRzKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10pOiBTdGF0ZXNBbmREZWZhdWx0cyB7XG4gICAgY29uc3QgY2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10gPSBzdGF0ZUNsYXNzZXMgfHwgW107XG5cbiAgICBjb25zdCBtYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSB0aGlzLmFkZChjbGFzc2VzKTtcbiAgICBjb25zdCBkZWZhdWx0cyA9IG1hcHBlZFN0b3Jlcy5yZWR1Y2UoXG4gICAgICAocmVzdWx0OiBhbnksIG1hcHBlZFN0b3JlOiBNYXBwZWRTdG9yZSkgPT5cbiAgICAgICAgc2V0VmFsdWUocmVzdWx0LCBtYXBwZWRTdG9yZS5wYXRoLCBtYXBwZWRTdG9yZS5kZWZhdWx0cyksXG4gICAgICB7fVxuICAgICk7XG4gICAgcmV0dXJuIHsgZGVmYXVsdHMsIHN0YXRlczogbWFwcGVkU3RvcmVzIH07XG4gIH1cblxuICBjb25uZWN0QWN0aW9uSGFuZGxlcnMoKTogdm9pZCB7XG4gICAgLy8gTm90ZTogV2UgaGF2ZSB0byBjb25uZWN0IGFjdGlvbnMgb25seSBvbmNlIHdoZW4gdGhlIGBTdGF0ZUZhY3RvcnlgXG4gICAgLy8gICAgICAgaXMgYmVpbmcgY3JlYXRlZCBmb3IgdGhlIGZpcnN0IHRpbWUuIFRoaXMgY2hlY2tzIGlmIHdlJ3JlIGluXG4gICAgLy8gICAgICAgYSBjaGlsZCBzdGF0ZSBmYWN0b3J5IGFuZCB0aGUgcGFyZW50IHN0YXRlIGZhY3RvcnkgYWxyZWFkeSBleGlzdHMuXG4gICAgaWYgKHRoaXMuX3BhcmVudEZhY3RvcnkgfHwgdGhpcy5fYWN0aW9uc1N1YnNjcmlwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3BhdGNoZWQkID0gbmV3IFN1YmplY3Q8QWN0aW9uQ29udGV4dD4oKTtcbiAgICB0aGlzLl9hY3Rpb25zU3Vic2NyaXB0aW9uID0gdGhpcy5fYWN0aW9uc1xuICAgICAgLnBpcGUoXG4gICAgICAgIGZpbHRlcigoY3R4OiBBY3Rpb25Db250ZXh0KSA9PiBjdHguc3RhdHVzID09PSBBY3Rpb25TdGF0dXMuRGlzcGF0Y2hlZCksXG4gICAgICAgIG1lcmdlTWFwKGN0eCA9PiB7XG4gICAgICAgICAgZGlzcGF0Y2hlZCQubmV4dChjdHgpO1xuICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGN0eC5hY3Rpb247XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlQWN0aW9ucyhkaXNwYXRjaGVkJCwgYWN0aW9uISkucGlwZShcbiAgICAgICAgICAgIG1hcCgoKSA9PiA8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuU3VjY2Vzc2Z1bCB9KSxcbiAgICAgICAgICAgIGRlZmF1bHRJZkVtcHR5KDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5DYW5jZWxlZCB9KSxcbiAgICAgICAgICAgIGNhdGNoRXJyb3IoZXJyb3IgPT5cbiAgICAgICAgICAgICAgb2YoPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLkVycm9yZWQsIGVycm9yIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoY3R4ID0+IHRoaXMuX2FjdGlvblJlc3VsdHMubmV4dChjdHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2UgYWN0aW9ucyBvbiB0aGUgc3RhdGVzLlxuICAgKi9cbiAgaW52b2tlQWN0aW9ucyhkaXNwYXRjaGVkJDogT2JzZXJ2YWJsZTxBY3Rpb25Db250ZXh0PiwgYWN0aW9uOiBhbnkpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24pITtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGRpc3BhdGNoZWQgYWN0aW9uIGhhcyBiZWVuIGhhbmRsZWQsIHRoaXMgaXMgYXNzaWduZWRcbiAgICAvLyB0byBgdHJ1ZWAgd2l0aGluIHRoZSBiZWxvdyBgZm9yYCBsb29wIGlmIGFueSBgYWN0aW9uTWV0YXNgIGhhcyBiZWVuIGZvdW5kLlxuICAgIGxldCBhY3Rpb25IYXNCZWVuSGFuZGxlZCA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCBtZXRhZGF0YSBvZiB0aGlzLnN0YXRlcykge1xuICAgICAgY29uc3QgYWN0aW9uTWV0YXMgPSBtZXRhZGF0YS5hY3Rpb25zW3R5cGVdO1xuXG4gICAgICBpZiAoYWN0aW9uTWV0YXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBhY3Rpb25NZXRhIG9mIGFjdGlvbk1ldGFzKSB7XG4gICAgICAgICAgY29uc3Qgc3RhdGVDb250ZXh0ID0gdGhpcy5fc3RhdGVDb250ZXh0RmFjdG9yeS5jcmVhdGVTdGF0ZUNvbnRleHQobWV0YWRhdGEpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGEuaW5zdGFuY2VbYWN0aW9uTWV0YS5mbl0oc3RhdGVDb250ZXh0LCBhY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICByZXN1bHQgPSBmcm9tKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc09ic2VydmFibGUocmVzdWx0KSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGlzIG9ic2VydmFibGUgaGFzIGJlZW4gY29tcGxldGVkIHcvbyBlbWl0dGluZ1xuICAgICAgICAgICAgICAvLyBhbnkgdmFsdWUgdGhlbiB3ZSB3b3VsZG4ndCB3YW50IHRvIGNvbXBsZXRlIHRoZSB3aG9sZSBjaGFpblxuICAgICAgICAgICAgICAvLyBvZiBhY3Rpb25zLiBTaW5jZSBpZiBhbnkgb2JzZXJ2YWJsZSBjb21wbGV0ZXMgdGhlblxuICAgICAgICAgICAgICAvLyBhY3Rpb24gd2lsbCBiZSBjYW5jZWxlZC5cbiAgICAgICAgICAgICAgLy8gRm9yIGluc3RhbmNlIGlmIGFueSBhY3Rpb24gaGFuZGxlciB3b3VsZCd2ZSBoYWQgc3VjaCBzdGF0ZW1lbnQ6XG4gICAgICAgICAgICAgIC8vIGBoYW5kbGVyKGN0eCkgeyByZXR1cm4gRU1QVFk7IH1gXG4gICAgICAgICAgICAgIC8vIHRoZW4gdGhlIGFjdGlvbiB3aWxsIGJlIGNhbmNlbGVkLlxuICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25neHMvc3RvcmUvaXNzdWVzLzE1NjhcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUoXG4gICAgICAgICAgICAgICAgbWVyZ2VNYXAoKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZyb20odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0SWZFbXB0eSh7fSlcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBpZiAoYWN0aW9uTWV0YS5vcHRpb25zLmNhbmNlbFVuY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbzogb2ZBY3Rpb25EaXNwYXRjaGVkIHNob3VsZCBiZSB1c2VkIHdpdGggYWN0aW9uIGNsYXNzXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUoXG4gICAgICAgICAgICAgICAgICB0YWtlVW50aWwoZGlzcGF0Y2hlZCQucGlwZShvZkFjdGlvbkRpc3BhdGNoZWQoYWN0aW9uIGFzIGFueSkpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG9mKHt9KS5waXBlKHNoYXJlUmVwbGF5KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhyb3dFcnJvcihlKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWN0aW9uSGFzQmVlbkhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGBOZ3hzVW5oYW5kbGVkQWN0aW9uc0xvZ2dlcmAgaXMgYSB0cmVlLXNoYWthYmxlIGNsYXNzIHdoaWNoIGZ1bmN0aW9uc1xuICAgIC8vIG9ubHkgZHVyaW5nIGRldmVsb3BtZW50LlxuICAgIGlmIChOR19ERVZfTU9ERSAmJiAhYWN0aW9uSGFzQmVlbkhhbmRsZWQpIHtcbiAgICAgIGNvbnN0IHVuaGFuZGxlZEFjdGlvbnNMb2dnZXIgPSB0aGlzLl9pbmplY3Rvci5nZXQoTmd4c1VuaGFuZGxlZEFjdGlvbnNMb2dnZXIsIG51bGwpO1xuICAgICAgLy8gVGhlIGBOZ3hzVW5oYW5kbGVkQWN0aW9uc0xvZ2dlcmAgd2lsbCBub3QgYmUgcmVzb2x2ZWQgYnkgdGhlIGluamVjdG9yIGlmIHRoZVxuICAgICAgLy8gYE5neHNEZXZlbG9wbWVudE1vZHVsZWAgaXMgbm90IHByb3ZpZGVkLiBJdCdzIGVub3VnaCB0byBjaGVjayB3aGV0aGVyIHRoZSBgaW5qZWN0b3IuZ2V0YFxuICAgICAgLy8gZGlkbid0IHJldHVybiBgbnVsbGAgc28gd2UgbWF5IGVuc3VyZSB0aGUgbW9kdWxlIGhhcyBiZWVuIGltcG9ydGVkLlxuICAgICAgaWYgKHVuaGFuZGxlZEFjdGlvbnNMb2dnZXIpIHtcbiAgICAgICAgdW5oYW5kbGVkQWN0aW9uc0xvZ2dlci53YXJuKGFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0cy5wdXNoKG9mKHt9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcmtKb2luKHJlc3VsdHMpO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRUb1N0YXRlc01hcChzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKToge1xuICAgIG5ld1N0YXRlczogU3RhdGVDbGFzc0ludGVybmFsW107XG4gIH0ge1xuICAgIGNvbnN0IG5ld1N0YXRlczogU3RhdGVDbGFzc0ludGVybmFsW10gPSBbXTtcbiAgICBjb25zdCBzdGF0ZXNNYXA6IFN0YXRlc0J5TmFtZSA9IHRoaXMuc3RhdGVzQnlOYW1lO1xuXG4gICAgZm9yIChjb25zdCBzdGF0ZUNsYXNzIG9mIHN0YXRlQ2xhc3Nlcykge1xuICAgICAgY29uc3Qgc3RhdGVOYW1lID0gZ2V0U3RvcmVNZXRhZGF0YShzdGF0ZUNsYXNzKS5uYW1lITtcbiAgICAgIGlmIChOR19ERVZfTU9ERSkge1xuICAgICAgICBlbnN1cmVTdGF0ZU5hbWVJc1VuaXF1ZShzdGF0ZU5hbWUsIHN0YXRlQ2xhc3MsIHN0YXRlc01hcCk7XG4gICAgICB9XG4gICAgICBjb25zdCB1bm1vdW50ZWRTdGF0ZSA9ICFzdGF0ZXNNYXBbc3RhdGVOYW1lXTtcbiAgICAgIGlmICh1bm1vdW50ZWRTdGF0ZSkge1xuICAgICAgICBuZXdTdGF0ZXMucHVzaChzdGF0ZUNsYXNzKTtcbiAgICAgICAgc3RhdGVzTWFwW3N0YXRlTmFtZV0gPSBzdGF0ZUNsYXNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IG5ld1N0YXRlcyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhOiBNZXRhRGF0YU1vZGVsLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnN0YXRlUGF0aHNbbWV0YS5uYW1lIV0gPSBwYXRoO1xuICAgIC8vIFRPRE86IHY0IC0gd2UgcGxhbiB0byBnZXQgcmlkIG9mIHRoZSBwYXRoIHByb3BlcnR5IGJlY2F1c2UgaXQgaXMgbm9uLWRldGVybWluaXN0aWNcbiAgICAvLyB3ZSBjYW4gZG8gdGhpcyB3aGVuIHdlIGdldCByaWQgb2YgdGhlIGluY29ycmVjdGx5IGV4cG9zZWQgZ2V0U3RvcmVNZXRhZGF0YVxuICAgIC8vIFdlIHdpbGwgbmVlZCB0byBjb21lIHVwIHdpdGggYW4gYWx0ZXJuYXRpdmUgaW4gdjQgYmVjYXVzZSB0aGlzIGlzIHVzZWQgYnkgbWFueSBwbHVnaW5zXG4gICAgbWV0YS5wYXRoID0gcGF0aDtcbiAgfVxuXG4gIHByaXZhdGUgaGFzQmVlbk1vdW50ZWRBbmRCb290c3RyYXBwZWQobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCB2YWx1ZUlzQm9vdHN0cmFwcGVkSW5Jbml0aWFsU3RhdGU6IGJvb2xlYW4gPVxuICAgICAgZ2V0VmFsdWUodGhpcy5faW5pdGlhbFN0YXRlLCBwYXRoKSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIFRoaXMgY2hlY2tzIHdoZXRoZXIgYSBzdGF0ZSBoYXMgYmVlbiBhbHJlYWR5IGFkZGVkIHRvIHRoZSBnbG9iYWwgZ3JhcGggYW5kXG4gICAgLy8gaXRzIGxpZmVjeWNsZSBpcyBpbiAnYm9vdHN0cmFwcGVkJyBzdGF0ZS5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNCeU5hbWVbbmFtZV0gJiYgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlO1xuICB9XG59XG4iXX0=