import { Injectable } from '@angular/core';
import { isStateOperator } from '@ngxs/store/operators';
import { setValue, getValue } from '../utils/utils';
import { InternalStateOperations } from '../internal/state-operations';
import { simplePatch } from './state-operators';
import * as i0 from "@angular/core";
import * as i1 from "../internal/state-operations";
/**
 * State Context factory class
 * @ignore
 */
export class StateContextFactory {
    constructor(_internalStateOperations) {
        this._internalStateOperations = _internalStateOperations;
    }
    /**
     * Create the state context
     */
    createStateContext(mappedStore) {
        const root = this._internalStateOperations.getRootStateOperations();
        return {
            getState() {
                const currentAppState = root.getState();
                return getState(currentAppState, mappedStore.path);
            },
            patchState(val) {
                const currentAppState = root.getState();
                const patchOperator = simplePatch(val);
                return setStateFromOperator(root, currentAppState, patchOperator, mappedStore.path);
            },
            setState(val) {
                const currentAppState = root.getState();
                return isStateOperator(val)
                    ? setStateFromOperator(root, currentAppState, val, mappedStore.path)
                    : setStateValue(root, currentAppState, val, mappedStore.path);
            },
            dispatch(actions) {
                return root.dispatch(actions);
            }
        };
    }
}
/** @nocollapse */ StateContextFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateContextFactory, deps: [{ token: i1.InternalStateOperations }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ StateContextFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateContextFactory, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: StateContextFactory, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.InternalStateOperations }]; } });
function setStateValue(root, currentAppState, newValue, path) {
    const newAppState = setValue(currentAppState, path, newValue);
    root.setState(newAppState);
    return newAppState;
    // In doing this refactoring I noticed that there is a 'bug' where the
    // application state is returned instead of this state slice.
    // This has worked this way since the beginning see:
    // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts
    // This needs to be fixed, but is a 'breaking' change.
    // I will do this fix in a subsequent PR and we can decide how to handle it.
}
function setStateFromOperator(root, currentAppState, stateOperator, path) {
    const local = getState(currentAppState, path);
    const newValue = stateOperator(local);
    return setStateValue(root, currentAppState, newValue, path);
}
function getState(currentAppState, path) {
    return getValue(currentAppState, path);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtY29udGV4dC1mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvc3RvcmUvc3JjL2ludGVybmFsL3N0YXRlLWNvbnRleHQtZmFjdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzNDLE9BQU8sRUFBZ0MsZUFBZSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFJdEYsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUN2RSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7OztBQUVoRDs7O0dBR0c7QUFFSCxNQUFNLE9BQU8sbUJBQW1CO0lBQzlCLFlBQW9CLHdCQUFpRDtRQUFqRCw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQXlCO0lBQUcsQ0FBQztJQUV6RTs7T0FFRztJQUNILGtCQUFrQixDQUFJLFdBQXdCO1FBQzVDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO1FBRXBFLE9BQU87WUFDTCxRQUFRO2dCQUNOLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDeEMsT0FBTyxRQUFRLENBQUMsZUFBZSxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNyRCxDQUFDO1lBQ0QsVUFBVSxDQUFDLEdBQWU7Z0JBQ3hCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDeEMsTUFBTSxhQUFhLEdBQUcsV0FBVyxDQUFJLEdBQUcsQ0FBQyxDQUFDO2dCQUMxQyxPQUFPLG9CQUFvQixDQUFDLElBQUksRUFBRSxlQUFlLEVBQUUsYUFBYSxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0RixDQUFDO1lBQ0QsUUFBUSxDQUFDLEdBQXlCO2dCQUNoQyxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ3hDLE9BQU8sZUFBZSxDQUFDLEdBQUcsQ0FBQztvQkFDekIsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLElBQUksRUFBRSxlQUFlLEVBQUUsR0FBRyxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUM7b0JBQ3BFLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLGVBQWUsRUFBRSxHQUFHLEVBQUUsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2xFLENBQUM7WUFDRCxRQUFRLENBQUMsT0FBb0I7Z0JBQzNCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNoQyxDQUFDO1NBQ0YsQ0FBQztJQUNKLENBQUM7O29JQTdCVSxtQkFBbUI7d0lBQW5CLG1CQUFtQixjQUROLE1BQU07NEZBQ25CLG1CQUFtQjtrQkFEL0IsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7O0FBaUNsQyxTQUFTLGFBQWEsQ0FDcEIsSUFBMEIsRUFDMUIsZUFBb0IsRUFDcEIsUUFBVyxFQUNYLElBQVk7SUFFWixNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsZUFBZSxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztJQUM5RCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzNCLE9BQU8sV0FBVyxDQUFDO0lBQ25CLHNFQUFzRTtJQUN0RSw2REFBNkQ7SUFDN0Qsb0RBQW9EO0lBQ3BELG9HQUFvRztJQUNwRyxzREFBc0Q7SUFDdEQsNEVBQTRFO0FBQzlFLENBQUM7QUFFRCxTQUFTLG9CQUFvQixDQUMzQixJQUEwQixFQUMxQixlQUFvQixFQUNwQixhQUErQixFQUMvQixJQUFZO0lBRVosTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM5QyxNQUFNLFFBQVEsR0FBRyxhQUFhLENBQUMsS0FBeUIsQ0FBQyxDQUFDO0lBQzFELE9BQU8sYUFBYSxDQUFDLElBQUksRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzlELENBQUM7QUFFRCxTQUFTLFFBQVEsQ0FBSSxlQUFvQixFQUFFLElBQVk7SUFDckQsT0FBTyxRQUFRLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3pDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEV4aXN0aW5nU3RhdGUsIFN0YXRlT3BlcmF0b3IsIGlzU3RhdGVPcGVyYXRvciB9IGZyb20gJ0BuZ3hzL3N0b3JlL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IFN0YXRlQ29udGV4dCB9IGZyb20gJy4uL3N5bWJvbHMnO1xuaW1wb3J0IHsgTWFwcGVkU3RvcmUsIFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4uL2ludGVybmFsL2ludGVybmFscyc7XG5pbXBvcnQgeyBzZXRWYWx1ZSwgZ2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgeyBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucyB9IGZyb20gJy4uL2ludGVybmFsL3N0YXRlLW9wZXJhdGlvbnMnO1xuaW1wb3J0IHsgc2ltcGxlUGF0Y2ggfSBmcm9tICcuL3N0YXRlLW9wZXJhdG9ycyc7XG5cbi8qKlxuICogU3RhdGUgQ29udGV4dCBmYWN0b3J5IGNsYXNzXG4gKiBAaWdub3JlXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgU3RhdGVDb250ZXh0RmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2ludGVybmFsU3RhdGVPcGVyYXRpb25zOiBJbnRlcm5hbFN0YXRlT3BlcmF0aW9ucykge31cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBzdGF0ZSBjb250ZXh0XG4gICAqL1xuICBjcmVhdGVTdGF0ZUNvbnRleHQ8VD4obWFwcGVkU3RvcmU6IE1hcHBlZFN0b3JlKTogU3RhdGVDb250ZXh0PFQ+IHtcbiAgICBjb25zdCByb290ID0gdGhpcy5faW50ZXJuYWxTdGF0ZU9wZXJhdGlvbnMuZ2V0Um9vdFN0YXRlT3BlcmF0aW9ucygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFN0YXRlKCk6IFQge1xuICAgICAgICBjb25zdCBjdXJyZW50QXBwU3RhdGUgPSByb290LmdldFN0YXRlKCk7XG4gICAgICAgIHJldHVybiBnZXRTdGF0ZShjdXJyZW50QXBwU3RhdGUsIG1hcHBlZFN0b3JlLnBhdGgpO1xuICAgICAgfSxcbiAgICAgIHBhdGNoU3RhdGUodmFsOiBQYXJ0aWFsPFQ+KTogVCB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBcHBTdGF0ZSA9IHJvb3QuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgcGF0Y2hPcGVyYXRvciA9IHNpbXBsZVBhdGNoPFQ+KHZhbCk7XG4gICAgICAgIHJldHVybiBzZXRTdGF0ZUZyb21PcGVyYXRvcihyb290LCBjdXJyZW50QXBwU3RhdGUsIHBhdGNoT3BlcmF0b3IsIG1hcHBlZFN0b3JlLnBhdGgpO1xuICAgICAgfSxcbiAgICAgIHNldFN0YXRlKHZhbDogVCB8IFN0YXRlT3BlcmF0b3I8VD4pOiBUIHtcbiAgICAgICAgY29uc3QgY3VycmVudEFwcFN0YXRlID0gcm9vdC5nZXRTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gaXNTdGF0ZU9wZXJhdG9yKHZhbClcbiAgICAgICAgICA/IHNldFN0YXRlRnJvbU9wZXJhdG9yKHJvb3QsIGN1cnJlbnRBcHBTdGF0ZSwgdmFsLCBtYXBwZWRTdG9yZS5wYXRoKVxuICAgICAgICAgIDogc2V0U3RhdGVWYWx1ZShyb290LCBjdXJyZW50QXBwU3RhdGUsIHZhbCwgbWFwcGVkU3RvcmUucGF0aCk7XG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2goYWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHJvb3QuZGlzcGF0Y2goYWN0aW9ucyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZVZhbHVlPFQ+KFxuICByb290OiBTdGF0ZU9wZXJhdGlvbnM8YW55PixcbiAgY3VycmVudEFwcFN0YXRlOiBhbnksXG4gIG5ld1ZhbHVlOiBULFxuICBwYXRoOiBzdHJpbmdcbik6IGFueSB7XG4gIGNvbnN0IG5ld0FwcFN0YXRlID0gc2V0VmFsdWUoY3VycmVudEFwcFN0YXRlLCBwYXRoLCBuZXdWYWx1ZSk7XG4gIHJvb3Quc2V0U3RhdGUobmV3QXBwU3RhdGUpO1xuICByZXR1cm4gbmV3QXBwU3RhdGU7XG4gIC8vIEluIGRvaW5nIHRoaXMgcmVmYWN0b3JpbmcgSSBub3RpY2VkIHRoYXQgdGhlcmUgaXMgYSAnYnVnJyB3aGVyZSB0aGVcbiAgLy8gYXBwbGljYXRpb24gc3RhdGUgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiB0aGlzIHN0YXRlIHNsaWNlLlxuICAvLyBUaGlzIGhhcyB3b3JrZWQgdGhpcyB3YXkgc2luY2UgdGhlIGJlZ2lubmluZyBzZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uZ3hzL3N0b3JlL2JsYW1lLzMyNGM2NjdiNGI3ZGViZDhlYjk3OTAwNmM2N2NhMGFlMzQ3ZDg4Y2Qvc3JjL3N0YXRlLWZhY3RvcnkudHNcbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCwgYnV0IGlzIGEgJ2JyZWFraW5nJyBjaGFuZ2UuXG4gIC8vIEkgd2lsbCBkbyB0aGlzIGZpeCBpbiBhIHN1YnNlcXVlbnQgUFIgYW5kIHdlIGNhbiBkZWNpZGUgaG93IHRvIGhhbmRsZSBpdC5cbn1cblxuZnVuY3Rpb24gc2V0U3RhdGVGcm9tT3BlcmF0b3I8VD4oXG4gIHJvb3Q6IFN0YXRlT3BlcmF0aW9uczxhbnk+LFxuICBjdXJyZW50QXBwU3RhdGU6IGFueSxcbiAgc3RhdGVPcGVyYXRvcjogU3RhdGVPcGVyYXRvcjxUPixcbiAgcGF0aDogc3RyaW5nXG4pIHtcbiAgY29uc3QgbG9jYWwgPSBnZXRTdGF0ZShjdXJyZW50QXBwU3RhdGUsIHBhdGgpO1xuICBjb25zdCBuZXdWYWx1ZSA9IHN0YXRlT3BlcmF0b3IobG9jYWwgYXMgRXhpc3RpbmdTdGF0ZTxUPik7XG4gIHJldHVybiBzZXRTdGF0ZVZhbHVlKHJvb3QsIGN1cnJlbnRBcHBTdGF0ZSwgbmV3VmFsdWUsIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZTxUPihjdXJyZW50QXBwU3RhdGU6IGFueSwgcGF0aDogc3RyaW5nKTogVCB7XG4gIHJldHVybiBnZXRWYWx1ZShjdXJyZW50QXBwU3RhdGUsIHBhdGgpO1xufVxuIl19