import { META_KEY, META_OPTIONS_KEY, SELECTOR_META_KEY } from '../symbols';
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 */
export function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        const defaultMetadata = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            makeRootSelector(context) {
                return context.getStateGetter(defaultMetadata.name);
            },
            children: []
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 */
export function getStoreMetadata(target) {
    return target[META_KEY];
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 */
export function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        const defaultMetadata = {
            makeRootSelector: null,
            originalFn: null,
            containerClass: null,
            selectorName: null,
            getSelectorOptions: () => ({})
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 */
export function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 */
function compliantPropGetter(paths) {
    const copyOfPaths = paths.slice();
    return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 */
function fastPropGetter(paths) {
    const segments = paths;
    let seg = 'store.' + segments[0];
    let i = 0;
    const l = segments.length;
    let expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    const fn = new Function('store', 'return ' + expr + ';');
    return fn;
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 */
export function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 */
export function buildGraph(stateClasses) {
    const findName = (stateClass) => {
        const meta = stateClasses.find(g => g === stateClass);
        // Caretaker note: we have still left the `typeof` condition in order to avoid
        // creating a breaking change for projects that still use the View Engine.
        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {
            throw new Error(`Child state not found: ${stateClass}. \r\nYou may have forgotten to add states to module`);
        }
        return meta[META_KEY].name;
    };
    return stateClasses.reduce((result, stateClass) => {
        const { name, children } = stateClass[META_KEY];
        result[name] = (children || []).map(findName);
        return result;
    }, {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 */
export function nameToState(states) {
    return states.reduce((result, stateClass) => {
        const meta = stateClass[META_KEY];
        result[meta.name] = stateClass;
        return result;
    }, {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 */
export function findFullParentPath(obj, newObj = {}) {
    const visit = (child, keyToFind) => {
        for (const key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                const parent = visit(child, key);
                return parent !== null ? `${parent}.${key}` : key;
            }
        }
        return null;
    };
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            const parent = visit(obj, key);
            newObj[key] = parent ? `${parent}.${key}` : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 */
export function topologicalSort(graph) {
    const sorted = [];
    const visited = {};
    const visit = (name, ancestors = []) => {
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((dep) => {
            // Caretaker note: we have still left the `typeof` condition in order to avoid
            // creating a breaking change for projects that still use the View Engine.
            if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {
                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        });
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    };
    Object.keys(graph).forEach(k => visit(k));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 */
export function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvc3RvcmUvc3JjL2ludGVybmFsL2ludGVybmFscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFHQSxPQUFPLEVBQ0wsUUFBUSxFQUNSLGdCQUFnQixFQUVoQixpQkFBaUIsRUFFbEIsTUFBTSxZQUFZLENBQUM7QUFnRXBCOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsTUFBMEI7SUFDNUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDcEMsTUFBTSxlQUFlLEdBQWtCO1lBQ3JDLElBQUksRUFBRSxJQUFJO1lBQ1YsT0FBTyxFQUFFLEVBQUU7WUFDWCxRQUFRLEVBQUUsRUFBRTtZQUNaLElBQUksRUFBRSxJQUFJO1lBQ1YsZ0JBQWdCLENBQUMsT0FBK0I7Z0JBQzlDLE9BQU8sT0FBTyxDQUFDLGNBQWMsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdEQsQ0FBQztZQUNELFFBQVEsRUFBRSxFQUFFO1NBQ2IsQ0FBQztRQUVGLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxFQUFFLEtBQUssRUFBRSxlQUFlLEVBQUUsQ0FBQyxDQUFDO0tBQ3JFO0lBQ0QsT0FBTyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNsQyxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxNQUEwQjtJQUN6RCxPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUUsQ0FBQztBQUMzQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxzQkFBc0IsQ0FBQyxNQUFnQjtJQUNyRCxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO1FBQzdDLE1BQU0sZUFBZSxHQUEwQjtZQUM3QyxnQkFBZ0IsRUFBRSxJ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QVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FDbkYsQ0FBQzthQUNIO1lBRUQsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ2hCLE9BQU87YUFDUjtZQUVELEtBQUssQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2pDLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUM1QixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ25CO0lBQ0gsQ0FBQyxDQUFDO0lBRUYsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUxQyxPQUFPLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUMxQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxRQUFRLENBQUMsR0FBUTtJQUMvQixPQUFPLENBQUMsT0FBTyxHQUFHLEtBQUssUUFBUSxJQUFJLEdBQUcsS0FBSyxJQUFJLENBQUMsSUFBSSxPQUFPLEdBQUcsS0FBSyxVQUFVLENBQUM7QUFDaEYsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsYWluT2JqZWN0T2YsIFN0YXRlQ2xhc3MgfSBmcm9tICdAbmd4cy9zdG9yZS9pbnRlcm5hbHMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQge1xuICBNRVRBX0tFWSxcbiAgTUVUQV9PUFRJT05TX0tFWSxcbiAgTmd4c0NvbmZpZyxcbiAgU0VMRUNUT1JfTUVUQV9LRVksXG4gIFN0b3JlT3B0aW9uc1xufSBmcm9tICcuLi9zeW1ib2xzJztcbmltcG9ydCB7IEFjdGlvbkhhbmRsZXJNZXRhRGF0YSB9IGZyb20gJy4uL2FjdGlvbnMvc3ltYm9scyc7XG5cbi8vIGluc3BpcmVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQzNjc0Mzg5XG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ2xhc3NJbnRlcm5hbDxUID0gYW55LCBVID0gYW55PiBleHRlbmRzIFN0YXRlQ2xhc3M8VD4ge1xuICBbTUVUQV9LRVldPzogTWV0YURhdGFNb2RlbDtcbiAgW01FVEFfT1BUSU9OU19LRVldPzogU3RvcmVPcHRpb25zPFU+O1xufVxuXG5leHBvcnQgdHlwZSBTdGF0ZUtleUdyYXBoID0gUGxhaW5PYmplY3RPZjxzdHJpbmdbXT47XG5leHBvcnQgdHlwZSBTdGF0ZXNCeU5hbWUgPSBQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVPcGVyYXRpb25zPFQ+IHtcbiAgZ2V0U3RhdGUoKTogVDtcblxuICBzZXRTdGF0ZSh2YWw6IFQpOiBUO1xuXG4gIGRpc3BhdGNoKGFjdGlvbk9yQWN0aW9uczogYW55IHwgYW55W10pOiBPYnNlcnZhYmxlPHZvaWQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1ldGFEYXRhTW9kZWwge1xuICBuYW1lOiBzdHJpbmcgfCBudWxsO1xuICBhY3Rpb25zOiBQbGFpbk9iamVjdE9mPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcbiAgZGVmYXVsdHM6IGFueTtcbiAgcGF0aDogc3RyaW5nIHwgbnVsbDtcbiAgbWFrZVJvb3RTZWxlY3RvcjogU2VsZWN0b3JGYWN0b3J5IHwgbnVsbDtcbiAgY2hpbGRyZW4/OiBTdGF0ZUNsYXNzSW50ZXJuYWxbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdW50aW1lU2VsZWN0b3JDb250ZXh0IHtcbiAgZ2V0U3RhdGVHZXR0ZXIoa2V5OiBhbnkpOiAoc3RhdGU6IGFueSkgPT4gYW55O1xuICBnZXRTZWxlY3Rvck9wdGlvbnMobG9jYWxPcHRpb25zPzogU2hhcmVkU2VsZWN0b3JPcHRpb25zKTogU2hhcmVkU2VsZWN0b3JPcHRpb25zO1xufVxuXG5leHBvcnQgdHlwZSBTZWxlY3RGcm9tUm9vdFN0YXRlID0gKHJvb3RTdGF0ZTogYW55KSA9PiBhbnk7XG5leHBvcnQgdHlwZSBTZWxlY3RvckZhY3RvcnkgPSAocnVudGltZUNvbnRleHQ6IFJ1bnRpbWVTZWxlY3RvckNvbnRleHQpID0+IFNlbGVjdEZyb21Sb290U3RhdGU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2hhcmVkU2VsZWN0b3JPcHRpb25zIHtcbiAgaW5qZWN0Q29udGFpbmVyU3RhdGU/OiBib29sZWFuO1xuICBzdXBwcmVzc0Vycm9ycz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcbiAgbWFrZVJvb3RTZWxlY3RvcjogU2VsZWN0b3JGYWN0b3J5IHwgbnVsbDtcbiAgb3JpZ2luYWxGbjogRnVuY3Rpb24gfCBudWxsO1xuICBjb250YWluZXJDbGFzczogYW55O1xuICBzZWxlY3Rvck5hbWU6IHN0cmluZyB8IG51bGw7XG4gIGdldFNlbGVjdG9yT3B0aW9uczogKCkgPT4gU2hhcmVkU2VsZWN0b3JPcHRpb25zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hcHBlZFN0b3JlIHtcbiAgbmFtZTogc3RyaW5nO1xuICBpc0luaXRpYWxpc2VkOiBib29sZWFuO1xuICBhY3Rpb25zOiBQbGFpbk9iamVjdE9mPEFjdGlvbkhhbmRsZXJNZXRhRGF0YVtdPjtcbiAgZGVmYXVsdHM6IGFueTtcbiAgaW5zdGFuY2U6IGFueTtcbiAgcGF0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlc0FuZERlZmF1bHRzIHtcbiAgZGVmYXVsdHM6IGFueTtcbiAgc3RhdGVzOiBNYXBwZWRTdG9yZVtdO1xufVxuXG4vKipcbiAqIEVuc3VyZXMgbWV0YWRhdGEgaXMgYXR0YWNoZWQgdG8gdGhlIGNsYXNzIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0OiBTdGF0ZUNsYXNzSW50ZXJuYWwpOiBNZXRhRGF0YU1vZGVsIHtcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoTUVUQV9LRVkpKSB7XG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBNZXRhRGF0YU1vZGVsID0ge1xuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIGFjdGlvbnM6IHt9LFxuICAgICAgZGVmYXVsdHM6IHt9LFxuICAgICAgcGF0aDogbnVsbCxcbiAgICAgIG1ha2VSb290U2VsZWN0b3IoY29udGV4dDogUnVudGltZVNlbGVjdG9yQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5nZXRTdGF0ZUdldHRlcihkZWZhdWx0TWV0YWRhdGEubmFtZSk7XG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIE1FVEFfS0VZLCB7IHZhbHVlOiBkZWZhdWx0TWV0YWRhdGEgfSk7XG4gIH1cbiAgcmV0dXJuIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBzdGF0ZSBjbGFzcyBpZiBpdCBleGlzdHMuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQ6IFN0YXRlQ2xhc3NJbnRlcm5hbCk6IE1ldGFEYXRhTW9kZWwge1xuICByZXR1cm4gdGFyZ2V0W01FVEFfS0VZXSE7XG59XG5cbi8qKlxuICogRW5zdXJlcyBtZXRhZGF0YSBpcyBhdHRhY2hlZCB0byB0aGUgc2VsZWN0b3IgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQ6IEZ1bmN0aW9uKTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoU0VMRUNUT1JfTUVUQV9LRVkpKSB7XG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwgPSB7XG4gICAgICBtYWtlUm9vdFNlbGVjdG9yOiBudWxsLFxuICAgICAgb3JpZ2luYWxGbjogbnVsbCxcbiAgICAgIGNvbnRhaW5lckNsYXNzOiBudWxsLFxuICAgICAgc2VsZWN0b3JOYW1lOiBudWxsLFxuICAgICAgZ2V0U2VsZWN0b3JPcHRpb25zOiAoKSA9PiAoe30pXG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIFNFTEVDVE9SX01FVEFfS0VZLCB7IHZhbHVlOiBkZWZhdWx0TWV0YWRhdGEgfSk7XG4gIH1cblxuICByZXR1cm4gZ2V0U2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rvck1ldGFkYXRhKHRhcmdldDogYW55KTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcbiAgcmV0dXJuIHRhcmdldFtTRUxFQ1RPUl9NRVRBX0tFWV07XG59XG5cbi8qKlxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcbiAqXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cbiAqXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCBhcyBmYXN0IGFzIHRoZSBgZmFzdFByb3BHZXR0ZXJgIGJ1dCBpcyBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgY29tcGxpYW50LlxuICogU2VlIHBlcmYgaGl0OiBodHRwczovL2pzcGVyZi5jb20vZmFzdC12YWx1ZS1nZXR0ZXItZ2l2ZW4tcGF0aC8xXG4gKlxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBjb21wbGlhbnRQcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSk6ICh4OiBhbnkpID0+IGFueSB7XG4gIGNvbnN0IGNvcHlPZlBhdGhzID0gcGF0aHMuc2xpY2UoKTtcbiAgcmV0dXJuIG9iaiA9PiBjb3B5T2ZQYXRocy5yZWR1Y2UoKGFjYzogYW55LCBwYXJ0OiBzdHJpbmcpID0+IGFjYyAmJiBhY2NbcGFydF0sIG9iaik7XG59XG5cbi8qKlxuICogVGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbjpcbiAqIC0gcGx1Y2sgKE9ic2VydmFibGUgb3BlcmF0b3IpXG4gKiAtIG1lbW9pemVcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGZhc3RQcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSk6ICh4OiBhbnkpID0+IGFueSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aHM7XG4gIGxldCBzZWcgPSAnc3RvcmUuJyArIHNlZ21lbnRzWzBdO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGwgPSBzZWdtZW50cy5sZW5ndGg7XG5cbiAgbGV0IGV4cHIgPSBzZWc7XG4gIHdoaWxlICgrK2kgPCBsKSB7XG4gICAgZXhwciA9IGV4cHIgKyAnICYmICcgKyAoc2VnID0gc2VnICsgJy4nICsgc2VnbWVudHNbaV0pO1xuICB9XG5cbiAgY29uc3QgZm4gPSBuZXcgRnVuY3Rpb24oJ3N0b3JlJywgJ3JldHVybiAnICsgZXhwciArICc7Jyk7XG5cbiAgcmV0dXJuIDwoeDogYW55KSA9PiBhbnk+Zm47XG59XG5cbi8qKlxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcbiAqXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSwgY29uZmlnOiBOZ3hzQ29uZmlnKSB7XG4gIGlmIChjb25maWcgJiYgY29uZmlnLmNvbXBhdGliaWxpdHkgJiYgY29uZmlnLmNvbXBhdGliaWxpdHkuc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5KSB7XG4gICAgcmV0dXJuIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYXN0UHJvcEdldHRlcihwYXRocyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBzdGF0ZXMsIGl0IHdpbGwgcmV0dXJuIGEgb2JqZWN0IGdyYXBoLiBFeGFtcGxlOlxuICogICAgY29uc3Qgc3RhdGVzID0gW1xuICogICAgICBDYXJ0LFxuICogICAgICBDYXJ0U2F2ZWQsXG4gKiAgICAgIENhcnRTYXZlZEl0ZW1zXG4gKiAgICBdXG4gKlxuICogd291bGQgcmV0dXJuOlxuICpcbiAqICBjb25zdCBncmFwaCA9IHtcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXG4gKiAgICBpdGVtczogW11cbiAqICB9O1xuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR3JhcGgoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IFN0YXRlS2V5R3JhcGgge1xuICBjb25zdCBmaW5kTmFtZSA9IChzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwpID0+IHtcbiAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc2VzLmZpbmQoZyA9PiBnID09PSBzdGF0ZUNsYXNzKTtcblxuICAgIC8vIENhcmV0YWtlciBub3RlOiB3ZSBoYXZlIHN0aWxsIGxlZnQgdGhlIGB0eXBlb2ZgIGNvbmRpdGlvbiBpbiBvcmRlciB0byBhdm9pZFxuICAgIC8vIGNyZWF0aW5nIGEgYnJlYWtpbmcgY2hhbmdlIGZvciBwcm9qZWN0cyB0aGF0IHN0aWxsIHVzZSB0aGUgVmlldyBFbmdpbmUuXG4gICAgaWYgKCh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpICYmICFtZXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDaGlsZCBzdGF0ZSBub3QgZm91bmQ6ICR7c3RhdGVDbGFzc30uIFxcclxcbllvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gYWRkIHN0YXRlcyB0byBtb2R1bGVgXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRhIVtNRVRBX0tFWV0hLm5hbWUhO1xuICB9O1xuXG4gIHJldHVybiBzdGF0ZUNsYXNzZXMucmVkdWNlPFN0YXRlS2V5R3JhcGg+KFxuICAgIChyZXN1bHQ6IFN0YXRlS2V5R3JhcGgsIHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3NJbnRlcm5hbCkgPT4ge1xuICAgICAgY29uc3QgeyBuYW1lLCBjaGlsZHJlbiB9ID0gc3RhdGVDbGFzc1tNRVRBX0tFWV0hO1xuICAgICAgcmVzdWx0W25hbWUhXSA9IChjaGlsZHJlbiB8fCBbXSkubWFwKGZpbmROYW1lKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgc3RhdGVzIGFycmF5LCByZXR1cm5zIG9iamVjdCBncmFwaFxuICogcmV0dXJuaW5nIHRoZSBuYW1lIGFuZCBzdGF0ZSBtZXRhZGF0YS4gRXhhbXBsZTpcbiAqXG4gKiAgY29uc3QgZ3JhcGggPSB7XG4gKiAgICBjYXJ0OiB7IG1ldGFkYXRhIH1cbiAqICB9O1xuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hbWVUb1N0YXRlKHN0YXRlczogU3RhdGVDbGFzc0ludGVybmFsW10pOiBQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD4ge1xuICByZXR1cm4gc3RhdGVzLnJlZHVjZTxQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD4+KFxuICAgIChyZXN1bHQ6IFBsYWluT2JqZWN0T2Y8U3RhdGVDbGFzc0ludGVybmFsPiwgc3RhdGVDbGFzczogU3RhdGVDbGFzc0ludGVybmFsKSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc1tNRVRBX0tFWV0hO1xuICAgICAgcmVzdWx0W21ldGEubmFtZSFdID0gc3RhdGVDbGFzcztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgb2JqZWN0IHJlbGF0aW9uc2hpcCBncmFwaCB3aWxsIHJldHVybiB0aGUgZnVsbCBwYXRoXG4gKiBmb3IgdGhlIGNoaWxkIGl0ZW1zLiBFeGFtcGxlOlxuICpcbiAqICBjb25zdCBncmFwaCA9IHtcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXG4gKiAgICBpdGVtczogW11cbiAqICB9O1xuICpcbiAqIHdvdWxkIHJldHVybjpcbiAqXG4gKiAgY29uc3QgciA9IHtcbiAqICAgIGNhcnQ6ICdjYXJ0JyxcbiAqICAgIHNhdmVkOiAnY2FydC5zYXZlZCcsXG4gKiAgICBpdGVtczogJ2NhcnQuc2F2ZWQuaXRlbXMnXG4gKiAgfTtcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRnVsbFBhcmVudFBhdGgoXG4gIG9iajogU3RhdGVLZXlHcmFwaCxcbiAgbmV3T2JqOiBQbGFpbk9iamVjdE9mPHN0cmluZz4gPSB7fVxuKTogUGxhaW5PYmplY3RPZjxzdHJpbmc+IHtcbiAgY29uc3QgdmlzaXQgPSAoY2hpbGQ6IFN0YXRlS2V5R3JhcGgsIGtleVRvRmluZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGNoaWxkW2tleV0uaW5kZXhPZihrZXlUb0ZpbmQpID49IDApIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQoY2hpbGQsIGtleSk7XG4gICAgICAgIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBgJHtwYXJlbnR9LiR7a2V5fWAgOiBrZXk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gdmlzaXQob2JqLCBrZXkpO1xuICAgICAgbmV3T2JqW2tleV0gPSBwYXJlbnQgPyBgJHtwYXJlbnR9LiR7a2V5fWAgOiBrZXk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIG9iamVjdCBncmFwaCwgaXQgd2lsbCByZXR1cm4gdGhlIGl0ZW1zIHRvcG9sb2dpY2FsbHkgc29ydGVkIEV4YW1wbGU6XG4gKlxuICogIGNvbnN0IGdyYXBoID0ge1xuICogICAgY2FydDogWydzYXZlZCddLFxuICogICAgc2F2ZWQ6IFsnaXRlbXMnXSxcbiAqICAgIGl0ZW1zOiBbXVxuICogIH07XG4gKlxuICogd291bGQgcmV0dXJuOlxuICpcbiAqICBjb25zdCByZXN1bHRzID0gW1xuICogICAgJ2l0ZW1zJyxcbiAqICAgICdzYXZlZCcsXG4gKiAgICAnY2FydCdcbiAqICBdO1xuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvcG9sb2dpY2FsU29ydChncmFwaDogU3RhdGVLZXlHcmFwaCk6IHN0cmluZ1tdIHtcbiAgY29uc3Qgc29ydGVkOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCB2aXNpdGVkOiBQbGFpbk9iamVjdE9mPGJvb2xlYW4+ID0ge307XG5cbiAgY29uc3QgdmlzaXQgPSAobmFtZTogc3RyaW5nLCBhbmNlc3RvcnM6IHN0cmluZ1tdID0gW10pID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYW5jZXN0b3JzKSkge1xuICAgICAgYW5jZXN0b3JzID0gW107XG4gICAgfVxuXG4gICAgYW5jZXN0b3JzLnB1c2gobmFtZSk7XG4gICAgdmlzaXRlZFtuYW1lXSA9IHRydWU7XG5cbiAgICBncmFwaFtuYW1lXS5mb3JFYWNoKChkZXA6IHN0cmluZykgPT4ge1xuICAgICAgLy8gQ2FyZXRha2VyIG5vdGU6IHdlIGhhdmUgc3RpbGwgbGVmdCB0aGUgYHR5cGVvZmAgY29uZGl0aW9uIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAvLyBjcmVhdGluZyBhIGJyZWFraW5nIGNoYW5nZSBmb3IgcHJvamVjdHMgdGhhdCBzdGlsbCB1c2UgdGhlIFZpZXcgRW5naW5lLlxuICAgICAgaWYgKCh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpICYmIGFuY2VzdG9ycy5pbmRleE9mKGRlcCkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENpcmN1bGFyIGRlcGVuZGVuY3kgJyR7ZGVwfScgaXMgcmVxdWlyZWQgYnkgJyR7bmFtZX0nOiAke2FuY2VzdG9ycy5qb2luKCcgLT4gJyl9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodmlzaXRlZFtkZXBdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmlzaXQoZGVwLCBhbmNlc3RvcnMuc2xpY2UoMCkpO1xuICAgIH0pO1xuXG4gICAgaWYgKHNvcnRlZC5pbmRleE9mKG5hbWUpIDwgMCkge1xuICAgICAgc29ydGVkLnB1c2gobmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIE9iamVjdC5rZXlzKGdyYXBoKS5mb3JFYWNoKGsgPT4gdmlzaXQoaykpO1xuXG4gIHJldHVybiBzb3J0ZWQucmV2ZXJzZSgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIG9iamVjdCBvciBub3QuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3Qob2JqOiBhbnkpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwpIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG59XG4iXX0=