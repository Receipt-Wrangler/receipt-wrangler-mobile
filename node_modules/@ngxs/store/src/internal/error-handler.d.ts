import { Injector } from '@angular/core';
import { Observable } from 'rxjs';
import { NgxsExecutionStrategy } from '../execution/symbols';
import * as i0 from "@angular/core";
/**
 * This operator is used for piping the observable result
 * from the `dispatch()`. It has a "smart" error handling
 * strategy that allows us to decide whether we propagate
 * errors to Angular's `ErrorHandler` or enable users to
 * handle them manually. We consider following cases:
 * 1) `store.dispatch()` (no subscribe) -> call `handleError()`
 * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`
 * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`
 * 4) `toPromise()` without `catch` -> do `handleError()`
 * 5) `toPromise()` with `catch` -> don't `handleError()`
 */
export declare function ngxsErrorHandler<T>(internalErrorReporter: InternalErrorReporter, ngxsExecutionStrategy: NgxsExecutionStrategy): (source: Observable<T>) => Observable<unknown>;
export declare class InternalErrorReporter {
    private _injector;
    /** Will be set lazily to be backward compatible. */
    private _errorHandler;
    constructor(_injector: Injector);
    reportErrorSafely(error: any): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<InternalErrorReporter, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<InternalErrorReporter>;
}
