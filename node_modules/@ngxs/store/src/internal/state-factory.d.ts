import { Injector, OnDestroy } from '@angular/core';
import { Observable } from 'rxjs';
import { NgxsConfig } from '../symbols';
import { MappedStore, StateClassInternal, StatesAndDefaults, StatesByName, RuntimeSelectorContext } from './internals';
import { ActionContext, InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import * as i0 from "@angular/core";
/**
 * The `StateFactory` class adds root and feature states to the graph.
 * This extracts state names from state classes, checks if they already
 * exist in the global graph, throws errors if their names are invalid, etc.
 * See its constructor, state factories inject state factories that are
 * parent-level providers. This is required to get feature states from the
 * injector on the same level.
 *
 * The `NgxsModule.forFeature(...)` returns `providers: [StateFactory, ...states]`.
 * The `StateFactory` is initialized on the feature level and goes through `...states`
 * to get them from the injector through `injector.get(state)`.
 * @ignore
 */
export declare class StateFactory implements OnDestroy {
    private _injector;
    private _config;
    private _parentFactory;
    private _actions;
    private _actionResults;
    private _stateContextFactory;
    private _initialState;
    private _actionsSubscription;
    constructor(_injector: Injector, _config: NgxsConfig, _parentFactory: StateFactory, _actions: InternalActions, _actionResults: InternalDispatchedActionResults, _stateContextFactory: StateContextFactory, _initialState: any);
    private _states;
    get states(): MappedStore[];
    private _statesByName;
    get statesByName(): StatesByName;
    private _statePaths;
    private get statePaths();
    getRuntimeSelectorContext: () => RuntimeSelectorContext;
    private static _cloneDefaults;
    ngOnDestroy(): void;
    /**
     * Add a new state to the global defs.
     */
    add(stateClasses: StateClassInternal[]): MappedStore[];
    /**
     * Add a set of states to the store and return the defaults
     */
    addAndReturnDefaults(stateClasses: StateClassInternal[]): StatesAndDefaults;
    connectActionHandlers(): void;
    /**
     * Invoke actions on the states.
     */
    invokeActions(dispatched$: Observable<ActionContext>, action: any): Observable<unknown[]>;
    private addToStatesMap;
    private addRuntimeInfoToMeta;
    private hasBeenMountedAndBootstrapped;
    static ɵfac: i0.ɵɵFactoryDeclaration<StateFactory, [null, null, { optional: true; skipSelf: true; }, null, null, null, { optional: true; }]>;
    static ɵprov: i0.ɵɵInjectableDeclaration<StateFactory>;
}
