import { Type } from '@angular/core';
import { Observable, Subscription } from 'rxjs';
import { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';
import { InternalStateOperations } from './internal/state-operations';
import { StateStream } from './internal/state-stream';
import { NgxsConfig } from './symbols';
import { StateToken } from './state-token/state-token';
import { StateFactory } from './internal/state-factory';
import * as i0 from "@angular/core";
export declare class Store {
    private _stateStream;
    private _internalStateOperations;
    private _config;
    private _internalExecutionStrategy;
    private _stateFactory;
    /**
     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,
     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.
     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.
     */
    private _selectableStateStream;
    constructor(_stateStream: StateStream, _internalStateOperations: InternalStateOperations, _config: NgxsConfig, _internalExecutionStrategy: InternalNgxsExecutionStrategy, _stateFactory: StateFactory, initialStateValue: any);
    /**
     * Dispatches event(s).
     */
    dispatch(actionOrActions: any | any[]): Observable<any>;
    /**
     * Selects a slice of data from the store.
     */
    select<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;
    select<T = any>(selector: string | Type<any>): Observable<T>;
    select<T>(selector: StateToken<T>): Observable<T>;
    /**
     * Select one slice of data from the store.
     */
    selectOnce<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;
    selectOnce<T = any>(selector: string | Type<any>): Observable<T>;
    selectOnce<T>(selector: StateToken<T>): Observable<T>;
    /**
     * Select a snapshot from the state.
     */
    selectSnapshot<T>(selector: (state: any, ...states: any[]) => T): T;
    selectSnapshot<T = any>(selector: string | Type<any>): T;
    selectSnapshot<T>(selector: StateToken<T>): T;
    /**
     * Allow the user to subscribe to the root of the state
     */
    subscribe(fn?: (value: any) => void): Subscription;
    /**
     * Return the raw value of the state.
     */
    snapshot(): any;
    /**
     * Reset the state to a specific point in time. This method is useful
     * for plugin's who need to modify the state directly or unit testing.
     */
    reset(state: any): any;
    private getStoreBoundSelectorFn;
    private initStateStream;
    static ɵfac: i0.ɵɵFactoryDeclaration<Store, [null, null, null, null, null, { optional: true; }]>;
    static ɵprov: i0.ɵɵInjectableDeclaration<Store>;
}
