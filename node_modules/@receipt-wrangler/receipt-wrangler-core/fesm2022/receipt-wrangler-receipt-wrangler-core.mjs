import { trigger, state, style, transition, animate } from '@angular/animations';
import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, NgModule, SkipSelf, EventEmitter, Component, ViewEncapsulation, Input, Output, Directive, ViewChild, Pipe } from '@angular/core';
import * as i1 from '@angular/common/http';
import { HttpHeaders, HttpUrlEncodingCodec, HttpParams } from '@angular/common/http';
import * as i2$1 from '@angular/forms';
import { FormControl, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import * as i3$1 from '@angular/router';
import { RouterModule } from '@angular/router';
import * as i1$1 from '@ngxs/store';
import { createSelector, Action, Selector, State } from '@ngxs/store';
import { map, take, switchMap, catchError, tap, forkJoin, of, startWith, BehaviorSubject } from 'rxjs';
import { __decorate, __metadata } from 'tslib';
import * as i1$2 from '@angular/material/snack-bar';
import * as i1$3 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2 from '@angular/material/badge';
import { MatBadgeModule } from '@angular/material/badge';
import * as i3 from '@angular/material/button';
import { MatButtonModule } from '@angular/material/button';
import * as i4 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import * as i5 from '@angular/material/tooltip';
import { MatTooltipModule } from '@angular/material/tooltip';
import * as i3$2 from '@angular/material/form-field';
import { MatFormFieldModule } from '@angular/material/form-field';
import * as i5$1 from '@angular/material/input';
import { MatInputModule } from '@angular/material/input';
import * as i7 from 'ngx-mask';
import { NgxMaskDirective, provideNgxMask } from 'ngx-mask';

const fadeInOut = [
    trigger('fadeInOut', [
        state('void', style({
            opacity: 0,
            visibility: 'hidden',
        })),
        transition(':enter', [
            animate('0.2s', style({
                opacity: 1,
                visibility: 'visible',
            })),
        ]),
        transition(':leave', [
            animate('0.2s', style({
                opacity: 0,
                visibility: 'hidden',
            })),
        ]),
    ]),
];

const BASE_PATH = new InjectionToken('basePath');
const COLLECTION_FORMATS = {
    'csv': ',',
    'tsv': '   ',
    'ssv': ' ',
    'pipes': '|'
};

class Configuration {
    constructor(configurationParameters = {}) {
        this.apiKeys = configurationParameters.apiKeys;
        this.username = configurationParameters.username;
        this.password = configurationParameters.password;
        this.accessToken = configurationParameters.accessToken;
        this.basePath = configurationParameters.basePath;
        this.withCredentials = configurationParameters.withCredentials;
    }
    /**
     * Select the correct content-type to use for a request.
     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param contentTypes - the array of content types that are available for selection
     * @returns the selected content-type or <code>undefined</code> if no selection could be made.
     */
    selectHeaderContentType(contentTypes) {
        if (contentTypes.length == 0) {
            return undefined;
        }
        let type = contentTypes.find(x => this.isJsonMime(x));
        if (type === undefined) {
            return contentTypes[0];
        }
        return type;
    }
    /**
     * Select the correct accept content-type to use for a request.
     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.
     * If no content type is found return the first found type if the contentTypes is not empty
     * @param accepts - the array of content types that are available for selection.
     * @returns the selected content-type or <code>undefined</code> if no selection could be made.
     */
    selectHeaderAccept(accepts) {
        if (accepts.length == 0) {
            return undefined;
        }
        let type = accepts.find(x => this.isJsonMime(x));
        if (type === undefined) {
            return accepts[0];
        }
        return type;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime != null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class AuthService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getNewRefreshToken(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('post', `${this.basePath}/token/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    login(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling login.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/login/`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    logout(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('post', `${this.basePath}/logout/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    signUp(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling signUp.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/signUp`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class CategoryService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    createCategory(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCategory.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/category/`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    deleteCategory(categoryId, observe = 'body', reportProgress = false) {
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling deleteCategory.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('delete', `${this.basePath}/category/${encodeURIComponent(String(categoryId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getAllCategories(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/category/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getCategoryCountByName(categoryName, observe = 'body', reportProgress = false) {
        if (categoryName === null || categoryName === undefined) {
            throw new Error('Required parameter categoryName was null or undefined when calling getCategoryCountByName.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/category/${encodeURIComponent(String(categoryName))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPagedCategories(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling getPagedCategories.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/category/getPagedCategories`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateCategory(body, categoryId, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCategory.');
        }
        if (categoryId === null || categoryId === undefined) {
            throw new Error('Required parameter categoryId was null or undefined when calling updateCategory.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('put', `${this.basePath}/category/${encodeURIComponent(String(categoryId))}`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: CategoryService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: CategoryService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: CategoryService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class CommentService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    addComment(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addComment.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/comment/`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    deleteComment(commentId, observe = 'body', reportProgress = false) {
        if (commentId === null || commentId === undefined) {
            throw new Error('Required parameter commentId was null or undefined when calling deleteComment.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('delete', `${this.basePath}/comment/${encodeURIComponent(String(commentId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: CommentService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: CommentService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: CommentService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class DashboardService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    createDashboard(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createDashboard.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/dashboard/`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    deleteDashboard(dashboardId, observe = 'body', reportProgress = false) {
        if (dashboardId === null || dashboardId === undefined) {
            throw new Error('Required parameter dashboardId was null or undefined when calling deleteDashboard.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('delete', `${this.basePath}/dashboard/${encodeURIComponent(String(dashboardId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getDashboardsForUserByGroupId(groupId, observe = 'body', reportProgress = false) {
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getDashboardsForUserByGroupId.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/dashboard/${encodeURIComponent(String(groupId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateDashboard(body, dashboardId, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateDashboard.');
        }
        if (dashboardId === null || dashboardId === undefined) {
            throw new Error('Required parameter dashboardId was null or undefined when calling updateDashboard.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('put', `${this.basePath}/dashboard/${encodeURIComponent(String(dashboardId))}`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: DashboardService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: DashboardService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: DashboardService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class FeatureConfigService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getFeatureConfig(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/featureConfig`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureConfigService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureConfigService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureConfigService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class GroupsService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    createGroup(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createGroup.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/group`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    deleteGroup(groupId, observe = 'body', reportProgress = false) {
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling deleteGroup.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('delete', `${this.basePath}/group/${encodeURIComponent(String(groupId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getGroupById(groupId, observe = 'body', reportProgress = false) {
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getGroupById.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/group/${encodeURIComponent(String(groupId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getGroupsForuser(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/group`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    pollGroupEmail(groupId, observe = 'body', reportProgress = false) {
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling pollGroupEmail.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('post', `${this.basePath}/group/${encodeURIComponent(String(groupId))}/pollGroupEmail`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateGroup(body, groupId, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateGroup.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling updateGroup.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('put', `${this.basePath}/group/${encodeURIComponent(String(groupId))}`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateGroupSettings(body, groupId, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateGroupSettings.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling updateGroupSettings.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('put', `${this.basePath}/group/${encodeURIComponent(String(groupId))}/groupSettings`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: GroupsService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: GroupsService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: GroupsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class NotificationsService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    deleteAllNotificationsForUser(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('delete', `${this.basePath}/notifications/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    deleteNotificationById(notificationId, observe = 'body', reportProgress = false) {
        if (notificationId === null || notificationId === undefined) {
            throw new Error('Required parameter notificationId was null or undefined when calling deleteNotificationById.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('delete', `${this.basePath}/notifications/${encodeURIComponent(String(notificationId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getNotificationCount(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/notifications/notificationCount`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getNotificationsForuser(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/notifications/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: NotificationsService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: NotificationsService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: NotificationsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * CustomHttpUrlEncodingCodec
 * Fix plus sign (+) not encoding, so sent as blank space
 * See: https://github.com/angular/angular/issues/11058#issuecomment-247367318
 */
class CustomHttpUrlEncodingCodec extends HttpUrlEncodingCodec {
    encodeKey(k) {
        k = super.encodeKey(k);
        return k.replace(/\+/gi, '%2B');
    }
    encodeValue(v) {
        v = super.encodeValue(v);
        return v.replace(/\+/gi, '%2B');
    }
}

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class ReceiptService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    bulkReceiptStatusUpdate(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling bulkReceiptStatusUpdate.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/receipt/bulkStatusUpdate`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    createReceipt(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createReceipt.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/receipt/`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    deleteReceiptById(receiptId, observe = 'body', reportProgress = false) {
        if (receiptId === null || receiptId === undefined) {
            throw new Error('Required parameter receiptId was null or undefined when calling deleteReceiptById.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('delete', `${this.basePath}/receipt/${encodeURIComponent(String(receiptId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    duplicateReceipt(receiptId, observe = 'body', reportProgress = false) {
        if (receiptId === null || receiptId === undefined) {
            throw new Error('Required parameter receiptId was null or undefined when calling duplicateReceipt.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('post', `${this.basePath}/receipt/${encodeURIComponent(String(receiptId))}/duplicate`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getReceiptById(receiptId, observe = 'body', reportProgress = false) {
        if (receiptId === null || receiptId === undefined) {
            throw new Error('Required parameter receiptId was null or undefined when calling getReceiptById.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/receipt/${encodeURIComponent(String(receiptId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getReceiptsForGroup(body, groupId, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling getReceiptsForGroup.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling getReceiptsForGroup.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/receipt/group/${encodeURIComponent(String(groupId))}`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    hasAccessToReceipt(receiptId, groupRole, observe = 'body', reportProgress = false) {
        if (receiptId === null || receiptId === undefined) {
            throw new Error('Required parameter receiptId was null or undefined when calling hasAccessToReceipt.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (receiptId !== undefined && receiptId !== null) {
            queryParameters = queryParameters.set('receiptId', receiptId);
        }
        if (groupRole !== undefined && groupRole !== null) {
            queryParameters = queryParameters.set('groupRole', groupRole);
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/receipt/hasAccess`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    quickScanReceiptForm(file, groupId, paidByUserId, status, observe = 'body', reportProgress = false) {
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling quickScanReceipt.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling quickScanReceipt.');
        }
        if (paidByUserId === null || paidByUserId === undefined) {
            throw new Error('Required parameter paidByUserId was null or undefined when calling quickScanReceipt.');
        }
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling quickScanReceipt.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'multipart/form-data'
        ];
        const canConsumeForm = this.canConsumeForm(consumes);
        let formParams;
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        }
        else {
            formParams = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        }
        if (file !== undefined) {
            formParams = formParams.append('file', file) || formParams;
        }
        if (groupId !== undefined) {
            formParams = formParams.append('groupId', groupId) || formParams;
        }
        if (paidByUserId !== undefined) {
            formParams = formParams.append('paidByUserId', paidByUserId) || formParams;
        }
        if (status !== undefined) {
            formParams = formParams.append('status', status) || formParams;
        }
        return this.httpClient.request('post', `${this.basePath}/receipt/quickScan`, {
            body: convertFormParamsToString ? formParams.toString() : formParams,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateReceipt(body, receiptId, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateReceipt.');
        }
        if (receiptId === null || receiptId === undefined) {
            throw new Error('Required parameter receiptId was null or undefined when calling updateReceipt.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('put', `${this.basePath}/receipt/${encodeURIComponent(String(receiptId))}`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ReceiptService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ReceiptService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ReceiptService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class ReceiptImageService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    convertToJpgForm(file, observe = 'body', reportProgress = false) {
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling convertToJpg.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'multipart/form-data'
        ];
        const canConsumeForm = this.canConsumeForm(consumes);
        let formParams;
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        }
        else {
            formParams = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        }
        if (file !== undefined) {
            formParams = formParams.append('file', file) || formParams;
        }
        return this.httpClient.request('post', `${this.basePath}/receiptImage/convertToJpg`, {
            body: convertFormParamsToString ? formParams.toString() : formParams,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    deleteReceiptImageById(receiptImageId, observe = 'body', reportProgress = false) {
        if (receiptImageId === null || receiptImageId === undefined) {
            throw new Error('Required parameter receiptImageId was null or undefined when calling deleteReceiptImageById.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('delete', `${this.basePath}/receiptImage/${encodeURIComponent(String(receiptImageId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getReceiptImageById(receiptImageId, observe = 'body', reportProgress = false) {
        if (receiptImageId === null || receiptImageId === undefined) {
            throw new Error('Required parameter receiptImageId was null or undefined when calling getReceiptImageById.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/receiptImage/${encodeURIComponent(String(receiptImageId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    magicFillReceiptForm(file, receiptImageId, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (receiptImageId !== undefined && receiptImageId !== null) {
            queryParameters = queryParameters.set('receiptImageId', receiptImageId);
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'multipart/form-data'
        ];
        const canConsumeForm = this.canConsumeForm(consumes);
        let formParams;
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        }
        else {
            formParams = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        }
        if (file !== undefined) {
            formParams = formParams.append('file', file) || formParams;
        }
        return this.httpClient.request('post', `${this.basePath}/receiptImage/magicFill`, {
            body: convertFormParamsToString ? formParams.toString() : formParams,
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    uploadReceiptImageForm(file, receiptId, encodedImage, observe = 'body', reportProgress = false) {
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling uploadReceiptImage.');
        }
        if (receiptId === null || receiptId === undefined) {
            throw new Error('Required parameter receiptId was null or undefined when calling uploadReceiptImage.');
        }
        if (encodedImage === null || encodedImage === undefined) {
            throw new Error('Required parameter encodedImage was null or undefined when calling uploadReceiptImage.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'multipart/form-data'
        ];
        const canConsumeForm = this.canConsumeForm(consumes);
        let formParams;
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        }
        else {
            formParams = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        }
        if (file !== undefined) {
            formParams = formParams.append('file', file) || formParams;
        }
        if (receiptId !== undefined) {
            formParams = formParams.append('receiptId', receiptId) || formParams;
        }
        if (encodedImage !== undefined) {
            formParams = formParams.append('encodedImage', encodedImage) || formParams;
        }
        return this.httpClient.request('post', `${this.basePath}/receiptImage/`, {
            body: convertFormParamsToString ? formParams.toString() : formParams,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ReceiptImageService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ReceiptImageService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ReceiptImageService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class SearchService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    receiptSearch(searchTerm, observe = 'body', reportProgress = false) {
        if (searchTerm === null || searchTerm === undefined) {
            throw new Error('Required parameter searchTerm was null or undefined when calling receiptSearch.');
        }
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (searchTerm !== undefined && searchTerm !== null) {
            queryParameters = queryParameters.set('searchTerm', searchTerm);
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/search/`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: SearchService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: SearchService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: SearchService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class TagService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    createTag(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createTag.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/tag/`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    deleteTag(tagId, observe = 'body', reportProgress = false) {
        if (tagId === null || tagId === undefined) {
            throw new Error('Required parameter tagId was null or undefined when calling deleteTag.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('delete', `${this.basePath}/tag/${encodeURIComponent(String(tagId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getAllTags(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/tag/`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getPagedTags(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling getPagedTags.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/tag/getPagedTags`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getTagCountByName(tagName, observe = 'body', reportProgress = false) {
        if (tagName === null || tagName === undefined) {
            throw new Error('Required parameter tagName was null or undefined when calling getTagCountByName.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'text/plain'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/tag/${encodeURIComponent(String(tagName))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateTag(body, tagId, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateTag.');
        }
        if (tagId === null || tagId === undefined) {
            throw new Error('Required parameter tagId was null or undefined when calling updateTag.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('put', `${this.basePath}/tag/${encodeURIComponent(String(tagId))}`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: TagService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: TagService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: TagService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class UserService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    convertDummyUserById(body, userId, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling convertDummyUserById.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling convertDummyUserById.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/user/${encodeURIComponent(String(userId))}/convertDummyUserToNormalUser`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    createUser(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createUser.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/user`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    deleteUserById(userId, observe = 'body', reportProgress = false) {
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling deleteUserById.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('delete', `${this.basePath}/user/${encodeURIComponent(String(userId))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getAmountOwedForUser(groupId, receiptIds, observe = 'body', reportProgress = false) {
        let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
        if (groupId !== undefined && groupId !== null) {
            queryParameters = queryParameters.set('groupId', groupId);
        }
        if (receiptIds) {
            receiptIds.forEach((element) => {
                queryParameters = queryParameters.append('receiptIds', element);
            });
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/user/amountOwedForUser`, {
            params: queryParameters,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getUserClaims(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/user/getUserClaims`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getUsernameCount(username, observe = 'body', reportProgress = false) {
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getUsernameCount.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/user/${encodeURIComponent(String(username))}`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    getUsers(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/user`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    resetPasswordById(body, userId, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling resetPasswordById.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling resetPasswordById.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('post', `${this.basePath}/user/${encodeURIComponent(String(userId))}/resetPassword`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateUserById(body, userId, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateUserById.');
        }
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUserById.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('put', `${this.basePath}/user/${encodeURIComponent(String(userId))}`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateUserProfile(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateUserProfile.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('put', `${this.basePath}/user/updateUserProfile`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */
class UserPreferencesService {
    constructor(httpClient, basePath, configuration) {
        this.httpClient = httpClient;
        this.basePath = '/api';
        this.defaultHeaders = new HttpHeaders();
        this.configuration = new Configuration();
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }
    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    canConsumeForm(consumes) {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }
    getUserPreferences(observe = 'body', reportProgress = false) {
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [];
        return this.httpClient.request('get', `${this.basePath}/userPreferences`, {
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    updateUserPreferences(body, observe = 'body', reportProgress = false) {
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateUserPreferences.');
        }
        let headers = this.defaultHeaders;
        // authentication (bearerAuth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }
        // to determine the Accept header
        let httpHeaderAccepts = [
            'application/json'
        ];
        const httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }
        // to determine the Content-Type header
        const consumes = [
            'application/json'
        ];
        const httpContentTypeSelected = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }
        return this.httpClient.request('put', `${this.basePath}/userPreferences`, {
            body: body,
            withCredentials: this.configuration.withCredentials,
            headers: headers,
            observe: observe,
            reportProgress: reportProgress
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserPreferencesService, deps: [{ token: i1.HttpClient }, { token: BASE_PATH, optional: true }, { token: Configuration, optional: true }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserPreferencesService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserPreferencesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BASE_PATH]
                }] }, { type: Configuration, decorators: [{
                    type: Optional
                }] }]; } });

const APIS = [AuthService, CategoryService, CommentService, DashboardService, FeatureConfigService, GroupsService, NotificationsService, ReceiptService, ReceiptImageService, SearchService, TagService, UserService, UserPreferencesService];

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

var Group;
(function (Group) {
    Group.StatusEnum = {
        ACTIVE: 'ACTIVE',
        ARCHIVED: 'ARCHIVED'
    };
})(Group || (Group = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var GroupMember;
(function (GroupMember) {
    GroupMember.GroupRoleEnum = {
        OWNER: 'OWNER',
        VIEWER: 'VIEWER',
        EDITOR: 'EDITOR'
    };
})(GroupMember || (GroupMember = {}));

var GroupSettings;
(function (GroupSettings) {
    GroupSettings.EmailDefaultReceiptStatusEnum = {
        OPEN: 'OPEN',
        NEEDSATTENTION: 'NEEDS_ATTENTION',
        RESOLVED: 'RESOLVED',
        DRAFT: 'DRAFT'
    };
})(GroupSettings || (GroupSettings = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var Item;
(function (Item) {
    Item.StatusEnum = {
        OPEN: 'OPEN',
        RESOLVED: 'RESOLVED',
        DRAFT: 'DRAFT'
    };
})(Item || (Item = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var PagedRequestCommand;
(function (PagedRequestCommand) {
    PagedRequestCommand.SortDirectionEnum = {
        Asc: 'asc',
        Desc: 'desc',
        Empty: ''
    };
})(PagedRequestCommand || (PagedRequestCommand = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var PagedRequestField;
(function (PagedRequestField) {
    PagedRequestField.OperationEnum = {
        CONTAINS: 'CONTAINS',
        EQUALS: 'EQUALS',
        GREATERTHAN: 'GREATER_THAN',
        LESSTHAN: 'LESS_THAN'
    };
})(PagedRequestField || (PagedRequestField = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var QuickScanCommand;
(function (QuickScanCommand) {
    QuickScanCommand.StatusEnum = {
        OPEN: 'OPEN',
        NEEDSATTENTION: 'NEEDS_ATTENTION',
        RESOLVED: 'RESOLVED',
        DRAFT: 'DRAFT'
    };
})(QuickScanCommand || (QuickScanCommand = {}));

var Receipt;
(function (Receipt) {
    Receipt.StatusEnum = {
        OPEN: 'OPEN',
        NEEDSATTENTION: 'NEEDS_ATTENTION',
        RESOLVED: 'RESOLVED',
        DRAFT: 'DRAFT'
    };
})(Receipt || (Receipt = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

var ReceiptPagedRequestCommand;
(function (ReceiptPagedRequestCommand) {
    ReceiptPagedRequestCommand.SortDirectionEnum = {
        Asc: 'asc',
        Desc: 'desc',
        Empty: ''
    };
})(ReceiptPagedRequestCommand || (ReceiptPagedRequestCommand = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

var UpdateGroupSettingsCommand;
(function (UpdateGroupSettingsCommand) {
    UpdateGroupSettingsCommand.EmailDefaultReceiptStatusEnum = {
        OPEN: 'OPEN',
        NEEDSATTENTION: 'NEEDS_ATTENTION',
        RESOLVED: 'RESOLVED',
        DRAFT: 'DRAFT'
    };
})(UpdateGroupSettingsCommand || (UpdateGroupSettingsCommand = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var UpsertWidgetCommand;
(function (UpsertWidgetCommand) {
    UpsertWidgetCommand.WidgetTypeEnum = {
        GROUPSUMMARY: 'GROUP_SUMMARY',
        FILTEREDRECEIPTS: 'FILTERED_RECEIPTS'
    };
})(UpsertWidgetCommand || (UpsertWidgetCommand = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var User;
(function (User) {
    User.UserRoleEnum = {
        ADMIN: 'ADMIN',
        USER: 'USER'
    };
})(User || (User = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var UserPreferences;
(function (UserPreferences) {
    UserPreferences.QuickScanDefaultStatusEnum = {
        OPEN: 'OPEN',
        NEEDSATTENTION: 'NEEDS_ATTENTION',
        RESOLVED: 'RESOLVED',
        DRAFT: 'DRAFT'
    };
})(UserPreferences || (UserPreferences = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var UserView;
(function (UserView) {
    UserView.UserRoleEnum = {
        ADMIN: 'ADMIN',
        USER: 'USER'
    };
})(UserView || (UserView = {}));

/**
 * Receipt Wrangler API.
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var Widget;
(function (Widget) {
    Widget.WidgetTypeEnum = {
        GROUPSUMMARY: 'GROUP_SUMMARY',
        FILTEREDRECEIPTS: 'FILTERED_RECEIPTS'
    };
})(Widget || (Widget = {}));

class ApiModule {
    static forRoot(configurationFactory) {
        return {
            ngModule: ApiModule,
            providers: [{ provide: Configuration, useFactory: configurationFactory }]
        };
    }
    constructor(parentModule, http) {
        if (parentModule) {
            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');
        }
        if (!http) {
            throw new Error('You need to import the HttpClientModule in your AppModule! \n' +
                'See also https://github.com/angular/angular/issues/20575');
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ApiModule, deps: [{ token: ApiModule, optional: true, skipSelf: true }, { token: i1.HttpClient, optional: true }], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.11", ngImport: i0, type: ApiModule }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ApiModule, providers: [
            AuthService,
            CategoryService,
            CommentService,
            DashboardService,
            FeatureConfigService,
            GroupsService,
            NotificationsService,
            ReceiptService,
            ReceiptImageService,
            SearchService,
            TagService,
            UserService,
            UserPreferencesService
        ] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ApiModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [],
                    declarations: [],
                    exports: [],
                    providers: [
                        AuthService,
                        CategoryService,
                        CommentService,
                        DashboardService,
                        FeatureConfigService,
                        GroupsService,
                        NotificationsService,
                        ReceiptService,
                        ReceiptImageService,
                        SearchService,
                        TagService,
                        UserService,
                        UserPreferencesService
                    ]
                }]
        }], ctorParameters: function () { return [{ type: ApiModule, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i1.HttpClient, decorators: [{
                    type: Optional
                }] }]; } });

class AddGroup {
    static { this.type = '[Group] Add Group'; }
    constructor(group) {
        this.group = group;
    }
}
class RemoveGroup {
    static { this.type = '[Group] Remove Group'; }
    constructor(groupId) {
        this.groupId = groupId;
    }
}
class SetGroups {
    static { this.type = '[Group] Set Groups'; }
    constructor(groups) {
        this.groups = groups;
    }
}
class UpdateGroup {
    static { this.type = '[Group] Update Group'; }
    constructor(group) {
        this.group = group;
    }
}
class SetSelectedDashboardId {
    static { this.type = '[Group] Set Selected Dashboard Id'; }
    constructor(dashboardId) {
        this.dashboardId = dashboardId;
    }
}
class SetSelectedGroupId {
    static { this.type = '[Group] Set Selected Group Id'; }
    constructor(groupId) {
        this.groupId = groupId;
    }
}

var GroupState_1;
let GroupState = GroupState_1 = class GroupState {
    static groups(state) {
        return state.groups;
    }
    static allGroupMembers(state) {
        return state.groups.map((g) => g.groupMembers).flat();
    }
    static groupsWithoutAll(state) {
        return state.groups.filter((g) => !g.isAllGroup);
    }
    static groupsWithoutSelectedGroup(state) {
        return state.groups.filter((g) => g.id.toString() !== state.selectedGroupId);
    }
    static selectedDashboardId(state) {
        return state.selectedDashboardId;
    }
    static selectedGroupId(state) {
        return state.selectedGroupId;
    }
    static receiptListLink(state) {
        return `/receipts/group/${state.selectedGroupId}`;
    }
    // TODO: needs to be fixed
    static dashboardLink(state) {
        return `/dashboard/group/${state.selectedGroupId}`;
    }
    static settingsLinkBase(state) {
        return `/groups/${state.selectedGroupId}/settings`;
    }
    static getGroupById(groupId) {
        return createSelector([GroupState_1], (state) => {
            return state.groups.find((g) => g.id.toString() === groupId.toString());
        });
    }
    addGroup({ getState, patchState }, payload) {
        const groups = Array.from(getState().groups);
        groups.push(payload.group);
        patchState({
            groups: groups,
        });
    }
    removeGroup({ getState, patchState }, payload) {
        const state = getState();
        const group = GroupState_1.getGroupById(payload.groupId)(state);
        if (group) {
            const index = state.groups.findIndex((g) => g === group);
            if (index >= 0) {
                const newInterface = {};
                const newGroups = Array.from(state.groups).filter((g) => g.id !== group.id);
                newInterface.groups = newGroups;
                if (group.id.toString() === state.selectedGroupId.toString()) {
                    newInterface.selectedGroupId = state.groups[0].id.toString();
                }
                patchState(newInterface);
            }
        }
    }
    setGroups({ patchState }, payload) {
        patchState({
            groups: payload.groups,
        });
    }
    updateGroup({ getState, patchState }, payload) {
        const groupIndex = getState().groups.findIndex((g) => g.id?.toString() === payload?.group?.id?.toString());
        if (groupIndex > -1) {
            const newGroups = Array.from(getState().groups);
            newGroups[groupIndex] = payload.group;
            patchState({
                groups: newGroups,
            });
        }
    }
    setSelectedDashboardId({ getState, patchState }, payload) {
        patchState({
            selectedDashboardId: payload.dashboardId,
        });
    }
    setSelectedGroupId({ getState, patchState }, payload) {
        let groupId = '';
        let dashboardId = '';
        if (payload?.groupId) {
            groupId = payload.groupId;
        }
        else {
            const groups = getState().groups;
            groupId = groups[0].id.toString();
        }
        if (payload.groupId === getState().selectedGroupId) {
            dashboardId = getState().selectedDashboardId;
        }
        patchState({
            selectedGroupId: groupId,
            selectedDashboardId: dashboardId,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: GroupState, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: GroupState }); }
};
__decorate([
    Action(AddGroup),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, AddGroup]),
    __metadata("design:returntype", void 0)
], GroupState.prototype, "addGroup", null);
__decorate([
    Action(RemoveGroup),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, RemoveGroup]),
    __metadata("design:returntype", void 0)
], GroupState.prototype, "removeGroup", null);
__decorate([
    Action(SetGroups),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, SetGroups]),
    __metadata("design:returntype", void 0)
], GroupState.prototype, "setGroups", null);
__decorate([
    Action(UpdateGroup),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, UpdateGroup]),
    __metadata("design:returntype", void 0)
], GroupState.prototype, "updateGroup", null);
__decorate([
    Action(SetSelectedDashboardId),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, SetSelectedDashboardId]),
    __metadata("design:returntype", void 0)
], GroupState.prototype, "setSelectedDashboardId", null);
__decorate([
    Action(SetSelectedGroupId),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, SetSelectedGroupId]),
    __metadata("design:returntype", void 0)
], GroupState.prototype, "setSelectedGroupId", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Array)
], GroupState, "groups", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Array)
], GroupState, "allGroupMembers", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Array)
], GroupState, "groupsWithoutAll", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Array)
], GroupState, "groupsWithoutSelectedGroup", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", String)
], GroupState, "selectedDashboardId", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", String)
], GroupState, "selectedGroupId", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", String)
], GroupState, "receiptListLink", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", String)
], GroupState, "dashboardLink", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", String)
], GroupState, "settingsLinkBase", null);
GroupState = GroupState_1 = __decorate([
    State({
        name: 'groups',
        defaults: {
            groups: [],
            selectedGroupId: '',
            selectedDashboardId: '',
        },
    })
], GroupState);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: GroupState, decorators: [{
            type: Injectable
        }], propDecorators: { addGroup: [], removeGroup: [], setGroups: [], updateGroup: [], setSelectedDashboardId: [], setSelectedGroupId: [] } });

class UserValidators {
    constructor(userService) {
        this.userService = userService;
    }
    uniqueUsername(threshold, originalValue) {
        return (control) => {
            return this.userService.getUsernameCount(control.value).pipe(map((usernameCount) => {
                if (usernameCount > threshold && control.value !== originalValue) {
                    return { duplicate: true };
                }
                return null;
            }));
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserValidators, deps: [{ token: UserService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserValidators }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserValidators, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: UserService }]; } });

class SetFeatureConfig {
    static { this.type = '[FeatureConfig] Set Feature Config'; }
    constructor(config) {
        this.config = config;
    }
}

class SetUsers {
    static { this.type = '[User] Set Users'; }
    constructor(users) {
        this.users = users;
    }
}
class UpdateUser {
    static { this.type = '[User] Update User'; }
    constructor(userId, user) {
        this.userId = userId;
        this.user = user;
    }
}
class AddUser {
    static { this.type = '[User] Add User'; }
    constructor(user) {
        this.user = user;
    }
}
class RemoveUser {
    static { this.type = '[User] Remove User'; }
    constructor(userId) {
        this.userId = userId;
    }
}

class SetAuthState {
    static { this.type = '[Auth] Set Auth State'; }
    constructor(userClaims) {
        this.userClaims = userClaims;
    }
}
class SetUserPreferences {
    static { this.type = '[Auth] Set User PReferences'; }
    constructor(userPreferences) {
        this.userPreferences = userPreferences;
    }
}
class Logout {
    static { this.type = '[Auth] Logout'; }
}

class ClaimsService {
    constructor(store, userService) {
        this.store = store;
        this.userService = userService;
    }
    getAndSetClaimsForLoggedInUser() {
        return this.userService.getUserClaims().pipe(take(1), switchMap((claims) => this.store.dispatch(new SetAuthState(claims))));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ClaimsService, deps: [{ token: i1$1.Store }, { token: UserService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ClaimsService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ClaimsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.Store }, { type: UserService }]; } });

var AuthState_1;
let AuthState = AuthState_1 = class AuthState {
    static userPreferences(state) {
        return state.userPreferences;
    }
    static userRole(state) {
        return state.userRole ?? '';
    }
    static isLoggedIn(state) {
        return !AuthState_1.isTokenExpired(state);
    }
    static userId(state) {
        return state.userId ?? '';
    }
    static isTokenExpired(state) {
        if (state.expirationDate) {
            return new Date() >= new Date(Number(state.expirationDate) * 1000);
        }
        else {
            return true;
        }
    }
    static loggedInUser(state) {
        return {
            defaultAvatarColor: state.defaultAvatarColor ?? '',
            displayName: state.displayname ?? '',
            id: Number(state.userId) ?? '',
            username: state.username ?? '',
        };
    }
    static hasRole(role) {
        return createSelector([AuthState_1], (state) => {
            return state.userRole === role;
        });
    }
    setAuthState({ getState, patchState }, payload) {
        const claims = payload.userClaims;
        patchState({
            defaultAvatarColor: claims['DefaultAvatarColor'],
            displayname: claims['Displayname'],
            expirationDate: claims['exp']?.toString(),
            userId: claims['UserId']?.toString(),
            username: claims['Username'],
            userRole: claims['UserRole'],
        });
    }
    logout({ getState, patchState }) {
        patchState({
            defaultAvatarColor: '',
            displayname: '',
            expirationDate: '',
            userId: '',
            username: '',
            userRole: undefined,
            userPreferences: undefined,
        });
    }
    setUserPreferences({ patchState }, payload) {
        patchState({
            userPreferences: payload.userPreferences,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthState, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthState }); }
};
__decorate([
    Action(SetAuthState),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, SetAuthState]),
    __metadata("design:returntype", void 0)
], AuthState.prototype, "setAuthState", null);
__decorate([
    Action(Logout),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], AuthState.prototype, "logout", null);
__decorate([
    Action(SetUserPreferences),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, SetUserPreferences]),
    __metadata("design:returntype", void 0)
], AuthState.prototype, "setUserPreferences", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Object)
], AuthState, "userPreferences", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", String)
], AuthState, "userRole", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Boolean)
], AuthState, "isLoggedIn", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", String)
], AuthState, "userId", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Boolean)
], AuthState, "isTokenExpired", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Object)
], AuthState, "loggedInUser", null);
AuthState = AuthState_1 = __decorate([
    State({
        name: 'auth',
        defaults: {},
    })
], AuthState);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthState, decorators: [{
            type: Injectable
        }], propDecorators: { setAuthState: [], logout: [], setUserPreferences: [] } });

var FeatureConfigState_1;
let FeatureConfigState = FeatureConfigState_1 = class FeatureConfigState {
    static enableLocalSignUp(state) {
        return state.enableLocalSignUp;
    }
    static aiPoweredReceipts(state) {
        return state.aiPoweredReceipts;
    }
    static hasFeature(feature) {
        return createSelector([FeatureConfigState_1], (state) => {
            return !!state[feature];
        });
    }
    setFeatureConfig({ patchState }, payload) {
        patchState({
            aiPoweredReceipts: payload.config?.aiPoweredReceipts,
            enableLocalSignUp: payload.config?.enableLocalSignUp,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureConfigState, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureConfigState }); }
};
__decorate([
    Action(SetFeatureConfig),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, SetFeatureConfig]),
    __metadata("design:returntype", void 0)
], FeatureConfigState.prototype, "setFeatureConfig", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Boolean)
], FeatureConfigState, "enableLocalSignUp", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Boolean)
], FeatureConfigState, "aiPoweredReceipts", null);
FeatureConfigState = FeatureConfigState_1 = __decorate([
    State({
        name: 'featureConfig',
        defaults: { enableLocalSignUp: true, aiPoweredReceipts: false },
    })
], FeatureConfigState);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureConfigState, decorators: [{
            type: Injectable
        }], propDecorators: { setFeatureConfig: [] } });

var UserState_1;
let UserState = UserState_1 = class UserState {
    static users(state) {
        return state.users;
    }
    static getUserById(userId) {
        return createSelector([UserState_1], (state) => {
            return state.users.find((u) => u.id.toString() === userId.toString());
        });
    }
    static findUserById(userId) {
        return createSelector([UserState_1], (state) => {
            return state.users.find((u) => u.id.toString() === userId.toString());
        });
    }
    static findUserIndexById(userId, users) {
        return users.findIndex((u) => u.id.toString() === userId);
    }
    setUsers({ getState, patchState }, payload) {
        patchState({
            users: payload.users,
        });
    }
    updateUser({ getState, patchState }, payload) {
        const users = Array.from(getState().users);
        const index = UserState_1.findUserIndexById(payload.userId, users);
        if (index >= 0) {
            users.splice(index, 1, payload.user);
            patchState({
                users: users,
            });
        }
    }
    addUser({ getState, patchState }, payload) {
        const users = Array.from(getState().users);
        users.push(payload.user);
        patchState({
            users: users,
        });
    }
    removeUser({ getState, patchState }, payload) {
        const users = Array.from(getState().users);
        patchState({
            users: users.filter((u) => u.id.toString() !== payload.userId.toString()),
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserState, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserState }); }
};
__decorate([
    Action(SetUsers),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, SetUsers]),
    __metadata("design:returntype", void 0)
], UserState.prototype, "setUsers", null);
__decorate([
    Action(UpdateUser),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, UpdateUser]),
    __metadata("design:returntype", void 0)
], UserState.prototype, "updateUser", null);
__decorate([
    Action(AddUser),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, AddUser]),
    __metadata("design:returntype", void 0)
], UserState.prototype, "addUser", null);
__decorate([
    Action(RemoveUser),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, RemoveUser]),
    __metadata("design:returntype", void 0)
], UserState.prototype, "removeUser", null);
__decorate([
    Selector(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Array)
], UserState, "users", null);
UserState = UserState_1 = __decorate([
    State({
        name: 'users',
        defaults: {
            users: [],
        },
    })
], UserState);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: UserState, decorators: [{
            type: Injectable
        }], propDecorators: { setUsers: [], updateUser: [], addUser: [], removeUser: [] } });

class AppInitService {
    constructor(authService, claimsService, featureConfigService, groupsService, store, userService, userPreferencesService) {
        this.authService = authService;
        this.claimsService = claimsService;
        this.featureConfigService = featureConfigService;
        this.groupsService = groupsService;
        this.store = store;
        this.userService = userService;
        this.userPreferencesService = userPreferencesService;
    }
    initAppData() {
        return new Promise((resolve) => {
            this.featureConfigService
                .getFeatureConfig()
                .pipe(take(1), switchMap((config) => this.store.dispatch(new SetFeatureConfig(config))), catchError((err) => {
                resolve(false);
                return err;
            }), switchMap(() => this.authService.getNewRefreshToken()), switchMap(() => this.getAppData()), tap(() => resolve(true)))
                .subscribe();
        });
    }
    getAppData() {
        const usersCall = this.userService.getUsers().pipe(take(1), tap((users) => this.store.dispatch(new SetUsers(users))));
        const groupsCall = this.groupsService.getGroupsForuser().pipe(take(1), tap((groups) => {
            this.store.dispatch(new SetGroups(groups));
            const groupId = this.store.selectSnapshot(GroupState.selectedGroupId);
            if (!groupId) {
                this.store.dispatch(new SetSelectedGroupId());
            }
        }));
        const userClaims = this.claimsService.getAndSetClaimsForLoggedInUser();
        const userPreferencesCall = this.userPreferencesService
            .getUserPreferences()
            .pipe(take(1), tap((userPreferences) => {
            this.store.dispatch(new SetUserPreferences(userPreferences));
        }));
        return forkJoin(usersCall, groupsCall, userClaims, userPreferencesCall);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AppInitService, deps: [{ token: AuthService }, { token: ClaimsService }, { token: FeatureConfigService }, { token: GroupsService }, { token: i1$1.Store }, { token: UserService }, { token: UserPreferencesService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AppInitService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AppInitService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: AuthService }, { type: ClaimsService }, { type: FeatureConfigService }, { type: GroupsService }, { type: i1$1.Store }, { type: UserService }, { type: UserPreferencesService }]; } });
function initAppData(appInitService) {
    return () => appInitService.initAppData();
}

const DEFAULT_SNACKBAR_ACTION = 'Ok';
const DEFAULT_SNACKBAR_CONFIG = {
    horizontalPosition: 'center',
    verticalPosition: 'top',
    duration: 3000,
};

class SnackbarService {
    constructor(snackbar) {
        this.snackbar = snackbar;
    }
    error(message) {
        this.snackbar.open(message, DEFAULT_SNACKBAR_ACTION, {
            ...DEFAULT_SNACKBAR_CONFIG,
            panelClass: ['error-snackbar'],
        });
    }
    success(message, configOverrides) {
        this.snackbar.open(message, DEFAULT_SNACKBAR_ACTION, {
            ...DEFAULT_SNACKBAR_CONFIG,
            ...configOverrides,
            panelClass: ['success-snackbar'],
        });
    }
    successFromTemplate(template, configOverrides) {
        return this.snackbar.openFromTemplate(template, {
            ...DEFAULT_SNACKBAR_CONFIG,
            ...configOverrides,
            panelClass: ['success-snackbar'],
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: SnackbarService, deps: [{ token: i1$2.MatSnackBar }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: SnackbarService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: SnackbarService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$2.MatSnackBar }]; } });

class AuthFormUtil {
    constructor(authService, snackbarService, appInitService) {
        this.authService = authService;
        this.snackbarService = snackbarService;
        this.appInitService = appInitService;
    }
    getSubmitObservable(form, isSignUp) {
        const isValid = form.valid;
        if (isValid && isSignUp) {
            return this.authService.signUp(form.value).pipe(tap(() => {
                this.snackbarService.success('User successfully signed up');
            }), catchError((err) => of(this.snackbarService.error(err.error['username'] ?? err['errMsg']))));
        }
        else if (isValid && !isSignUp) {
            return this.authService.login(form.value).pipe(tap(() => {
                this.snackbarService.success('Successfully logged in');
            }), switchMap(() => this.appInitService.getAppData()), map(() => undefined));
        }
        else {
            return of(undefined);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthFormUtil, deps: [{ token: AuthService }, { token: SnackbarService }, { token: AppInitService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthFormUtil }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthFormUtil, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: AuthService }, { type: SnackbarService }, { type: AppInitService }]; } });

class ButtonComponent {
    constructor() {
        this.buttonClass = '';
        this.color = 'primary';
        this.buttonText = '';
        this.type = 'button';
        this.matButtonType = 'matRaisedButton';
        this.icon = '';
        this.customIcon = '';
        this.disabled = false;
        this.buttonRouterLink = [];
        this.tooltip = '';
        this.matBadgeColor = 'primary';
        this.clicked = new EventEmitter();
    }
    emitClicked(event) {
        this.clicked.emit(event);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.11", type: ButtonComponent, selector: "app-button", inputs: { buttonClass: "buttonClass", color: "color", buttonText: "buttonText", type: "type", matButtonType: "matButtonType", icon: "icon", customIcon: "customIcon", disabled: "disabled", buttonRouterLink: "buttonRouterLink", tooltip: "tooltip", matBadgeContent: "matBadgeContent", matBadgeColor: "matBadgeColor" }, outputs: { clicked: "clicked" }, ngImport: i0, template: "<ng-container [ngSwitch]=\"matButtonType\">\n  <button\n    mat-button\n    *ngSwitchCase=\"'basic'\"\n    [class]=\"buttonClass\"\n    [type]=\"type\"\n    [color]=\"color\"\n    [disabled]=\"disabled\"\n    [matTooltip]=\"tooltip\"\n    [routerLink]=\"buttonRouterLink\"\n    [matBadgeColor]=\"matBadgeColor\"\n    [matBadge]=\"matBadgeContent\"\n    (click)=\"emitClicked($event)\"\n  >\n    <div class=\"d-flex align-items-center\">\n      <mat-icon *ngIf=\"icon\" class=\"me-1\">\n        {{ icon }}\n      </mat-icon>\n      <span>\n        {{ buttonText }}\n      </span>\n    </div>\n  </button>\n\n  <button\n    mat-raised-button\n    *ngSwitchCase=\"'matRaisedButton'\"\n    [class]=\"buttonClass\"\n    [type]=\"type\"\n    [color]=\"color\"\n    [disabled]=\"disabled\"\n    [matTooltip]=\"tooltip\"\n    [matBadgeColor]=\"matBadgeColor\"\n    [matBadge]=\"matBadgeContent\"\n    [routerLink]=\"buttonRouterLink\"\n    (click)=\"emitClicked($event)\"\n  >\n    <div class=\"d-flex align-items-center\">\n      <mat-icon *ngIf=\"icon\" class=\"me-1\">\n        {{ icon }}\n      </mat-icon>\n      <span>\n        {{ buttonText }}\n      </span>\n    </div>\n  </button>\n\n  <button\n    mat-icon-button\n    *ngSwitchCase=\"'iconButton'\"\n    [class]=\"buttonClass\"\n    [type]=\"type\"\n    [color]=\"color\"\n    [disabled]=\"disabled\"\n    [routerLink]=\"buttonRouterLink\"\n    [matTooltip]=\"tooltip\"\n    [matBadgeColor]=\"matBadgeColor\"\n    [matBadge]=\"matBadgeContent\"\n    (click)=\"emitClicked($event)\"\n  >\n    <mat-icon *ngIf=\"customIcon\" [svgIcon]=\"customIcon\"></mat-icon>\n    <mat-icon *ngIf=\"icon\">\n      {{ icon }}\n    </mat-icon>\n  </button>\n</ng-container>\n", styles: ["app-button{width:-moz-fit-content;width:fit-content}app-button .mat-badge-content{color:#fff}\n"], dependencies: [{ kind: "directive", type: i1$3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1$3.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { kind: "directive", type: i1$3.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { kind: "directive", type: i2.MatBadge, selector: "[matBadge]", inputs: ["matBadgeDisabled", "matBadgeColor", "matBadgeOverlap", "matBadgePosition", "matBadge", "matBadgeDescription", "matBadgeSize", "matBadgeHidden"] }, { kind: "component", type: i3.MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i3.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i3$1.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }], encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-button', encapsulation: ViewEncapsulation.None, template: "<ng-container [ngSwitch]=\"matButtonType\">\n  <button\n    mat-button\n    *ngSwitchCase=\"'basic'\"\n    [class]=\"buttonClass\"\n    [type]=\"type\"\n    [color]=\"color\"\n    [disabled]=\"disabled\"\n    [matTooltip]=\"tooltip\"\n    [routerLink]=\"buttonRouterLink\"\n    [matBadgeColor]=\"matBadgeColor\"\n    [matBadge]=\"matBadgeContent\"\n    (click)=\"emitClicked($event)\"\n  >\n    <div class=\"d-flex align-items-center\">\n      <mat-icon *ngIf=\"icon\" class=\"me-1\">\n        {{ icon }}\n      </mat-icon>\n      <span>\n        {{ buttonText }}\n      </span>\n    </div>\n  </button>\n\n  <button\n    mat-raised-button\n    *ngSwitchCase=\"'matRaisedButton'\"\n    [class]=\"buttonClass\"\n    [type]=\"type\"\n    [color]=\"color\"\n    [disabled]=\"disabled\"\n    [matTooltip]=\"tooltip\"\n    [matBadgeColor]=\"matBadgeColor\"\n    [matBadge]=\"matBadgeContent\"\n    [routerLink]=\"buttonRouterLink\"\n    (click)=\"emitClicked($event)\"\n  >\n    <div class=\"d-flex align-items-center\">\n      <mat-icon *ngIf=\"icon\" class=\"me-1\">\n        {{ icon }}\n      </mat-icon>\n      <span>\n        {{ buttonText }}\n      </span>\n    </div>\n  </button>\n\n  <button\n    mat-icon-button\n    *ngSwitchCase=\"'iconButton'\"\n    [class]=\"buttonClass\"\n    [type]=\"type\"\n    [color]=\"color\"\n    [disabled]=\"disabled\"\n    [routerLink]=\"buttonRouterLink\"\n    [matTooltip]=\"tooltip\"\n    [matBadgeColor]=\"matBadgeColor\"\n    [matBadge]=\"matBadgeContent\"\n    (click)=\"emitClicked($event)\"\n  >\n    <mat-icon *ngIf=\"customIcon\" [svgIcon]=\"customIcon\"></mat-icon>\n    <mat-icon *ngIf=\"icon\">\n      {{ icon }}\n    </mat-icon>\n  </button>\n</ng-container>\n", styles: ["app-button{width:-moz-fit-content;width:fit-content}app-button .mat-badge-content{color:#fff}\n"] }]
        }], propDecorators: { buttonClass: [{
                type: Input
            }], color: [{
                type: Input
            }], buttonText: [{
                type: Input
            }], type: [{
                type: Input
            }], matButtonType: [{
                type: Input
            }], icon: [{
                type: Input
            }], customIcon: [{
                type: Input
            }], disabled: [{
                type: Input
            }], buttonRouterLink: [{
                type: Input
            }], tooltip: [{
                type: Input
            }], matBadgeContent: [{
                type: Input
            }], matBadgeColor: [{
                type: Input
            }], clicked: [{
                type: Output
            }] } });

/**
 * Add the template content to the DOM unless the condition is true.
 */
class FeatureDirective {
    constructor(templateRef, viewContainer, store) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.store = store;
        this.hasView = false;
    }
    set appFeature(feature) {
        const hasFeature = this.store.selectSnapshot(FeatureConfigState.hasFeature(feature));
        if (hasFeature) {
            this.viewContainer.createEmbeddedView(this.templateRef);
            this.hasView = true;
        }
        else if (!hasFeature) {
            this.viewContainer.clear();
            this.hasView = false;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureDirective, deps: [{ token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: i1$1.Store }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.11", type: FeatureDirective, selector: "[appFeature]", inputs: { appFeature: "appFeature" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[appFeature]' }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: i1$1.Store }]; }, propDecorators: { appFeature: [{
                type: Input
            }] } });

class BaseInputComponent {
    constructor() {
        this.inputFormControl = new FormControl();
        this.label = '';
        this.readonly = false;
        this.errorMessages = {};
    }
    ngOnInit() {
        this.errorMessages = {
            required: `${this.label} is required.`,
            email: `${this.label} must be a valid email address.`,
            duplicate: `${this.label} must be unique.`,
            min: `Value must be larger than 0`,
        };
        this.formControlErrors = this.inputFormControl.statusChanges.pipe(startWith(this.inputFormControl.status), map(() => {
            const errors = this.inputFormControl.errors;
            if (errors) {
                const keys = Object.keys(this.inputFormControl.errors);
                return keys.map((k) => {
                    const value = errors[k];
                    let message = '';
                    if (typeof value === 'string') {
                        message = value;
                    }
                    else if (this.errorMessages[k]) {
                        message = this.errorMessages[k];
                    }
                    return {
                        error: k,
                        message: message,
                    };
                });
            }
            else {
                return [];
            }
        }));
        if (this.additionalErrorMessages) {
            this.errorMessages = {
                ...this.errorMessages,
                ...this.additionalErrorMessages,
            };
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: BaseInputComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.11", type: BaseInputComponent, selector: "app-base-input", inputs: { inputFormControl: "inputFormControl", label: "label", additionalErrorMessages: "additionalErrorMessages", readonly: "readonly", placeholder: "placeholder" }, ngImport: i0, template: "<p>base-input works!</p>\n", styles: [""] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: BaseInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-base-input', template: "<p>base-input works!</p>\n" }]
        }], propDecorators: { inputFormControl: [{
                type: Input
            }], label: [{
                type: Input
            }], additionalErrorMessages: [{
                type: Input
            }], readonly: [{
                type: Input
            }], placeholder: [{
                type: Input
            }] } });

class InputComponent extends BaseInputComponent {
    constructor() {
        super(...arguments);
        this.inputId = '';
        this.type = 'text';
        this.showVisibilityEye = false;
        this.isCurrency = false;
        this.mask = '';
        this.maskPrefix = '';
        this.thousandSeparator = '';
        this.inputBlur = new EventEmitter(undefined);
    }
    ngOnChanges(changes) {
        if (changes['isCurrency']?.currentValue) {
            this.maskPrefix = '$ ';
            this.mask = 'separator.2';
            this.thousandSeparator = ',';
        }
    }
    toggleVisibility() {
        if (this.type !== 'password') {
            this.type = 'password';
        }
        else {
            this.type = 'text';
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: InputComponent, deps: null, target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.11", type: InputComponent, selector: "app-input", inputs: { inputId: "inputId", type: "type", showVisibilityEye: "showVisibilityEye", isCurrency: "isCurrency", mask: "mask", maskPrefix: "maskPrefix", thousandSeparator: "thousandSeparator" }, outputs: { inputBlur: "inputBlur" }, viewQueries: [{ propertyName: "nativeInput", first: true, predicate: ["nativeInput"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<mat-form-field class=\"w-100\">\n  <mat-label>{{ label }}</mat-label>\n  <div class=\"d-flex align-items-center\">\n    <input\n      #nativeInput\n      matInput\n      [id]=\"inputId\"\n      [type]=\"type\"\n      [readonly]=\"readonly\"\n      [formControl]=\"inputFormControl\"\n      [prefix]=\"maskPrefix\"\n      [mask]=\"mask\"\n      [thousandSeparator]=\"thousandSeparator\"\n      (blur)=\"inputBlur.emit($event)\"\n    />\n    <button\n      *ngIf=\"showVisibilityEye\"\n      mat-icon-button\n      type=\"button\"\n      [matTooltip]=\"type === 'password' ? 'Show ' + label : 'Hide ' + label\"\n      (click)=\"toggleVisibility()\"\n    >\n      <mat-icon *ngIf=\"type === 'password'\">visibility</mat-icon>\n      <mat-icon *ngIf=\"type !== 'password'\">visibility_off</mat-icon>\n    </button>\n  </div>\n  <mat-error *ngFor=\"let err of formControlErrors | async\">{{\n    err.message\n  }}</mat-error>\n</mat-form-field>\n", styles: [""], dependencies: [{ kind: "directive", type: i1$3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1$3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i3.MatIconButton, selector: "button[mat-icon-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { kind: "component", type: i3$2.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i3$2.MatLabel, selector: "mat-label" }, { kind: "directive", type: i3$2.MatError, selector: "mat-error, [matError]", inputs: ["id"] }, { kind: "component", type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { kind: "directive", type: i5$1.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "directive", type: i5.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { kind: "directive", type: i7.NgxMaskDirective, selector: "input[mask], textarea[mask]", inputs: ["mask", "specialCharacters", "patterns", "prefix", "suffix", "thousandSeparator", "decimalMarker", "dropSpecialCharacters", "hiddenInput", "showMaskTyped", "placeHolderCharacter", "shownMaskExpression", "showTemplate", "clearIfNotMatch", "validation", "separatorLimit", "allowNegativeNumbers", "leadZeroDateTime", "leadZero", "triggerOnMaskChange", "apm", "inputTransformFn", "outputTransformFn", "keepCharacterPositions"], outputs: ["maskFilled"], exportAs: ["mask", "ngxMask"] }, { kind: "directive", type: i2$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2$1.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "pipe", type: i1$3.AsyncPipe, name: "async" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: InputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'app-input', template: "<mat-form-field class=\"w-100\">\n  <mat-label>{{ label }}</mat-label>\n  <div class=\"d-flex align-items-center\">\n    <input\n      #nativeInput\n      matInput\n      [id]=\"inputId\"\n      [type]=\"type\"\n      [readonly]=\"readonly\"\n      [formControl]=\"inputFormControl\"\n      [prefix]=\"maskPrefix\"\n      [mask]=\"mask\"\n      [thousandSeparator]=\"thousandSeparator\"\n      (blur)=\"inputBlur.emit($event)\"\n    />\n    <button\n      *ngIf=\"showVisibilityEye\"\n      mat-icon-button\n      type=\"button\"\n      [matTooltip]=\"type === 'password' ? 'Show ' + label : 'Hide ' + label\"\n      (click)=\"toggleVisibility()\"\n    >\n      <mat-icon *ngIf=\"type === 'password'\">visibility</mat-icon>\n      <mat-icon *ngIf=\"type !== 'password'\">visibility_off</mat-icon>\n    </button>\n  </div>\n  <mat-error *ngFor=\"let err of formControlErrors | async\">{{\n    err.message\n  }}</mat-error>\n</mat-form-field>\n" }]
        }], propDecorators: { nativeInput: [{
                type: ViewChild,
                args: ['nativeInput']
            }], inputId: [{
                type: Input
            }], type: [{
                type: Input
            }], showVisibilityEye: [{
                type: Input
            }], isCurrency: [{
                type: Input
            }], mask: [{
                type: Input
            }], maskPrefix: [{
                type: Input
            }], thousandSeparator: [{
                type: Input
            }], inputBlur: [{
                type: Output
            }] } });

class FormGetPipe {
    transform(form, path) {
        const result = form.get(path);
        if (result) {
            return result;
        }
        else {
            return new FormControl();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FormGetPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.2.11", ngImport: i0, type: FormGetPipe, name: "formGet" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FormGetPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'formGet',
                }]
        }] });

class AuthForm {
    constructor(authFormUtil, formBuilder, route, router, store, userValidators) {
        this.authFormUtil = authFormUtil;
        this.formBuilder = formBuilder;
        this.route = route;
        this.router = router;
        this.store = store;
        this.userValidators = userValidators;
        this.emitSubmit = false;
        this.submitted = new EventEmitter();
        this.form = new FormGroup({});
        this.isSignUp = new BehaviorSubject(false);
        this.headerText = '';
        this.primaryButtonText = '';
        this.secondaryButtonText = '';
        this.secondaryButtonRouterLink = [];
    }
    ngOnInit() {
        this.initForm();
        this.listenForRouteChanges();
        this.listenForIsSignUpChanges();
    }
    listenForRouteChanges() {
        this.route.data
            .pipe(tap((data) => {
            this.isSignUp.next(!!data?.['isSignUp']);
        }))
            .subscribe();
    }
    listenForIsSignUpChanges() {
        this.isSignUp
            .pipe(tap((isSignUp) => {
            if (isSignUp) {
                this.headerText = 'Sign Up';
                this.primaryButtonText = 'Sign Up';
                this.secondaryButtonRouterLink = ['/auth/login'];
                this.secondaryButtonText = 'Back to Login';
                this.form
                    .get('username')
                    ?.addAsyncValidators(this.userValidators.uniqueUsername(0, ''));
                this.form.addControl('displayname', new FormControl('', Validators.required));
            }
            else {
                this.headerText = 'Login';
                this.primaryButtonText = 'Login';
                this.secondaryButtonRouterLink = ['/auth/sign-up'];
                this.secondaryButtonText = 'Sign Up';
                this.form
                    .get('username')
                    ?.removeAsyncValidators(this.userValidators.uniqueUsername(0, ''));
                this.form.removeControl('displayname');
            }
        }))
            .subscribe();
    }
    initForm() {
        this.form = this.formBuilder.group({
            username: ['', [Validators.required]],
            password: ['', Validators.required],
        });
    }
    submit() {
        if (this.emitSubmit) {
            this.submitted.emit();
        }
        else {
            const isSignUp = this.isSignUp.getValue();
            this.authFormUtil
                .getSubmitObservable(this.form, isSignUp)
                .pipe(take(1), tap(() => {
                this.router.navigate([
                    this.store.selectSnapshot(GroupState.dashboardLink),
                ]);
            }))
                .subscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthForm, deps: [{ token: AuthFormUtil }, { token: i2$1.FormBuilder }, { token: i3$1.ActivatedRoute }, { token: i3$1.Router }, { token: i1$1.Store }, { token: UserValidators }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.11", type: AuthForm, selector: "app-auth-form", inputs: { additionalFieldsTemplate: "additionalFieldsTemplate", emitSubmit: "emitSubmit" }, outputs: { submitted: "submitted" }, providers: [UserValidators], ngImport: i0, template: "<div class=\"d-flex align-items-center justify-content-center\">\n  <form [formGroup]=\"form\" (ngSubmit)=\"submit()\">\n    <h2>{{ headerText }}</h2>\n    <div class=\"d-flex flex-column\">\n      <ng-template\n        *ngIf=\"additionalFieldsTemplate\"\n        [ngTemplateOutlet]=\"additionalFieldsTemplate\"\n      ></ng-template>\n      <ng-container *ngIf=\"isSignUp | async\">\n        <app-input\n          label=\"Displayname\"\n          [inputFormControl]=\"form | formGet : 'displayname'\"\n        >\n        </app-input>\n      </ng-container>\n      <app-input\n        label=\"Username\"\n        [inputFormControl]=\"form | formGet : 'username'\"\n      >\n      </app-input>\n      <app-input\n        label=\"Password\"\n        type=\"password\"\n        [showVisibilityEye]=\"true\"\n        [inputFormControl]=\"form | formGet : 'password'\"\n      >\n      </app-input>\n    </div>\n    <div class=\"w-100 d-flex flex-column\">\n      <app-button\n        class=\"w-100\"\n        buttonClass=\"w-100 mb-2\"\n        type=\"submit\"\n        [buttonText]=\"primaryButtonText\"\n      ></app-button>\n      <app-button\n        *appFeature=\"'enableLocalSignUp'\"\n        class=\"w-100\"\n        buttonClass=\"w-100 \"\n        type=\"button\"\n        color=\"accent\"\n        [buttonText]=\"secondaryButtonText\"\n        [routerLink]=\"secondaryButtonRouterLink\"\n      ></app-button>\n    </div>\n  </form>\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i3$1.RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "component", type: ButtonComponent, selector: "app-button", inputs: ["buttonClass", "color", "buttonText", "type", "matButtonType", "icon", "customIcon", "disabled", "buttonRouterLink", "tooltip", "matBadgeContent", "matBadgeColor"], outputs: ["clicked"] }, { kind: "directive", type: i1$3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1$3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: FeatureDirective, selector: "[appFeature]", inputs: ["appFeature"] }, { kind: "component", type: InputComponent, selector: "app-input", inputs: ["inputId", "type", "showVisibilityEye", "isCurrency", "mask", "maskPrefix", "thousandSeparator"], outputs: ["inputBlur"] }, { kind: "directive", type: i2$1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { kind: "directive", type: i2$1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { kind: "directive", type: i2$1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { kind: "pipe", type: i1$3.AsyncPipe, name: "async" }, { kind: "pipe", type: FormGetPipe, name: "formGet" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthForm, decorators: [{
            type: Component,
            args: [{ selector: 'app-auth-form', providers: [UserValidators], template: "<div class=\"d-flex align-items-center justify-content-center\">\n  <form [formGroup]=\"form\" (ngSubmit)=\"submit()\">\n    <h2>{{ headerText }}</h2>\n    <div class=\"d-flex flex-column\">\n      <ng-template\n        *ngIf=\"additionalFieldsTemplate\"\n        [ngTemplateOutlet]=\"additionalFieldsTemplate\"\n      ></ng-template>\n      <ng-container *ngIf=\"isSignUp | async\">\n        <app-input\n          label=\"Displayname\"\n          [inputFormControl]=\"form | formGet : 'displayname'\"\n        >\n        </app-input>\n      </ng-container>\n      <app-input\n        label=\"Username\"\n        [inputFormControl]=\"form | formGet : 'username'\"\n      >\n      </app-input>\n      <app-input\n        label=\"Password\"\n        type=\"password\"\n        [showVisibilityEye]=\"true\"\n        [inputFormControl]=\"form | formGet : 'password'\"\n      >\n      </app-input>\n    </div>\n    <div class=\"w-100 d-flex flex-column\">\n      <app-button\n        class=\"w-100\"\n        buttonClass=\"w-100 mb-2\"\n        type=\"submit\"\n        [buttonText]=\"primaryButtonText\"\n      ></app-button>\n      <app-button\n        *appFeature=\"'enableLocalSignUp'\"\n        class=\"w-100\"\n        buttonClass=\"w-100 \"\n        type=\"button\"\n        color=\"accent\"\n        [buttonText]=\"secondaryButtonText\"\n        [routerLink]=\"secondaryButtonRouterLink\"\n      ></app-button>\n    </div>\n  </form>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: AuthFormUtil }, { type: i2$1.FormBuilder }, { type: i3$1.ActivatedRoute }, { type: i3$1.Router }, { type: i1$1.Store }, { type: UserValidators }]; }, propDecorators: { additionalFieldsTemplate: [{
                type: Input
            }], emitSubmit: [{
                type: Input
            }], submitted: [{
                type: Output
            }] } });

class FeatureGuard {
    constructor(store) {
        this.store = store;
    }
    canActivate(route, state) {
        return this.store.selectSnapshot(FeatureConfigState.hasFeature(route.data['feature']));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureGuard, deps: [{ token: i1$1.Store }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureGuard, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: FeatureGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.Store }]; } });

const authRoutes = [
    {
        path: 'sign-up',
        component: AuthForm,
        data: {
            isSignUp: true,
            feature: 'enableLocalSignUp',
        },
        canActivate: [FeatureGuard],
    },
    {
        path: 'login',
        component: AuthForm,
    },
];
class AuthRoutingModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthRoutingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.11", ngImport: i0, type: AuthRoutingModule, imports: [i3$1.RouterModule], exports: [RouterModule] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthRoutingModule, imports: [RouterModule.forChild(authRoutes), RouterModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthRoutingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [RouterModule.forChild(authRoutes)],
                    exports: [RouterModule],
                }]
        }] });

class ButtonModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ButtonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.11", ngImport: i0, type: ButtonModule, declarations: [ButtonComponent], imports: [CommonModule,
            MatBadgeModule,
            MatButtonModule,
            MatIconModule,
            MatTooltipModule,
            RouterModule], exports: [ButtonComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ButtonModule, imports: [CommonModule,
            MatBadgeModule,
            MatButtonModule,
            MatIconModule,
            MatTooltipModule,
            RouterModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: ButtonModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ButtonComponent],
                    imports: [
                        CommonModule,
                        MatBadgeModule,
                        MatButtonModule,
                        MatIconModule,
                        MatTooltipModule,
                        RouterModule,
                    ],
                    exports: [ButtonComponent],
                }]
        }] });

class RoleDirective {
    constructor(templateRef, viewContainer, store) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.store = store;
        this.hasView = false;
    }
    set appRole(role) {
        const hasRole = this.store.selectSnapshot(AuthState.hasRole(role));
        if (hasRole) {
            this.viewContainer.createEmbeddedView(this.templateRef);
            this.hasView = true;
        }
        else if (!hasRole) {
            this.viewContainer.clear();
            this.hasView = false;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: RoleDirective, deps: [{ token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: i1$1.Store }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.11", type: RoleDirective, selector: "[appRole]", inputs: { appRole: "appRole" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: RoleDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[appRole]' }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: i1$1.Store }]; }, propDecorators: { appRole: [{
                type: Input
            }] } });

class DirectivesModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: DirectivesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.11", ngImport: i0, type: DirectivesModule, declarations: [RoleDirective, FeatureDirective], imports: [CommonModule], exports: [RoleDirective, FeatureDirective] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: DirectivesModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: DirectivesModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [RoleDirective, FeatureDirective],
                    imports: [CommonModule],
                    exports: [RoleDirective, FeatureDirective],
                }]
        }] });

class InputModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: InputModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.11", ngImport: i0, type: InputModule, declarations: [InputComponent], imports: [CommonModule,
            MatButtonModule,
            MatFormFieldModule,
            MatIconModule,
            MatInputModule,
            MatTooltipModule,
            NgxMaskDirective,
            ReactiveFormsModule], exports: [InputComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: InputModule, providers: [provideNgxMask()], imports: [CommonModule,
            MatButtonModule,
            MatFormFieldModule,
            MatIconModule,
            MatInputModule,
            MatTooltipModule,
            ReactiveFormsModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: InputModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [InputComponent],
                    imports: [
                        CommonModule,
                        MatButtonModule,
                        MatFormFieldModule,
                        MatIconModule,
                        MatInputModule,
                        MatTooltipModule,
                        NgxMaskDirective,
                        ReactiveFormsModule,
                    ],
                    exports: [InputComponent],
                    providers: [provideNgxMask()],
                }]
        }] });

class PipesModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: PipesModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.11", ngImport: i0, type: PipesModule, declarations: [FormGetPipe], imports: [CommonModule], exports: [FormGetPipe] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: PipesModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: PipesModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [FormGetPipe],
                    imports: [CommonModule],
                    exports: [FormGetPipe],
                }]
        }] });

class AuthModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.11", ngImport: i0, type: AuthModule, declarations: [AuthForm], imports: [AuthRoutingModule,
            ButtonModule,
            CommonModule,
            DirectivesModule,
            InputModule,
            PipesModule,
            ReactiveFormsModule], exports: [AuthForm] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthModule, imports: [AuthRoutingModule,
            ButtonModule,
            CommonModule,
            DirectivesModule,
            InputModule,
            PipesModule,
            ReactiveFormsModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [AuthForm],
                    imports: [
                        AuthRoutingModule,
                        ButtonModule,
                        CommonModule,
                        DirectivesModule,
                        InputModule,
                        PipesModule,
                        ReactiveFormsModule,
                    ],
                    exports: [AuthForm],
                }]
        }] });

class BaseInputModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: BaseInputModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.11", ngImport: i0, type: BaseInputModule, declarations: [BaseInputComponent], imports: [CommonModule], exports: [BaseInputComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: BaseInputModule, imports: [CommonModule] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: BaseInputModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [BaseInputComponent],
                    imports: [CommonModule],
                    exports: [BaseInputComponent],
                }]
        }] });

class AuthGuard {
    constructor(router, store) {
        this.router = router;
        this.store = store;
    }
    canActivate(route, state) {
        const isLoggedIn = this.store.selectSnapshot(AuthState.isLoggedIn);
        const navigatingToAuth = route.url.toString().includes('auth');
        // if user tries to go to login screens while already logged in
        if (navigatingToAuth && isLoggedIn) {
            this.router.navigate([
                this.store.selectSnapshot(GroupState.dashboardLink),
            ]);
            return false;
        }
        else if (navigatingToAuth && !isLoggedIn) {
            return true;
        }
        if (!isLoggedIn) {
            this.router.navigate(['/auth/login']);
        }
        return isLoggedIn;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthGuard, deps: [{ token: i3$1.Router }, { token: i1$1.Store }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthGuard, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.11", ngImport: i0, type: AuthGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i3$1.Router }, { type: i1$1.Store }]; } });

/*
 * Public API Surface of core
 */

/**
 * Generated bundle index. Do not edit.
 */

export { APIS, AddGroup, AddUser, ApiModule, AppInitService, AuthForm, AuthFormUtil, AuthGuard, AuthModule, AuthRoutingModule, AuthService, AuthState, BASE_PATH, BaseInputComponent, BaseInputModule, ButtonComponent, ButtonModule, COLLECTION_FORMATS, CategoryService, ClaimsService, CommentService, Configuration, DEFAULT_SNACKBAR_ACTION, DEFAULT_SNACKBAR_CONFIG, DashboardService, DirectivesModule, FeatureConfigService, FeatureConfigState, FeatureDirective, FeatureGuard, FormGetPipe, Group, GroupMember, GroupSettings, GroupState, GroupsService, InputComponent, InputModule, Item, Logout, NotificationsService, PagedRequestCommand, PagedRequestField, PipesModule, QuickScanCommand, Receipt, ReceiptImageService, ReceiptPagedRequestCommand, ReceiptService, RemoveGroup, RemoveUser, RoleDirective, SearchService, SetAuthState, SetFeatureConfig, SetGroups, SetSelectedDashboardId, SetSelectedGroupId, SetUserPreferences, SetUsers, SnackbarService, TagService, UpdateGroup, UpdateGroupSettingsCommand, UpdateUser, UpsertWidgetCommand, User, UserPreferences, UserPreferencesService, UserService, UserState, UserValidators, UserView, Widget, authRoutes, fadeInOut, initAppData };
//# sourceMappingURL=receipt-wrangler-receipt-wrangler-core.mjs.map
