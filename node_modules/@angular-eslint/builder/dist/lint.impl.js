"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const devkit_1 = require("@nx/devkit");
const fs_1 = require("fs");
const path_1 = require("path");
const eslint_utils_1 = require("./utils/eslint-utils");
exports.default = (0, devkit_1.convertNxExecutor)(async (options, context) => {
    var _a, _b, _c, _d;
    const systemRoot = context.root;
    // eslint resolves files relative to the current working directory.
    // We want these paths to always be resolved relative to the workspace
    // root to be able to run the lint executor from any subfolder.
    process.chdir(systemRoot);
    const projectName = context.projectName || '<???>';
    const printInfo = options.format && !options.silent;
    if (printInfo) {
        console.info(`\nLinting ${JSON.stringify(projectName)}...`);
    }
    /**
     * We want users to have the option of not specifying the config path, and let
     * eslint automatically resolve the `.eslintrc.json` files in each folder.
     */
    const eslintConfigPath = options.eslintConfig
        ? (0, path_1.resolve)(systemRoot, options.eslintConfig)
        : undefined;
    options.cacheLocation = options.cacheLocation
        ? (0, path_1.join)(options.cacheLocation, projectName)
        : null;
    /**
     * Until ESLint v9 is released and the new so called flat config is the default
     * we only want to support it if the user has explicitly opted into it by converting
     * their root ESLint config to use eslint.config.js
     */
    const useFlatConfig = (0, fs_1.existsSync)((0, devkit_1.joinPathFragments)(devkit_1.workspaceRoot, 'eslint.config.js'));
    const { eslint, ESLint } = await (0, eslint_utils_1.resolveAndInstantiateESLint)(eslintConfigPath, options, useFlatConfig);
    const version = (_a = ESLint === null || ESLint === void 0 ? void 0 : ESLint.version) === null || _a === void 0 ? void 0 : _a.split('.');
    if (!version ||
        version.length < 2 ||
        Number(version[0]) < 7 ||
        (Number(version[0]) === 7 && Number(version[1]) < 6)) {
        throw new Error('ESLint must be version 7.6 or higher.');
    }
    let lintResults = [];
    try {
        lintResults = await eslint.lintFiles(options.lintFilePatterns);
    }
    catch (err) {
        if (err instanceof Error &&
            err.message.includes('You must therefore provide a value for the "parserOptions.project" property for @typescript-eslint/parser')) {
            let eslintConfigPathForError = `for ${projectName}`;
            if ((_d = (_c = (_b = context.projectsConfigurations) === null || _b === void 0 ? void 0 : _b.projects) === null || _c === void 0 ? void 0 : _c[projectName]) === null || _d === void 0 ? void 0 : _d.root) {
                const { root } = context.projectsConfigurations.projects[projectName];
                eslintConfigPathForError = `\`${root}/.eslintrc.json\``;
            }
            console.error(`
Error: You have attempted to use a lint rule which requires the full TypeScript type-checker to be available, but you do not have \`parserOptions.project\` configured to point at your project tsconfig.json files in the relevant TypeScript file "overrides" block of your project ESLint config ${eslintConfigPath || eslintConfigPathForError}

For full guidance on how to resolve this issue, please see https://github.com/angular-eslint/angular-eslint/blob/main/docs/RULES_REQUIRING_TYPE_INFORMATION.md
`);
            return {
                success: false,
            };
        }
        // If some unexpected error, rethrow
        throw err;
    }
    if (lintResults.length === 0) {
        const ignoredPatterns = (await Promise.all(options.lintFilePatterns.map(async (pattern) => (await eslint.isPathIgnored(pattern)) ? pattern : null)))
            .filter((pattern) => !!pattern)
            .map((pattern) => `- '${pattern}'`);
        if (ignoredPatterns.length) {
            throw new Error(`All files matching the following patterns are ignored:\n${ignoredPatterns.join('\n')}\n\nPlease check your '.eslintignore' file.`);
        }
        throw new Error('Invalid lint configuration. Nothing to lint. Please check your lint target pattern(s).');
    }
    // output fixes to disk, if applicable based on the options
    await ESLint.outputFixes(lintResults);
    const formatter = await eslint.loadFormatter(options.format);
    let totalErrors = 0;
    let totalWarnings = 0;
    const reportOnlyErrors = options.quiet;
    const maxWarnings = options.maxWarnings;
    /**
     * Depending on user configuration we may not want to report on all the
     * results, so we need to adjust them before formatting.
     */
    const finalLintResults = lintResults
        .map((result) => {
        totalErrors += result.errorCount;
        totalWarnings += result.warningCount;
        if (result.errorCount || (result.warningCount && !reportOnlyErrors)) {
            if (reportOnlyErrors) {
                // Collect only errors (Linter.Severity === 2)
                result.messages = result.messages.filter(({ severity }) => severity === 2);
            }
            return result;
        }
        return null;
    })
        // Filter out the null values
        .filter(Boolean);
    const hasWarningsToPrint = totalWarnings > 0 && !reportOnlyErrors;
    const hasErrorsToPrint = totalErrors > 0;
    /**
     * It's important that we format all results together so that custom
     * formatters, such as checkstyle, can provide a valid output for the
     * whole project being linted.
     *
     * Additionally, apart from when outputting to a file, we want to always
     * log (even when no results) because different formatters handled the
     * "no results" case differently.
     */
    const formattedResults = await formatter.format(finalLintResults);
    if (options.outputFile) {
        const pathToOutputFile = (0, path_1.join)(context.root, options.outputFile);
        (0, fs_1.mkdirSync)((0, path_1.dirname)(pathToOutputFile), { recursive: true });
        (0, fs_1.writeFileSync)(pathToOutputFile, formattedResults);
    }
    else {
        console.info(formattedResults);
    }
    if (hasWarningsToPrint && printInfo) {
        console.warn('Lint warnings found in the listed files.\n');
    }
    if (hasErrorsToPrint && printInfo) {
        console.error('Lint errors found in the listed files.\n');
    }
    if ((totalWarnings === 0 || reportOnlyErrors) &&
        totalErrors === 0 &&
        printInfo) {
        console.info('All files pass linting.\n');
    }
    const tooManyWarnings = maxWarnings >= 0 && totalWarnings > maxWarnings;
    if (tooManyWarnings && printInfo) {
        console.error(`Found ${totalWarnings} warnings, which exceeds your configured limit (${options.maxWarnings}). Either increase your maxWarnings limit or fix some of the lint warnings.`);
    }
    return {
        success: options.force || (totalErrors === 0 && !tooManyWarnings),
    };
});
